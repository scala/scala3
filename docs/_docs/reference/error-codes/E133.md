---
title: E133: Overload In Refinement
kind: Error
---
# E133: Overload In Refinement

This error occurs when a refinement type introduces an overloaded definition.

In Scala, refinement types (structural types) can add or refine members of a base type. However, they cannot introduce overloaded methods because refinements are meant to describe structural constraints, not create new method signatures that would conflict with existing ones. Adding an overload would change the semantics of method resolution in ways that are not supported by refinement types.

---

## Example

```scala sc:fail sc-opts:-explain
trait Base:
  def foo(x: Int): Int

type Refined = Base { def foo(x: String): String }
```

### Error

```scala sc:nocompile
-- [E133] Declaration Error: example.scala:4:26 --------------------------------
4 |type Refined = Base { def foo(x: String): String }
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |                      Refinements cannot introduce overloaded definitions
  |-----------------------------------------------------------------------------
  | Explanation (enabled by `-explain`)
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  | The refinement `method foo` introduces an overloaded definition.
  | Refinements cannot contain overloaded definitions.
   -----------------------------------------------------------------------------
```

### Solution

```scala sc:compile sc-opts:-Werror
// Use a different method name in the refinement
trait Base:
  def foo(x: Int): Int

type Refined = Base { def bar(x: String): String }
```

```scala sc:compile sc-opts:-Werror
// Alternative: Define a trait with both methods instead of using refinement
trait Base:
  def foo(x: Int): Int

trait Refined extends Base:
  def foo(x: String): String
```

