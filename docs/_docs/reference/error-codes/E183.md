---
title: "E183: Closure Cannot Have Internal Parameter Dependencies"
kind: Error
since: 3.4.0
---
# E183: Closure Cannot Have Internal Parameter Dependencies

This error occurs when you try to create a closure (anonymous function) where one parameter's type depends on another parameter from the same parameter list. This is called a "parameter dependency" and is not supported for closures.

In Scala, closures are converted to function types like `Function1`, `Function2`, etc. These standard function types cannot represent dependent parameter types, where the type of one parameter refers to another parameter using `.type` (singleton types).

This limitation applies to both polymorphic closures (with type parameters like `[T]`) and monomorphic closures.

## Example

```scala sc:fail
def example = [T] => (x: T, y: List[x.type]) => List(y)
```

Here, the type of parameter `y` is `List[x.type]`, which depends on the value of parameter `x`. This internal dependency between parameters in the same list makes it impossible to represent this closure as a standard function type.

### Error

```scala sc:nocompile
-- [E183] Type Error: example.scala:1:18 ---------------------------------------
1 |def example = [T] => (x: T, y: List[x.type]) => List(y)
  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |cannot turn method type [T](x: T, y: List[(x : T)]): List[List[(x : T)]] into closure
  |because it has internal parameter dependencies
```

### Solution

There are two common approaches to work around this limitation:

**1. Use a regular method instead of a closure**

Convert the closure to a named method definition:

```scala sc:compile sc-opts:-Werror
def example[T](x: T, y: List[x.type]): List[List[x.type]] = List(y)
```

**2. Use curried parameters**

Split the dependent parameters into separate parameter lists. The dependent parameter can then reference parameters from earlier lists:

```scala sc:compile sc-opts:-Werror
def curriedExample = [T] => (x: T) => (y: List[x.type]) => List(y)
```

This works because each parameter list produces a separate closure, and the inner closure captures `x` from its enclosing scope rather than having a parameter-to-parameter dependency.
