expect/Access.scala
-------------------

Summary:
Schema => SemanticDB v4
Uri => Access.scala
Text => empty
Language => Scala
Symbols => 9 entries
Occurrences => 19 entries

Symbols:
example/Access# => class Access extends Object { self: Access => +8 decls }
example/Access#`<init>`(). => primary ctor <init> (): Access
example/Access#m1(). => private[this] method m1 => Nothing
example/Access#m2(). => private[this] method m2 => Nothing
example/Access#m3(). => private[example/Access#] method m3 => Nothing
example/Access#m4(). => protected method m4 => Nothing
example/Access#m5(). => protected[this] method m5 => Nothing
example/Access#m6(). => protected[example/] method m6 => Nothing
example/Access#m7(). => method m7 => Nothing

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:12): Access <- example/Access#
[3:2..3:2): <- example/Access#`<init>`().
[3:14..3:16): m1 <- example/Access#m1().
[3:19..3:22): ??? -> scala/Predef.`???`().
[4:20..4:22): m2 <- example/Access#m2().
[4:25..4:28): ??? -> scala/Predef.`???`().
[5:10..5:16): Access -> example/Access#
[5:22..5:24): m3 <- example/Access#m3().
[5:27..5:30): ??? -> scala/Predef.`???`().
[6:16..6:18): m4 <- example/Access#m4().
[6:21..6:24): ??? -> scala/Predef.`???`().
[7:22..7:24): m5 <- example/Access#m5().
[7:27..7:30): ??? -> scala/Predef.`???`().
[8:12..8:19): example -> example/
[8:25..8:27): m6 <- example/Access#m6().
[8:30..8:33): ??? -> scala/Predef.`???`().
[9:6..9:8): m7 <- example/Access#m7().
[9:11..9:14): ??? -> scala/Predef.`???`().

expect/Advanced.scala
---------------------

Summary:
Schema => SemanticDB v4
Uri => Advanced.scala
Text => empty
Language => Scala
Symbols => 61 entries
Occurrences => 143 entries
Synthetics => 3 entries

Symbols:
advanced/C# => class C [typeparam T ] extends Object { self: C[T] => +3 decls }
advanced/C#[T] => typeparam T 
advanced/C#`<init>`(). => primary ctor <init> [typeparam T ](): C[T]
advanced/C#t(). => method t => T
advanced/HKClass# => class HKClass [typeparam F [typeparam T ] <: [U] =>> Tuple2[U, T]] extends Object { self: HKClass[F] => +3 decls }
advanced/HKClass#[F] => typeparam F [typeparam T ] <: [U] =>> Tuple2[U, T]
advanced/HKClass#[F][T] => typeparam T 
advanced/HKClass#[F][U] => typeparam U 
advanced/HKClass#`<init>`(). => primary ctor <init> [typeparam F [typeparam T ] <: [U] =>> Tuple2[U, T]](): HKClass[F]
advanced/HKClass#`<init>`().[F][T] => typeparam T 
advanced/HKClass#`<init>`().[F][U] => typeparam U 
advanced/HKClass#foo(). => method foo [typeparam T , typeparam U ](param x: F[T, U]): String
advanced/HKClass#foo().(x) => param x: F[T, U]
advanced/HKClass#foo().[T] => typeparam T 
advanced/HKClass#foo().[U] => typeparam U 
advanced/Structural# => class Structural extends Object { self: Structural => +6 decls }
advanced/Structural#T# => trait T [typeparam A ] extends Object { self: T[A] => +4 decls }
advanced/Structural#T#[A] => typeparam A 
advanced/Structural#T#`<init>`(). => primary ctor <init> [typeparam A ](): T[A]
advanced/Structural#T#bar(). => method bar (param b: foo.B): Unit
advanced/Structural#T#bar().(b) => param b: foo.B
advanced/Structural#T#foo. => val method foo Object { type B  = A }
advanced/Structural#`<init>`(). => primary ctor <init> (): Structural
advanced/Structural#s1(). => method s1 => Object { abstract val method x Int }
advanced/Structural#s2(). => method s2 => Object { abstract val method x Int }
advanced/Structural#s3(). => method s3 => Object { abstract method m (param x: Int): Int }
advanced/Structural#s4(). => method s4 (param a: Int): Object { abstract val method x Int }
advanced/Structural#s4().(a) => param a: Int
advanced/Test. => final object Test extends Object { self: Test.type => +13 decls }
advanced/Test.bar(). => method bar => foo.A
advanced/Test.e. => val method e Wildcards
advanced/Test.e1. => val method e1 List[_] forSome { type _  }
advanced/Test.e1x. => val method e1x Any
advanced/Test.foo. => lazy val method foo Selectable { type A  = Int } & Selectable { abstract val method a A; type A  = Int }
advanced/Test.s. => val method s Structural
advanced/Test.s1. => val method s1 Object { abstract val method x Int }
advanced/Test.s1x. => val method s1x Int
advanced/Test.s2. => val method s2 Object { abstract val method x Int }
advanced/Test.s2x. => val method s2x Int
advanced/Test.s3. => val method s3 Object { abstract method m (param x: Int): Int }
advanced/Test.s3x. => val method s3x Int
advanced/Wildcards# => class Wildcards extends Object { self: Wildcards => +3 decls }
advanced/Wildcards#`<init>`(). => primary ctor <init> (): Wildcards
advanced/Wildcards#e1(). => method e1 => List[_] forSome { type _  }
advanced/Wildcards#e2(). => method e2 => List[_] forSome { type _  <: Int }
local0 => abstract val method x Int
local1 => abstract val method x Int
local2 => val method x Int
local3 => final class $anon extends Object { self: $anon => +2 decls }
local5 => param x: Int
local6 => abstract method m (param x: Int): Int
local7 => param x: Int
local8 => method m (param x: Int): Int
local9 => final class $anon extends Object { self: $anon => +2 decls }
local11 => abstract val method x Int
local12 => type B  = A
local13 => val local e3: List[local14]
local15 => val local e3x: local14
local16 => type A  = Int
local17 => type A  = Int
local18 => abstract val method a A

Occurrences:
[0:8..0:16): advanced <- advanced/
[2:7..2:12): scala -> scala/
[2:13..2:21): language -> scala/language.
[2:22..2:33): higherKinds -> scala/language.higherKinds.
[3:7..3:12): scala -> scala/
[3:13..3:21): language -> scala/language.
[3:22..3:37): reflectiveCalls -> scala/language.reflectiveCalls.
[5:7..5:12): scala -> scala/
[5:13..5:20): reflect -> scala/reflect/
[5:21..5:31): Selectable -> scala/reflect/Selectable.
[5:32..5:52): reflectiveSelectable -> scala/reflect/Selectable.reflectiveSelectable().
[7:6..7:7): C <- advanced/C#
[7:7..7:7): <- advanced/C#`<init>`().
[7:8..7:9): T <- advanced/C#[T]
[8:6..8:7): t <- advanced/C#t().
[8:9..8:10): T -> advanced/C#[T]
[8:13..8:16): ??? -> scala/Predef.`???`().
[11:6..11:16): Structural <- advanced/Structural#
[12:2..12:2): <- advanced/Structural#`<init>`().
[12:6..12:8): s1 <- advanced/Structural#s1().
[12:16..12:17): x <- local0
[12:19..12:22): Int -> scala/Int#
[12:27..12:30): ??? -> scala/Predef.`???`().
[13:6..13:8): s2 <- advanced/Structural#s2().
[13:16..13:17): x <- local1
[13:19..13:22): Int -> scala/Int#
[13:27..13:27): <- local3
[13:37..13:38): x <- local2
[13:40..13:43): Int -> scala/Int#
[13:46..13:49): ??? -> scala/Predef.`???`().
[14:6..14:8): s3 <- advanced/Structural#s3().
[14:16..14:17): m <- local6
[14:18..14:19): x <- local5
[14:21..14:24): Int -> scala/Int#
[14:27..14:30): Int -> scala/Int#
[14:35..14:35): <- local9
[14:45..14:46): m <- local8
[14:47..14:48): x <- local7
[14:50..14:53): Int -> scala/Int#
[14:56..14:59): Int -> scala/Int#
[14:62..14:65): ??? -> scala/Predef.`???`().
[15:6..15:8): s4 <- advanced/Structural#s4().
[15:9..15:10): a <- advanced/Structural#s4().(a)
[15:12..15:15): Int -> scala/Int#
[15:24..15:25): x <- local11
[15:27..15:30): Int -> scala/Int#
[15:35..15:38): ??? -> scala/Predef.`???`().
[16:8..16:9): T <- advanced/Structural#T#
[16:9..16:9): <- advanced/Structural#T#`<init>`().
[16:10..16:11): A <- advanced/Structural#T#[A]
[16:19..16:22): foo <- advanced/Structural#T#foo.
[16:31..16:32): B <- local12
[16:35..16:36): A -> advanced/Structural#T#[A]
[16:41..16:44): ??? -> scala/Predef.`???`().
[16:50..16:53): bar <- advanced/Structural#T#bar().
[16:54..16:55): b <- advanced/Structural#T#bar().(b)
[16:57..16:60): foo -> advanced/Structural#T#foo.
[16:61..16:62): B -> local12
[19:6..19:15): Wildcards <- advanced/Wildcards#
[20:2..20:2): <- advanced/Wildcards#`<init>`().
[20:6..20:8): e1 <- advanced/Wildcards#e1().
[20:10..20:14): List -> scala/package.List#
[20:20..20:23): ??? -> scala/Predef.`???`().
[21:6..21:8): e2 <- advanced/Wildcards#e2().
[21:10..21:14): List -> scala/package.List#
[21:20..21:23): Int -> scala/Int#
[21:27..21:30): ??? -> scala/Predef.`???`().
[24:7..24:11): Test <- advanced/Test.
[25:6..25:7): s <- advanced/Test.s.
[25:14..25:24): Structural -> advanced/Structural#
[26:6..26:8): s1 <- advanced/Test.s1.
[26:11..26:12): s -> advanced/Test.s.
[26:13..26:15): s1 -> advanced/Structural#s1().
[27:6..27:9): s1x <- advanced/Test.s1x.
[27:12..27:13): s -> advanced/Test.s.
[27:14..27:16): s1 -> advanced/Structural#s1().
[27:16..27:18): .x -> scala/reflect/Selectable#selectDynamic().
[28:6..28:8): s2 <- advanced/Test.s2.
[28:11..28:12): s -> advanced/Test.s.
[28:13..28:15): s2 -> advanced/Structural#s2().
[29:6..29:9): s2x <- advanced/Test.s2x.
[29:12..29:13): s -> advanced/Test.s.
[29:14..29:16): s2 -> advanced/Structural#s2().
[29:16..29:18): .x -> scala/reflect/Selectable#selectDynamic().
[30:6..30:8): s3 <- advanced/Test.s3.
[30:11..30:12): s -> advanced/Test.s.
[30:13..30:15): s3 -> advanced/Structural#s3().
[31:6..31:9): s3x <- advanced/Test.s3x.
[31:12..31:13): s -> advanced/Test.s.
[31:14..31:16): s3 -> advanced/Structural#s3().
[31:16..31:18): .m -> scala/reflect/Selectable#applyDynamic().
[31:19..31:22): ??? -> scala/Predef.`???`().
[33:6..33:7): e <- advanced/Test.e.
[33:14..33:23): Wildcards -> advanced/Wildcards#
[34:6..34:8): e1 <- advanced/Test.e1.
[34:11..34:12): e -> advanced/Test.e.
[34:13..34:15): e1 -> advanced/Wildcards#e1().
[35:6..35:9): e1x <- advanced/Test.e1x.
[35:12..35:13): e -> advanced/Test.e.
[35:14..35:16): e1 -> advanced/Wildcards#e1().
[35:17..35:21): head -> scala/collection/IterableOps#head().
[38:5..38:8): ??? -> scala/Predef.`???`().
[38:11..38:14): Any -> scala/Any#
[39:11..39:13): e3 <- local13
[39:15..39:19): List -> scala/package.List#
[40:12..40:15): e3x <- local15
[40:18..40:20): e3 -> local13
[40:21..40:25): head -> scala/collection/IterableOps#head().
[46:11..46:14): foo <- advanced/Test.foo.
[46:17..46:24): reflect -> scala/reflect/
[46:25..46:35): Selectable -> scala/reflect/Selectable#
[46:43..46:44): A <- local16
[46:47..46:50): Int -> scala/Int#
[46:54..46:55): & -> scala/`&`#
[46:57..46:64): reflect -> scala/reflect/
[46:65..46:75): Selectable -> scala/reflect/Selectable#
[46:83..46:84): A <- local17
[46:87..46:90): Int -> scala/Int#
[46:96..46:97): a <- local18
[46:99..46:100): A -> local17
[46:106..46:109): ??? -> scala/Predef.`???`().
[47:6..47:9): bar <- advanced/Test.bar().
[47:11..47:14): foo -> advanced/Test.foo.
[47:15..47:16): A -> local17
[47:19..47:22): foo -> advanced/Test.foo.
[47:22..47:24): .a -> scala/reflect/Selectable#selectDynamic().
[52:6..52:13): HKClass <- advanced/HKClass#
[52:13..52:13): <- advanced/HKClass#`<init>`().
[52:14..52:15): F <- advanced/HKClass#[F]
[52:20..52:21): T <- advanced/HKClass#`<init>`().[F][T]
[52:28..52:29): U <- advanced/HKClass#`<init>`().[F][U]
[52:36..52:37): U -> advanced/HKClass#`<init>`().[F][U]
[52:39..52:40): T -> advanced/HKClass#`<init>`().[F][T]
[53:6..53:9): foo <- advanced/HKClass#foo().
[53:10..53:11): T <- advanced/HKClass#foo().[T]
[53:12..53:13): U <- advanced/HKClass#foo().[U]
[53:15..53:16): x <- advanced/HKClass#foo().(x)
[53:18..53:19): F -> advanced/HKClass#[F]
[53:20..53:21): T -> advanced/HKClass#foo().[T]
[53:23..53:24): U -> advanced/HKClass#foo().[U]
[53:28..53:34): String -> scala/Predef.String#
[53:37..53:38): x -> advanced/HKClass#foo().(x)
[53:39..53:47): toString -> scala/Tuple2#toString().

Synthetics:
[27:12..27:16):s.s1 => reflectiveSelectable(*)
[29:12..29:16):s.s2 => reflectiveSelectable(*)
[31:12..31:16):s.s3 => reflectiveSelectable(*)

expect/Annotations.scala
------------------------

Summary:
Schema => SemanticDB v4
Uri => Annotations.scala
Text => empty
Language => Scala
Symbols => 23 entries
Occurrences => 55 entries

Symbols:
annot/Alias. => final object Alias extends Object { self: Alias.type => +2 decls }
annot/Alias.A# => type A  = ClassAnnotation @param
annot/Annotations# => @ClassAnnotation class Annotations [@TypeParameterAnnotation typeparam T ] extends Object { self: AnyRef & Annotations[T] => +6 decls }
annot/Annotations#S# => @TypeAnnotation type S 
annot/Annotations#[T] => @TypeParameterAnnotation typeparam T 
annot/Annotations#`<init>`(). => primary ctor <init> [@TypeParameterAnnotation typeparam T ](@ParameterAnnotation param x: T): Annotations[T]
annot/Annotations#`<init>`().(x) => @ParameterAnnotation param x: T
annot/Annotations#field. => @FieldAnnotation val method field Int
annot/Annotations#method(). => @MethodAnnotation method method => Int
annot/Annotations#x. => @ParameterAnnotation private[this] val method x T
annot/B# => class B extends Object { self: B => +4 decls }
annot/B#`<init>`(). => @ConstructorAnnotation primary ctor <init> (param x: Int): B
annot/B#`<init>`().(x) => param x: Int
annot/B#`<init>`(+1). => @ConstructorAnnotation ctor <init> (): B
annot/B#throwing(). => @throws[Exception] method throwing => Nothing
annot/B#x. => private[this] val method x Int
annot/M. => @ObjectAnnotation final object M extends Object { self: M.type => +1 decls }
annot/M.m(). => @MacroAnnotation macro m [typeparam TT ]: Int
annot/M.m().[TT] => typeparam TT 
annot/T# => @TraitAnnotation trait T extends Object { self: T => +1 decls }
annot/T#`<init>`(). => primary ctor <init> (): T
local0 => selfparam self: AnyRef
local1 => @LocalAnnotation val local local: Int

Occurrences:
[0:8..0:13): annot <- annot/
[2:7..2:10): com -> com/
[2:11..2:17): javacp -> com/javacp/
[2:18..2:23): annot -> com/javacp/annot/
[3:7..3:12): scala -> scala/
[3:13..3:23): annotation -> scala/annotation/
[3:24..3:28): meta -> scala/annotation/meta/
[4:7..4:12): scala -> scala/
[4:13..4:21): language -> scala/language.
[4:22..4:34): experimental -> scala/language.experimental.
[4:35..4:41): macros -> scala/language.experimental.macros.
[6:1..6:16): ClassAnnotation -> com/javacp/annot/ClassAnnotation#
[7:6..7:17): Annotations <- annot/Annotations#
[7:17..7:17): <- annot/Annotations#`<init>`().
[7:19..7:42): TypeParameterAnnotation -> com/javacp/annot/TypeParameterAnnotation#
[7:43..7:44): T <- annot/Annotations#[T]
[7:47..7:66): ParameterAnnotation -> com/javacp/annot/ParameterAnnotation#
[7:67..7:68): x <- annot/Annotations#x.
[7:70..7:71): T -> annot/Annotations#[T]
[7:75..7:79): self <- local0
[7:81..7:87): AnyRef -> scala/AnyRef#
[8:3..8:18): FieldAnnotation -> com/javacp/annot/FieldAnnotation#
[9:6..9:11): field <- annot/Annotations#field.
[11:3..11:19): MethodAnnotation -> com/javacp/annot/MethodAnnotation#
[12:6..12:12): method <- annot/Annotations#method().
[13:5..13:20): LocalAnnotation -> com/javacp/annot/LocalAnnotation#
[14:8..14:13): local <- local1
[15:4..15:9): local -> local1
[17:3..17:17): TypeAnnotation -> com/javacp/annot/TypeAnnotation#
[18:7..18:8): S <- annot/Annotations#S#
[21:6..21:7): B <- annot/B#
[21:7..21:7): <- annot/B#`<init>`().
[21:9..21:30): ConstructorAnnotation -> com/javacp/annot/ConstructorAnnotation#
[21:33..21:34): x <- annot/B#x.
[21:36..21:39): Int -> scala/Int#
[22:3..22:24): ConstructorAnnotation -> com/javacp/annot/ConstructorAnnotation#
[23:6..23:10): <- annot/B#`<init>`(+1).
[25:3..25:9): throws -> scala/throws#
[25:10..25:19): Exception -> scala/package.Exception#
[26:6..26:14): throwing <- annot/B#throwing().
[26:27..26:36): Exception -> scala/package.Exception#
[29:1..29:17): ObjectAnnotation -> com/javacp/annot/ObjectAnnotation#
[30:7..30:8): M <- annot/M.
[31:3..31:18): MacroAnnotation -> com/javacp/annot/MacroAnnotation#
[32:6..32:7): m <- annot/M.m().
[32:8..32:10): TT <- annot/M.m().[TT]
[32:13..32:16): Int -> scala/Int#
[32:25..32:28): ??? -> scala/Predef.`???`().
[35:0..35:0): <- annot/T#`<init>`().
[35:1..35:16): TraitAnnotation -> com/javacp/annot/TraitAnnotation#
[36:6..36:7): T <- annot/T#
[38:7..38:12): Alias <- annot/Alias.
[39:7..39:8): A <- annot/Alias.A#
[39:11..39:26): ClassAnnotation -> com/javacp/annot/ClassAnnotation#
[39:28..39:33): param -> scala/annotation/meta/param#

expect/Anonymous.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => Anonymous.scala
Text => empty
Language => Scala
Symbols => 23 entries
Occurrences => 50 entries
Synthetics => 2 entries

Symbols:
example/Anonymous# => class Anonymous extends Object { self: Anonymous & Anonymous => +9 decls }
example/Anonymous#Bar# => trait Bar extends Object { self: Bar => +2 decls }
example/Anonymous#Bar#`<init>`(). => primary ctor <init> (): Bar
example/Anonymous#Bar#bar(). => abstract method bar => String
example/Anonymous#Foo# => trait Foo extends Object { self: Foo => +1 decls }
example/Anonymous#Foo#`<init>`(). => primary ctor <init> (): Foo
example/Anonymous#`<init>`(). => primary ctor <init> (): Anonymous
example/Anonymous#bar1. => val method bar1 Bar
example/Anonymous#bar2. => val method bar2 Bar
example/Anonymous#foo. => val method foo Foo
example/Anonymous#locally(). => method locally [typeparam A ](param x: A): A
example/Anonymous#locally().(x) => param x: A
example/Anonymous#locally().[A] => typeparam A 
example/Anonymous#m1(). => method m1 [typeparam T [type _ ]]: Nothing
example/Anonymous#m1().[T] => typeparam T [type _ ]
example/Anonymous#m1().[T][_] => type _ 
example/Anonymous#m2(). => method m2 => Map[_, List[_] forSome { type _  }] forSome { type _  }
local0 => val local x: Function1[Int, Int]
local1 => final class $anon extends Object with Foo { self: $anon => +1 decls }
local3 => method bar => String <: example/Anonymous#Bar#bar().
local4 => final class $anon extends Object with Bar { self: $anon => +2 decls }
local6 => method bar => String <: example/Anonymous#Bar#bar().
local7 => final class $anon extends Object with Bar { self: $anon => +2 decls }

Occurrences:
[0:8..0:15): example <- example/
[1:7..1:12): scala -> scala/
[1:13..1:21): language -> scala/language.
[1:22..1:33): higherKinds -> scala/language.higherKinds.
[3:6..3:15): Anonymous <- example/Anonymous#
[4:2..4:2): <- example/Anonymous#`<init>`().
[4:8..4:17): Anonymous -> example/Anonymous#
[6:6..6:13): locally <- example/Anonymous#locally().
[6:14..6:15): A <- example/Anonymous#locally().[A]
[6:17..6:18): x <- example/Anonymous#locally().(x)
[6:20..6:21): A -> example/Anonymous#locally().[A]
[6:24..6:25): A -> example/Anonymous#locally().[A]
[6:28..6:29): x -> example/Anonymous#locally().(x)
[8:6..8:8): m1 <- example/Anonymous#m1().
[8:9..8:10): T <- example/Anonymous#m1().[T]
[8:17..8:20): ??? -> scala/Predef.`???`().
[9:6..9:8): m2 <- example/Anonymous#m2().
[9:10..9:13): Map -> scala/Predef.Map#
[9:17..9:21): List -> scala/package.List#
[9:28..9:31): ??? -> scala/Predef.`???`().
[10:2..10:9): locally -> example/Anonymous#locally().
[11:4..11:7): ??? -> scala/Predef.`???`().
[11:24..11:28): List -> scala/package.List#
[13:2..13:9): locally -> example/Anonymous#locally().
[14:8..14:9): x <- local0
[14:11..14:14): Int -> scala/Int#
[14:18..14:21): Int -> scala/Int#
[14:29..14:32): ??? -> scala/Predef.`???`().
[17:2..17:2): <- example/Anonymous#Foo#`<init>`().
[17:8..17:11): Foo <- example/Anonymous#Foo#
[18:6..18:9): foo <- example/Anonymous#foo.
[18:12..18:12): <- local1
[18:16..18:19): Foo -> example/Anonymous#Foo#
[20:8..20:11): Bar <- example/Anonymous#Bar#
[21:4..21:4): <- example/Anonymous#Bar#`<init>`().
[21:8..21:11): bar <- example/Anonymous#Bar#bar().
[21:13..21:19): String -> scala/Predef.String#
[22:6..22:10): bar1 <- example/Anonymous#bar1.
[22:12..22:15): Bar -> example/Anonymous#Bar#
[22:18..22:18): <- local4
[22:22..22:25): Bar -> example/Anonymous#Bar#
[22:32..22:35): bar <- local3
[22:37..22:43): String -> scala/Predef.String#
[22:46..22:49): ??? -> scala/Predef.`???`().
[23:6..23:10): bar2 <- example/Anonymous#bar2.
[23:12..23:15): Bar -> example/Anonymous#Bar#
[23:18..23:18): <- local7
[23:28..23:31): bar <- local6
[23:33..23:39): String -> scala/Predef.String#
[23:42..23:45): ??? -> scala/Predef.`???`().

Synthetics:
[10:2..10:9):locally => *[Unit]
[13:2..13:9):locally => *[Unit]

expect/AnonymousGiven.scala
---------------------------

Summary:
Schema => SemanticDB v4
Uri => AnonymousGiven.scala
Text => empty
Language => Scala
Symbols => 5 entries
Occurrences => 5 entries

Symbols:
angiven/AnonymousGiven$package. => final package object angiven extends Object { self: angiven.type => +2 decls }
angiven/AnonymousGiven$package.bar(). => method bar (implicit given param x$1: Foo): Int
angiven/AnonymousGiven$package.bar().(x$1) => implicit given param x$1: Foo
angiven/Foo# => trait Foo extends Object { self: Foo => +1 decls }
angiven/Foo#`<init>`(). => primary ctor <init> (): Foo

Occurrences:
[0:8..0:15): angiven <- angiven/
[2:0..2:0): <- angiven/Foo#`<init>`().
[2:6..2:9): Foo <- angiven/Foo#
[4:4..4:7): bar <- angiven/AnonymousGiven$package.bar().
[4:14..4:17): Foo -> angiven/Foo#

expect/CaseClass.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => CaseClass.scala
Text => empty
Language => Scala
Symbols => 22 entries
Occurrences => 17 entries

Symbols:
caseclass/CaseClass# => case class CaseClass extends Object with Product with Serializable { self: CaseClass => +8 decls }
caseclass/CaseClass#_1(). => method _1 => Int
caseclass/CaseClass#_2(). => method _2 => Int
caseclass/CaseClass#`<init>`(). => primary ctor <init> (val param int1: Int, val param int2: Int): CaseClass
caseclass/CaseClass#`<init>`().(int1) => val param int1: Int
caseclass/CaseClass#`<init>`().(int2) => val param int2: Int
caseclass/CaseClass#copy$default$1(). => method copy$default$1 => Int @uncheckedVariance
caseclass/CaseClass#copy$default$2(). => method copy$default$2 => Int @uncheckedVariance
caseclass/CaseClass#copy(). => method copy (param int1: Int, param int2: Int): CaseClass
caseclass/CaseClass#copy().(int1) => param int1: Int
caseclass/CaseClass#copy().(int2) => param int2: Int
caseclass/CaseClass#int1. => val method int1 Int
caseclass/CaseClass#int2. => val method int2 Int
caseclass/CaseClass. => final object CaseClass extends Object { self: CaseClass.type => +5 decls }
caseclass/CaseClass.apply(). => method apply (param int: Int): CaseClass
caseclass/CaseClass.apply().(int) => param int: Int
caseclass/CaseClass.apply(+1). => method apply (): CaseClass
caseclass/CaseClass.apply(+2). => method apply (param int1: Int, param int2: Int): CaseClass
caseclass/CaseClass.apply(+2).(int1) => param int1: Int
caseclass/CaseClass.apply(+2).(int2) => param int2: Int
caseclass/CaseClass.unapply(). => method unapply (param x$1: CaseClass): CaseClass
caseclass/CaseClass.unapply().(x$1) => param x$1: CaseClass

Occurrences:
[0:8..0:17): caseclass <- caseclass/
[2:11..2:20): CaseClass <- caseclass/CaseClass#
[2:20..2:20): <- caseclass/CaseClass#`<init>`().
[2:21..2:25): int1 <- caseclass/CaseClass#int1.
[2:27..2:30): Int -> scala/Int#
[2:32..2:36): int2 <- caseclass/CaseClass#int2.
[2:38..2:41): Int -> scala/Int#
[4:7..4:16): CaseClass <- caseclass/CaseClass.
[5:6..5:11): apply <- caseclass/CaseClass.apply().
[5:12..5:15): int <- caseclass/CaseClass.apply().(int)
[5:17..5:20): Int -> scala/Int#
[5:23..5:32): CaseClass -> caseclass/CaseClass#
[5:35..5:44): CaseClass -> caseclass/CaseClass.
[5:45..5:48): int -> caseclass/CaseClass.apply().(int)
[6:6..6:11): apply <- caseclass/CaseClass.apply(+1).
[6:15..6:24): CaseClass -> caseclass/CaseClass#
[6:27..6:36): CaseClass -> caseclass/CaseClass.

expect/Classes.scala
--------------------

Summary:
Schema => SemanticDB v4
Uri => Classes.scala
Text => empty
Language => Scala
Symbols => 108 entries
Occurrences => 127 entries
Synthetics => 2 entries

Symbols:
classes/C1# => final class C1 extends AnyVal { self: C1 => +2 decls }
classes/C1#`<init>`(). => primary ctor <init> (val param x1: Int): C1
classes/C1#`<init>`().(x1) => val param x1: Int
classes/C1#x1. => val method x1 Int
classes/C1. => final object C1 extends Object { self: C1.type => +2 decls }
classes/C2# => final class C2 extends AnyVal { self: C2 => +2 decls }
classes/C2#`<init>`(). => primary ctor <init> (val param x2: Int): C2
classes/C2#`<init>`().(x2) => val param x2: Int
classes/C2#x2. => val method x2 Int
classes/C2. => final object C2 extends Object { self: C2.type => +2 decls }
classes/C3# => case class C3 extends Object with Product with Serializable { self: C3 => +5 decls }
classes/C3#_1(). => method _1 => Int
classes/C3#`<init>`(). => primary ctor <init> (val param x: Int): C3
classes/C3#`<init>`().(x) => val param x: Int
classes/C3#copy$default$1(). => method copy$default$1 => Int @uncheckedVariance
classes/C3#copy(). => method copy (param x: Int): C3
classes/C3#copy().(x) => param x: Int
classes/C3#x. => val method x Int
classes/C3. => final object C3 extends Object { self: C3.type => +4 decls }
classes/C3.apply(). => method apply (param x: Int): C3
classes/C3.apply().(x) => param x: Int
classes/C3.toString(). => method toString => String <: scala/Any#toString().
classes/C3.unapply(). => method unapply (param x$1: C3): C3
classes/C3.unapply().(x$1) => param x$1: C3
classes/C4# => case class C4 extends Object with Product with Serializable { self: C4 => +5 decls }
classes/C4#_1(). => method _1 => Int
classes/C4#`<init>`(). => primary ctor <init> (val param x: Int): C4
classes/C4#`<init>`().(x) => val param x: Int
classes/C4#copy$default$1(). => method copy$default$1 => Int @uncheckedVariance
classes/C4#copy(). => method copy (param x: Int): C4
classes/C4#copy().(x) => param x: Int
classes/C4#x. => val method x Int
classes/C4. => final object C4 extends Object { self: C4.type => +3 decls }
classes/C4.apply(). => method apply (param x: Int): C4
classes/C4.apply().(x) => param x: Int
classes/C4.unapply(). => method unapply (param x$1: C4): C4
classes/C4.unapply().(x$1) => param x$1: C4
classes/C6# => case class C6 extends Object with Product with Serializable { self: C6 => +5 decls }
classes/C6#_1(). => method _1 => Int
classes/C6#`<init>`(). => primary ctor <init> (param x: Int): C6
classes/C6#`<init>`().(x) => param x: Int
classes/C6#copy$default$1(). => method copy$default$1 => Int @uncheckedVariance
classes/C6#copy(). => method copy (param x: Int): C6
classes/C6#copy().(x) => param x: Int
classes/C6#x. => private val method x Int
classes/C6. => final object C6 extends Object { self: C6.type => +4 decls }
classes/C6.apply(). => method apply (param x: Int): C6
classes/C6.apply().(x) => param x: Int
classes/C6.toString(). => method toString => String <: scala/Any#toString().
classes/C6.unapply(). => method unapply (param x$1: C6): C6
classes/C6.unapply().(x$1) => param x$1: C6
classes/C7# => class C7 extends Object { self: C7 => +2 decls }
classes/C7#`<init>`(). => primary ctor <init> (param x: Int): C7
classes/C7#`<init>`().(x) => param x: Int
classes/C7#x. => private[this] val method x Int
classes/C8# => class C8 extends Object { self: C8 => +2 decls }
classes/C8#`<init>`(). => primary ctor <init> (param x: Int): C8
classes/C8#`<init>`().(x) => param x: Int
classes/C8#x. => private[this] val method x Int
classes/C9# => class C9 extends Object { self: C9 => +2 decls }
classes/C9#`<init>`(). => primary ctor <init> (param x: Int): C9
classes/C9#`<init>`().(x) => param x: Int
classes/C9#x(). => private[this] var method x Int
classes/C10# => class C10 extends Object { self: C10 => +2 decls }
classes/C10#`<init>`(). => primary ctor <init> (param s: => String): C10
classes/C10#`<init>`().(s) => param s: => String
classes/C10#s. => private[this] val method s => String
classes/C11# => class C11 extends Object { self: C11 => +2 decls }
classes/C11#`<init>`(). => primary ctor <init> (): C11
classes/C11#foo(). => macro foo => Int
classes/C11#foo(). => inline macro foo => Int
classes/C12# => class C12 extends Object { self: C12 => +8 decls }
classes/C12#Context# => class Context extends Object { self: Context => +2 decls }
classes/C12#Context#Expr# => type Expr [typeparam T ]
classes/C12#Context#Expr#[T] => typeparam T 
classes/C12#Context#`<init>`(). => primary ctor <init> (): Context
classes/C12#`<init>`(). => primary ctor <init> (): C12
classes/C12#foo1(). => macro foo1 (param x: Int): Int
classes/C12#foo1(). => method foo1 (param x: Int): Int
classes/C12#foo1().(x) => param x: Int
classes/C12#foo1().(x) => param x: Int
classes/C12#foo1Impl(). => method foo1Impl (param context: Context)(param x: context.Expr[Int]): context.Expr[Int]
classes/C12#foo1Impl().(context) => param context: Context
classes/C12#foo1Impl().(x) => param x: context.Expr[Int]
classes/C12#foo2(). => macro foo2 (param x: Int, param y: String): Int
classes/C12#foo2(). => method foo2 (param x: Int, param y: String): Int
classes/C12#foo2().(x) => param x: Int
classes/C12#foo2().(x) => param x: Int
classes/C12#foo2().(y) => param y: String
classes/C12#foo2().(y) => param y: String
classes/C12#foo2Impl(). => method foo2Impl (param context: Context)(param x: context.Expr[Int], param y: context.Expr[String]): context.Expr[Int]
classes/C12#foo2Impl().(context) => param context: Context
classes/C12#foo2Impl().(x) => param x: context.Expr[Int]
classes/C12#foo2Impl().(y) => param y: context.Expr[String]
classes/M. => final object M extends Object { self: M.type => +3 decls }
classes/M.C5# => implicit class C5 extends Object { self: C5 => +2 decls }
classes/M.C5#`<init>`(). => primary ctor <init> (param x: Int): C5
classes/M.C5#`<init>`().(x) => param x: Int
classes/M.C5#x. => private[this] val method x Int
classes/M.C5(). => final implicit method C5 (param x: Int): C5
classes/M.C5().(x) => param x: Int
classes/N. => final object N extends Object { self: N.type => +3 decls }
classes/N.anonClass. => val method anonClass C7
classes/N.anonFun. => val method anonFun List[Int]
local0 => val method local Nothing
local1 => final class $anon extends C7 { self: $anon => +2 decls }
local3 => param i: Int
local4 => val local local: Int

Occurrences:
[0:8..0:15): classes <- classes/
[1:7..1:12): scala -> scala/
[1:13..1:21): language -> scala/language.
[1:22..1:34): experimental -> scala/language.experimental.
[1:35..1:41): macros -> scala/language.experimental.macros.
[2:6..2:8): C1 <- classes/C1#
[2:8..2:8): <- classes/C1#`<init>`().
[2:13..2:15): x1 <- classes/C1#x1.
[2:17..2:20): Int -> scala/Int#
[2:30..2:36): AnyVal -> scala/AnyVal#
[4:6..4:8): C2 <- classes/C2#
[4:8..4:8): <- classes/C2#`<init>`().
[4:13..4:15): x2 <- classes/C2#x2.
[4:17..4:20): Int -> scala/Int#
[4:30..4:36): AnyVal -> scala/AnyVal#
[5:7..5:9): C2 <- classes/C2.
[7:11..7:13): C3 <- classes/C3#
[7:13..7:13): <- classes/C3#`<init>`().
[7:14..7:15): x <- classes/C3#x.
[7:17..7:20): Int -> scala/Int#
[9:11..9:13): C4 <- classes/C4#
[9:13..9:13): <- classes/C4#`<init>`().
[9:14..9:15): x <- classes/C4#x.
[9:17..9:20): Int -> scala/Int#
[10:7..10:9): C4 <- classes/C4.
[12:7..12:8): M <- classes/M.
[13:17..13:19): C5 <- classes/M.C5#
[13:19..13:19): <- classes/M.C5#`<init>`().
[13:20..13:21): x <- classes/M.C5#x.
[13:23..13:26): Int -> scala/Int#
[16:11..16:13): C6 <- classes/C6#
[16:13..16:13): <- classes/C6#`<init>`().
[16:26..16:27): x <- classes/C6#x.
[16:29..16:32): Int -> scala/Int#
[18:6..18:8): C7 <- classes/C7#
[18:8..18:8): <- classes/C7#`<init>`().
[18:9..18:10): x <- classes/C7#x.
[18:12..18:15): Int -> scala/Int#
[20:6..20:8): C8 <- classes/C8#
[20:8..20:8): <- classes/C8#`<init>`().
[20:27..20:28): x <- classes/C8#x.
[20:30..20:33): Int -> scala/Int#
[22:6..22:8): C9 <- classes/C9#
[22:8..22:8): <- classes/C9#`<init>`().
[22:27..22:28): x <- classes/C9#x().
[22:30..22:33): Int -> scala/Int#
[24:6..24:9): C10 <- classes/C10#
[24:9..24:9): <- classes/C10#`<init>`().
[24:10..24:11): s <- classes/C10#s.
[24:16..24:22): String -> scala/Predef.String#
[26:6..26:9): C11 <- classes/C11#
[27:2..27:2): <- classes/C11#`<init>`().
[27:6..27:9): foo <- classes/C11#foo().
[27:11..27:14): Int -> scala/Int#
[27:23..27:26): ??? -> scala/Predef.`???`().
[28:13..28:16): foo <- classes/C11#foo().
[28:18..28:21): Int -> scala/Int#
[28:24..28:27): ??? -> scala/Predef.`???`().
[31:6..31:9): C12 <- classes/C12#
[33:2..33:2): <- classes/C12#`<init>`().
[33:8..33:15): Context <- classes/C12#Context#
[34:4..34:4): <- classes/C12#Context#`<init>`().
[34:9..34:13): Expr <- classes/C12#Context#Expr#
[34:14..34:15): T <- classes/C12#Context#Expr#[T]
[36:6..36:10): foo1 <- classes/C12#foo1().
[36:11..36:12): x <- classes/C12#foo1().(x)
[36:14..36:17): Int -> scala/Int#
[36:20..36:23): Int -> scala/Int#
[36:32..36:40): foo1Impl -> classes/C12#foo1Impl().
[37:6..37:10): foo1 <- classes/C12#foo1().
[37:11..37:12): x <- classes/C12#foo1().(x)
[37:14..37:17): Int -> scala/Int#
[37:20..37:23): Int -> scala/Int#
[37:26..37:29): ??? -> scala/Predef.`???`().
[39:6..39:10): foo2 <- classes/C12#foo2().
[39:11..39:12): x <- classes/C12#foo2().(x)
[39:14..39:17): Int -> scala/Int#
[39:19..39:20): y <- classes/C12#foo2().(y)
[39:22..39:28): String -> scala/Predef.String#
[39:31..39:34): Int -> scala/Int#
[39:43..39:51): foo2Impl -> classes/C12#foo2Impl().
[40:6..40:10): foo2 <- classes/C12#foo2().
[40:11..40:12): x <- classes/C12#foo2().(x)
[40:14..40:17): Int -> scala/Int#
[40:19..40:20): y <- classes/C12#foo2().(y)
[40:22..40:28): String -> scala/Predef.String#
[40:31..40:34): Int -> scala/Int#
[40:37..40:40): ??? -> scala/Predef.`???`().
[42:6..42:14): foo1Impl <- classes/C12#foo1Impl().
[42:15..42:22): context <- classes/C12#foo1Impl().(context)
[42:24..42:31): Context -> classes/C12#Context#
[42:33..42:34): x <- classes/C12#foo1Impl().(x)
[42:36..42:43): context -> classes/C12#foo1Impl().(context)
[42:44..42:48): Expr -> classes/C12#Context#Expr#
[42:49..42:52): Int -> scala/Int#
[42:56..42:63): context -> classes/C12#foo1Impl().(context)
[42:64..42:68): Expr -> classes/C12#Context#Expr#
[42:69..42:72): Int -> scala/Int#
[42:76..42:79): ??? -> scala/Predef.`???`().
[43:6..43:14): foo2Impl <- classes/C12#foo2Impl().
[43:15..43:22): context <- classes/C12#foo2Impl().(context)
[43:24..43:31): Context -> classes/C12#Context#
[43:33..43:34): x <- classes/C12#foo2Impl().(x)
[43:36..43:43): context -> classes/C12#foo2Impl().(context)
[43:44..43:48): Expr -> classes/C12#Context#Expr#
[43:49..43:52): Int -> scala/Int#
[43:55..43:56): y <- classes/C12#foo2Impl().(y)
[43:58..43:65): context -> classes/C12#foo2Impl().(context)
[43:66..43:70): Expr -> classes/C12#Context#Expr#
[43:71..43:77): String -> scala/Predef.String#
[43:81..43:88): context -> classes/C12#foo2Impl().(context)
[43:89..43:93): Expr -> classes/C12#Context#Expr#
[43:94..43:97): Int -> scala/Int#
[43:101..43:104): ??? -> scala/Predef.`???`().
[47:7..47:8): N <- classes/N.
[48:6..48:15): anonClass <- classes/N.anonClass.
[48:18..48:18): <- local1
[48:22..48:24): C7 -> classes/C7#
[49:8..49:13): local <- local0
[49:16..49:19): ??? -> scala/Predef.`???`().
[51:6..51:13): anonFun <- classes/N.anonFun.
[51:16..51:20): List -> scala/package.List.
[51:24..51:27): map -> scala/collection/immutable/List#map().
[51:30..51:31): i <- local3
[52:8..52:13): local <- local4
[53:4..53:9): local -> local4
[53:10..53:11): + -> scala/Int#`+`(+4).

Synthetics:
[51:16..51:27):List(1).map => *[Int]
[51:16..51:20):List => *.apply[Int]

expect/Empty.scala
------------------

Summary:
Schema => SemanticDB v4
Uri => Empty.scala
Text => empty
Language => Scala
Symbols => 6 entries
Occurrences => 10 entries

Symbols:
_empty_/A# => class A extends Object { self: A => +2 decls }
_empty_/A#`<init>`(). => primary ctor <init> (): A
_empty_/A#b(). => method b => B
_empty_/B# => class B extends Object { self: B => +2 decls }
_empty_/B#`<init>`(). => primary ctor <init> (): B
_empty_/B#a(). => method a => A

Occurrences:
[0:6..0:7): A <- _empty_/A#
[1:2..1:2): <- _empty_/A#`<init>`().
[1:6..1:7): b <- _empty_/A#b().
[1:9..1:10): B -> _empty_/B#
[1:13..1:16): ??? -> scala/Predef.`???`().
[4:6..4:7): B <- _empty_/B#
[5:2..5:2): <- _empty_/B#`<init>`().
[5:6..5:7): a <- _empty_/B#a().
[5:9..5:10): A -> _empty_/A#
[5:13..5:16): ??? -> scala/Predef.`???`().

expect/EmptyObject.scala
------------------------

Summary:
Schema => SemanticDB v4
Uri => EmptyObject.scala
Text => empty
Language => Scala
Symbols => 1 entries
Occurrences => 2 entries

Symbols:
example/EmptyObject. => final object EmptyObject extends Object { self: EmptyObject.type => +1 decls }

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:18): EmptyObject <- example/EmptyObject.

expect/EndMarkers.scala
-----------------------

Summary:
Schema => SemanticDB v4
Uri => EndMarkers.scala
Text => empty
Language => Scala
Symbols => 30 entries
Occurrences => 49 entries

Symbols:
endmarkers/Container# => class Container extends Object { self: Container => +5 decls }
endmarkers/Container#`<init>`(). => primary ctor <init> (): Container
endmarkers/Container#`baz_=`(). => var method baz_= (param x$1: Int): Unit
endmarkers/Container#`baz_=`().(x$1) => param x$1: Int
endmarkers/Container#bar. => val method bar Tuple3[Int, Int, Int]
endmarkers/Container#baz(). => var method baz Int
endmarkers/Container#foo(). => method foo => Tuple3[Int, Int, Int]
endmarkers/EndMarkers$package. => final package object endmarkers extends Object { self: endmarkers.type => +8 decls }
endmarkers/EndMarkers$package.`topLevelVar_=`(). => var method topLevelVar_= (param x$1: String): Unit
endmarkers/EndMarkers$package.`topLevelVar_=`().(x$1) => param x$1: String
endmarkers/EndMarkers$package.given_Stuff_String. => final implicit given object given_Stuff_String extends Object with Stuff[String] { self: given_Stuff_String.type => +2 decls }
endmarkers/EndMarkers$package.given_Stuff_String.do(). => method do => String <: endmarkers/Stuff#do().
endmarkers/EndMarkers$package.topLevelMethod(). => method topLevelMethod => String
endmarkers/EndMarkers$package.topLevelVal. => val method topLevelVal Int
endmarkers/EndMarkers$package.topLevelVar(). => var method topLevelVar String
endmarkers/EndMarkers$package.topLevelWithLocals(). => method topLevelWithLocals => Unit
endmarkers/MultiCtor# => class MultiCtor extends Object { self: MultiCtor => +3 decls }
endmarkers/MultiCtor#`<init>`(). => primary ctor <init> (val param i: Int): MultiCtor
endmarkers/MultiCtor#`<init>`().(i) => val param i: Int
endmarkers/MultiCtor#`<init>`(+1). => ctor <init> (): MultiCtor
endmarkers/MultiCtor#i. => val method i Int
endmarkers/Stuff# => trait Stuff [typeparam A ] extends Object { self: Stuff[A] => +3 decls }
endmarkers/Stuff#[A] => typeparam A 
endmarkers/Stuff#`<init>`(). => primary ctor <init> [typeparam A ](): Stuff[A]
endmarkers/Stuff#do(). => abstract method do => A
endmarkers/TestObj. => final object TestObj extends Object { self: TestObj.type => +2 decls }
endmarkers/TestObj.foo(). => method foo => Int
local0 => val local localVal: Int
local1 => var local localVar: Int
local2 => local localDef: => Int

Occurrences:
[0:8..0:18): endmarkers <- endmarkers/
[2:8..2:17): MultiCtor <- endmarkers/MultiCtor#
[2:17..2:17): <- endmarkers/MultiCtor#`<init>`().
[2:22..2:23): i <- endmarkers/MultiCtor#i.
[2:25..2:28): Int -> scala/Int#
[3:8..3:12): <- endmarkers/MultiCtor#`<init>`(+1).
[5:8..5:12): this -> endmarkers/MultiCtor#`<init>`(+1).
[6:6..6:15): MultiCtor -> endmarkers/MultiCtor#
[8:6..8:20): topLevelMethod <- endmarkers/EndMarkers$package.topLevelMethod().
[8:22..8:28): String -> scala/Predef.String#
[10:6..10:20): topLevelMethod -> endmarkers/EndMarkers$package.topLevelMethod().
[12:6..12:17): topLevelVal <- endmarkers/EndMarkers$package.topLevelVal.
[12:19..12:22): Int -> scala/Int#
[14:6..14:17): topLevelVal -> endmarkers/EndMarkers$package.topLevelVal.
[16:6..16:17): topLevelVar <- endmarkers/EndMarkers$package.topLevelVar().
[16:19..16:25): String -> scala/Predef.String#
[18:6..18:17): topLevelVar -> endmarkers/EndMarkers$package.topLevelVar().
[20:8..20:17): Container <- endmarkers/Container#
[22:4..22:4): <- endmarkers/Container#`<init>`().
[22:8..22:11): foo <- endmarkers/Container#foo().
[24:8..24:11): foo -> endmarkers/Container#foo().
[26:8..26:11): bar <- endmarkers/Container#bar.
[28:8..28:11): bar -> endmarkers/Container#bar.
[30:8..30:11): baz <- endmarkers/Container#baz().
[32:8..32:11): baz -> endmarkers/Container#baz().
[34:6..34:15): Container -> endmarkers/Container#
[36:6..36:24): topLevelWithLocals <- endmarkers/EndMarkers$package.topLevelWithLocals().
[36:26..36:30): Unit -> scala/Unit#
[38:8..38:16): localVal <- local0
[40:8..40:16): localVal -> local0
[42:8..42:16): localVar <- local1
[44:8..44:16): localVar -> local1
[46:8..46:16): localDef <- local2
[48:8..48:16): localDef -> local2
[50:6..50:24): topLevelWithLocals -> endmarkers/EndMarkers$package.topLevelWithLocals().
[52:9..52:16): TestObj <- endmarkers/TestObj.
[54:8..54:11): foo <- endmarkers/TestObj.foo().
[56:6..56:13): TestObj -> endmarkers/TestObj.
[58:8..58:13): Stuff <- endmarkers/Stuff#
[58:13..58:13): <- endmarkers/Stuff#`<init>`().
[58:14..58:15): A <- endmarkers/Stuff#[A]
[59:9..59:11): do <- endmarkers/Stuff#do().
[59:14..59:15): A -> endmarkers/Stuff#[A]
[60:6..60:11): Stuff -> endmarkers/Stuff#
[63:8..63:13): Stuff -> endmarkers/Stuff#
[63:14..63:20): String -> scala/Predef.String#
[64:9..64:11): do <- endmarkers/EndMarkers$package.given_Stuff_String.do().
[64:14..64:20): String -> scala/Predef.String#
[67:4..67:14): endmarkers -> endmarkers/

expect/EndMarkers2.scala
------------------------

Summary:
Schema => SemanticDB v4
Uri => EndMarkers2.scala
Text => empty
Language => Scala
Symbols => 2 entries
Occurrences => 5 entries

Symbols:
endmarkers2/package. => final package object endmarkers2 extends Object { self: endmarkers2.type => +2 decls }
endmarkers2/package.Foo# => type Foo  = Unit

Occurrences:
[0:15..0:26): endmarkers2 <- endmarkers2/package.
[2:7..2:10): Foo <- endmarkers2/package.Foo#
[3:4..3:8): Unit -> scala/Unit#
[4:6..4:9): Foo -> endmarkers2/package.Foo#
[6:4..6:15): endmarkers2 -> endmarkers2/package.

expect/EnumVal.scala
--------------------

Summary:
Schema => SemanticDB v4
Uri => EnumVal.scala
Text => empty
Language => Scala
Symbols => 16 entries
Occurrences => 18 entries

Symbols:
enumVal/A# => trait A extends Object { self: A => +1 decls }
enumVal/A#`<init>`(). => primary ctor <init> (): A
enumVal/Color# => abstract sealed enum class Color extends Object with Enum { self: Color => +2 decls }
enumVal/Color#`<init>`(). => primary ctor <init> (val param rgb: Int): Color
enumVal/Color#`<init>`().(rgb) => val param rgb: Int
enumVal/Color#rgb. => val method rgb Int
enumVal/Color. => final object Color extends Object { self: Color.type => +8 decls }
enumVal/Color.$values. => private[this] val method $values Array[Color]
enumVal/Color.Blue. => case val static enum method Blue Color
enumVal/Color.Green. => case val static enum method Green Color & A
enumVal/Color.Red. => case val static enum method Red Color
enumVal/Color.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Color
enumVal/Color.fromOrdinal().(ordinal) => param ordinal: Int
enumVal/Color.valueOf(). => method valueOf (param $name: String): Color
enumVal/Color.valueOf().($name) => param $name: String
enumVal/Color.values(). => method values => Array[Color]

Occurrences:
[0:8..0:15): enumVal <- enumVal/
[2:7..2:12): scala -> scala/
[2:13..2:20): runtime -> scala/runtime/
[2:21..2:30): EnumValue -> scala/runtime/EnumValue.
[5:0..5:0): <- enumVal/A#`<init>`().
[5:6..5:7): A <- enumVal/A#
[7:5..7:10): Color <- enumVal/Color#
[7:10..7:10): <- enumVal/Color#`<init>`().
[7:15..7:18): rgb <- enumVal/Color#rgb.
[7:20..7:23): Int -> scala/Int#
[8:7..8:10): Red <- enumVal/Color.Red.
[8:21..8:26): Color -> enumVal/Color#
[8:42..8:51): EnumValue -> scala/runtime/EnumValue#
[9:7..9:12): Green <- enumVal/Color.Green.
[9:21..9:26): Color -> enumVal/Color#
[9:42..9:43): A -> enumVal/A#
[10:7..10:11): Blue <- enumVal/Color.Blue.
[10:21..10:26): Color -> enumVal/Color#

expect/Enums.scala
------------------

Summary:
Schema => SemanticDB v4
Uri => Enums.scala
Text => empty
Language => Scala
Symbols => 181 entries
Occurrences => 159 entries
Synthetics => 6 entries

Symbols:
_empty_/Enums. => final object Enums extends Object { self: Enums.type => +30 decls }
_empty_/Enums.Coin# => abstract sealed enum class Coin extends Object with Enum { self: Coin => +2 decls }
_empty_/Enums.Coin#`<init>`(). => primary ctor <init> (param value: Int): Coin
_empty_/Enums.Coin#`<init>`().(value) => param value: Int
_empty_/Enums.Coin#value. => private[this] val method value Int
_empty_/Enums.Coin. => final object Coin extends Object { self: Coin.type => +10 decls }
_empty_/Enums.Coin.$values. => private[this] val method $values Array[Coin]
_empty_/Enums.Coin.Dime. => case val static enum method Dime Coin
_empty_/Enums.Coin.Dollar. => case val static enum method Dollar Coin
_empty_/Enums.Coin.Nickel. => case val static enum method Nickel Coin
_empty_/Enums.Coin.Penny. => case val static enum method Penny Coin
_empty_/Enums.Coin.Quarter. => case val static enum method Quarter Coin
_empty_/Enums.Coin.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Coin
_empty_/Enums.Coin.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.Coin.valueOf(). => method valueOf (param $name: String): Coin
_empty_/Enums.Coin.valueOf().($name) => param $name: String
_empty_/Enums.Coin.values(). => method values => Array[Coin]
_empty_/Enums.Colour# => abstract sealed enum class Colour extends Object with Enum { self: Colour => +1 decls }
_empty_/Enums.Colour#`<init>`(). => primary ctor <init> (): Colour
_empty_/Enums.Colour. => final object Colour extends Object { self: Colour.type => +9 decls }
_empty_/Enums.Colour.$new(). => private[this] method $new (param _$ordinal: Int, param $name: String): Colour
_empty_/Enums.Colour.$new().($name) => param $name: String
_empty_/Enums.Colour.$new().(_$ordinal) => param _$ordinal: Int
_empty_/Enums.Colour.$values. => private[this] val method $values Array[Colour]
_empty_/Enums.Colour.Blue. => case val static enum method Blue Colour
_empty_/Enums.Colour.Green. => case val static enum method Green Colour
_empty_/Enums.Colour.Red. => case val static enum method Red Colour
_empty_/Enums.Colour.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Colour
_empty_/Enums.Colour.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.Colour.valueOf(). => method valueOf (param $name: String): Colour
_empty_/Enums.Colour.valueOf().($name) => param $name: String
_empty_/Enums.Colour.values(). => method values => Array[Colour]
_empty_/Enums.Directions# => abstract sealed enum class Directions extends Object with Enum { self: Directions => +1 decls }
_empty_/Enums.Directions#`<init>`(). => primary ctor <init> (): Directions
_empty_/Enums.Directions. => final object Directions extends Object { self: Directions.type => +10 decls }
_empty_/Enums.Directions.$new(). => private[this] method $new (param _$ordinal: Int, param $name: String): Directions
_empty_/Enums.Directions.$new().($name) => param $name: String
_empty_/Enums.Directions.$new().(_$ordinal) => param _$ordinal: Int
_empty_/Enums.Directions.$values. => private[this] val method $values Array[Directions]
_empty_/Enums.Directions.East. => case val static enum method East Directions
_empty_/Enums.Directions.North. => case val static enum method North Directions
_empty_/Enums.Directions.South. => case val static enum method South Directions
_empty_/Enums.Directions.West. => case val static enum method West Directions
_empty_/Enums.Directions.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Directions
_empty_/Enums.Directions.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.Directions.valueOf(). => method valueOf (param $name: String): Directions
_empty_/Enums.Directions.valueOf().($name) => param $name: String
_empty_/Enums.Directions.values(). => method values => Array[Directions]
_empty_/Enums.Maybe# => abstract sealed enum class Maybe [covariant typeparam A ] extends Object with Enum { self: Maybe[A] => +2 decls }
_empty_/Enums.Maybe#[A] => covariant typeparam A 
_empty_/Enums.Maybe#`<init>`(). => primary ctor <init> [covariant typeparam A ](): Maybe[A]
_empty_/Enums.Maybe. => final object Maybe extends Object { self: Maybe.type => +6 decls }
_empty_/Enums.Maybe.Just# => final case enum class Just [covariant typeparam A ] extends Maybe[A] { self: Just[A] => +7 decls }
_empty_/Enums.Maybe.Just#[A] => covariant typeparam A 
_empty_/Enums.Maybe.Just#_1(). => method _1 => A
_empty_/Enums.Maybe.Just#`<init>`(). => primary ctor <init> [covariant typeparam A ](val param value: A): Just[A]
_empty_/Enums.Maybe.Just#`<init>`().(value) => val param value: A
_empty_/Enums.Maybe.Just#copy$default$1(). => method copy$default$1 [covariant typeparam A ]: A
_empty_/Enums.Maybe.Just#copy$default$1().[A] => typeparam A 
_empty_/Enums.Maybe.Just#copy(). => method copy [covariant typeparam A ](param value: A): Just[A]
_empty_/Enums.Maybe.Just#copy().(value) => param value: A
_empty_/Enums.Maybe.Just#copy().[A] => typeparam A 
_empty_/Enums.Maybe.Just#ordinal(). => method ordinal => Int <: scala/reflect/Enum#ordinal().
_empty_/Enums.Maybe.Just#value. => val method value A
_empty_/Enums.Maybe.Just. => final object Just extends Object { self: Just.type => +4 decls }
_empty_/Enums.Maybe.Just.apply(). => method apply [typeparam A ](param value: A): Just[A]
_empty_/Enums.Maybe.Just.apply().(value) => param value: A
_empty_/Enums.Maybe.Just.apply().[A] => typeparam A 
_empty_/Enums.Maybe.Just.toString(). => method toString => String <: scala/Any#toString().
_empty_/Enums.Maybe.Just.unapply(). => method unapply [typeparam A ](param x$1: Just[A]): Just[A]
_empty_/Enums.Maybe.Just.unapply().(x$1) => param x$1: Just[A]
_empty_/Enums.Maybe.Just.unapply().[A] => typeparam A 
_empty_/Enums.Maybe.None. => case val static enum method None Maybe[Nothing]
_empty_/Enums.Maybe.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Maybe[_] forSome { type _  }
_empty_/Enums.Maybe.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.Planet# => abstract sealed enum class Planet extends Enum[Planet] with Enum { self: Planet => +6 decls }
_empty_/Enums.Planet#G. => private[this] final val method G 6.673E-11
_empty_/Enums.Planet#`<init>`(). => primary ctor <init> (param mass: Double, param radius: Double): Planet
_empty_/Enums.Planet#`<init>`().(mass) => param mass: Double
_empty_/Enums.Planet#`<init>`().(radius) => param radius: Double
_empty_/Enums.Planet#mass. => private[this] val method mass Double
_empty_/Enums.Planet#radius. => private[this] val method radius Double
_empty_/Enums.Planet#surfaceGravity(). => method surfaceGravity => Double
_empty_/Enums.Planet#surfaceWeight(). => method surfaceWeight (param otherMass: Double): Double
_empty_/Enums.Planet#surfaceWeight().(otherMass) => param otherMass: Double
_empty_/Enums.Planet. => final object Planet extends Object { self: Planet.type => +13 decls }
_empty_/Enums.Planet.$values. => private[this] val method $values Array[Planet]
_empty_/Enums.Planet.Earth. => case val static enum method Earth Planet
_empty_/Enums.Planet.Jupiter. => case val static enum method Jupiter Planet
_empty_/Enums.Planet.Mars. => case val static enum method Mars Planet
_empty_/Enums.Planet.Mercury. => case val static enum method Mercury Planet
_empty_/Enums.Planet.Neptune. => case val static enum method Neptune Planet
_empty_/Enums.Planet.Saturn. => case val static enum method Saturn Planet
_empty_/Enums.Planet.Uranus. => case val static enum method Uranus Planet
_empty_/Enums.Planet.Venus. => case val static enum method Venus Planet
_empty_/Enums.Planet.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Planet
_empty_/Enums.Planet.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.Planet.valueOf(). => method valueOf (param $name: String): Planet
_empty_/Enums.Planet.valueOf().($name) => param $name: String
_empty_/Enums.Planet.values(). => method values => Array[Planet]
_empty_/Enums.Suits# => abstract sealed enum class Suits extends Object with Enum { self: Suits => +1 decls }
_empty_/Enums.Suits#`<init>`(). => primary ctor <init> (): Suits
_empty_/Enums.Suits. => final object Suits extends Object { self: Suits.type => +13 decls }
_empty_/Enums.Suits.$new(). => private[this] method $new (param _$ordinal: Int, param $name: String): Suits
_empty_/Enums.Suits.$new().($name) => param $name: String
_empty_/Enums.Suits.$new().(_$ordinal) => param _$ordinal: Int
_empty_/Enums.Suits.$values. => private[this] val method $values Array[Suits]
_empty_/Enums.Suits.Clubs. => case val static enum method Clubs Suits
_empty_/Enums.Suits.Diamonds. => case val static enum method Diamonds Suits
_empty_/Enums.Suits.Hearts. => case val static enum method Hearts Suits
_empty_/Enums.Suits.Spades. => case val static enum method Spades Suits
_empty_/Enums.Suits.derived$CanEqual. => implicit lazy val given method derived$CanEqual CanEqual[Suits, Suits]
_empty_/Enums.Suits.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Suits
_empty_/Enums.Suits.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.Suits.isBlack(). => method isBlack (param suit: Suits): Boolean
_empty_/Enums.Suits.isBlack().(suit) => param suit: Suits
_empty_/Enums.Suits.isRed(). => method isRed (param suit: Suits): Boolean
_empty_/Enums.Suits.isRed().(suit) => param suit: Suits
_empty_/Enums.Suits.valueOf(). => method valueOf (param $name: String): Suits
_empty_/Enums.Suits.valueOf().($name) => param $name: String
_empty_/Enums.Suits.values(). => method values => Array[Suits]
_empty_/Enums.Tag# => abstract sealed enum class Tag [typeparam A ] extends Object with Enum { self: Tag[A] => +2 decls }
_empty_/Enums.Tag#[A] => typeparam A 
_empty_/Enums.Tag#`<init>`(). => primary ctor <init> [typeparam A ](): Tag[A]
_empty_/Enums.Tag. => final object Tag extends Object { self: Tag.type => +7 decls }
_empty_/Enums.Tag.$values. => private[this] val method $values Array[Tag[_] forSome { type _  }]
_empty_/Enums.Tag.BooleanTag. => case val static enum method BooleanTag Tag[Boolean]
_empty_/Enums.Tag.IntTag. => case val static enum method IntTag Tag[Int]
_empty_/Enums.Tag.fromOrdinal(). => method fromOrdinal (param ordinal: Int): Tag[_] forSome { type _  }
_empty_/Enums.Tag.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.Tag.valueOf(). => method valueOf (param $name: String): Tag[_] forSome { type _  >: Int & Boolean <: Int | Boolean }
_empty_/Enums.Tag.valueOf().($name) => param $name: String
_empty_/Enums.Tag.values(). => method values => Array[Tag[_] forSome { type _  }]
_empty_/Enums.WeekDays# => abstract sealed enum class WeekDays extends Object with Enum { self: WeekDays => +1 decls }
_empty_/Enums.WeekDays#`<init>`(). => primary ctor <init> (): WeekDays
_empty_/Enums.WeekDays. => final object WeekDays extends Object { self: WeekDays.type => +13 decls }
_empty_/Enums.WeekDays.$new(). => private[this] method $new (param _$ordinal: Int, param $name: String): WeekDays
_empty_/Enums.WeekDays.$new().($name) => param $name: String
_empty_/Enums.WeekDays.$new().(_$ordinal) => param _$ordinal: Int
_empty_/Enums.WeekDays.$values. => private[this] val method $values Array[WeekDays]
_empty_/Enums.WeekDays.Friday. => case val static enum method Friday WeekDays
_empty_/Enums.WeekDays.Monday. => case val static enum method Monday WeekDays
_empty_/Enums.WeekDays.Saturday. => case val static enum method Saturday WeekDays
_empty_/Enums.WeekDays.Sunday. => case val static enum method Sunday WeekDays
_empty_/Enums.WeekDays.Thursday. => case val static enum method Thursday WeekDays
_empty_/Enums.WeekDays.Tuesday. => case val static enum method Tuesday WeekDays
_empty_/Enums.WeekDays.Wednesday. => case val static enum method Wednesday WeekDays
_empty_/Enums.WeekDays.fromOrdinal(). => method fromOrdinal (param ordinal: Int): WeekDays
_empty_/Enums.WeekDays.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.WeekDays.valueOf(). => method valueOf (param $name: String): WeekDays
_empty_/Enums.WeekDays.valueOf().($name) => param $name: String
_empty_/Enums.WeekDays.values(). => method values => Array[WeekDays]
_empty_/Enums.`<:<`# => abstract sealed enum class <:< [contravariant typeparam A , typeparam B ] extends Object with Enum { self: <:<[A, B] => +3 decls }
_empty_/Enums.`<:<`#[A] => contravariant typeparam A 
_empty_/Enums.`<:<`#[B] => typeparam B 
_empty_/Enums.`<:<`#`<init>`(). => primary ctor <init> [contravariant typeparam A , typeparam B ](): <:<[A, B]
_empty_/Enums.`<:<`. => final object <:< extends Object { self: <:<.type => +6 decls }
_empty_/Enums.`<:<`.Refl# => final case enum class Refl [typeparam C ] extends <:<[C, C] { self: Refl[C] => +4 decls }
_empty_/Enums.`<:<`.Refl#[C] => typeparam C 
_empty_/Enums.`<:<`.Refl#`<init>`(). => primary ctor <init> [typeparam C ](): Refl[C]
_empty_/Enums.`<:<`.Refl#copy(). => method copy [typeparam C ](): Refl[C]
_empty_/Enums.`<:<`.Refl#copy().[C] => typeparam C 
_empty_/Enums.`<:<`.Refl#ordinal(). => method ordinal => Int <: scala/reflect/Enum#ordinal().
_empty_/Enums.`<:<`.Refl. => final object Refl extends Object { self: Refl.type => +4 decls }
_empty_/Enums.`<:<`.Refl.apply(). => method apply [typeparam C ](): Refl[C]
_empty_/Enums.`<:<`.Refl.apply().[C] => typeparam C 
_empty_/Enums.`<:<`.Refl.toString(). => method toString => String <: scala/Any#toString().
_empty_/Enums.`<:<`.Refl.unapply(). => method unapply [typeparam C ](param x$1: Refl[C]): true
_empty_/Enums.`<:<`.Refl.unapply().(x$1) => param x$1: Refl[C]
_empty_/Enums.`<:<`.Refl.unapply().[C] => typeparam C 
_empty_/Enums.`<:<`.`given_<:<_T_T`(). => final implicit given method given_<:<_T_T [typeparam T ]: <:<[T, T]
_empty_/Enums.`<:<`.`given_<:<_T_T`().[T] => typeparam T 
_empty_/Enums.`<:<`.fromOrdinal(). => method fromOrdinal (param ordinal: Int): <:<[_, _] forSome { type _ ; type _  }
_empty_/Enums.`<:<`.fromOrdinal().(ordinal) => param ordinal: Int
_empty_/Enums.some1. => val method some1 Option[Int]
_empty_/Enums.unwrap(). => method unwrap [typeparam A , typeparam B ](param opt: Option[A])(implicit given param ev: <:<[A, Option[B]]): Option[B]
_empty_/Enums.unwrap().(ev) => implicit given param ev: <:<[A, Option[B]]
_empty_/Enums.unwrap().(opt) => param opt: Option[A]
_empty_/Enums.unwrap().[A] => typeparam A 
_empty_/Enums.unwrap().[B] => typeparam B 
local0 => param x: Option[B]

Occurrences:
[0:7..0:12): Enums <- _empty_/Enums.
[1:9..1:12): <:< -> _empty_/Enums.`<:<`.
[3:7..3:13): Colour <- _empty_/Enums.Colour#
[4:4..4:4): <- _empty_/Enums.Colour#`<init>`().
[4:11..4:17): Colour -> _empty_/Enums.Colour.
[4:18..4:21): Red -> _empty_/Enums.Colour.Red.
[5:9..5:12): Red <- _empty_/Enums.Colour.Red.
[5:14..5:19): Green <- _empty_/Enums.Colour.Green.
[5:21..5:25): Blue <- _empty_/Enums.Colour.Blue.
[7:7..7:17): Directions <- _empty_/Enums.Directions#
[8:4..8:4): <- _empty_/Enums.Directions#`<init>`().
[8:9..8:14): North <- _empty_/Enums.Directions.North.
[8:16..8:20): East <- _empty_/Enums.Directions.East.
[8:22..8:27): South <- _empty_/Enums.Directions.South.
[8:29..8:33): West <- _empty_/Enums.Directions.West.
[10:7..10:12): Suits <- _empty_/Enums.Suits#
[10:21..10:21): <- _empty_/Enums.Suits#`<init>`().
[11:9..11:15): Hearts <- _empty_/Enums.Suits.Hearts.
[11:17..11:23): Spades <- _empty_/Enums.Suits.Spades.
[11:25..11:30): Clubs <- _empty_/Enums.Suits.Clubs.
[11:32..11:40): Diamonds <- _empty_/Enums.Suits.Diamonds.
[13:9..13:14): Suits <- _empty_/Enums.Suits.
[14:15..14:19): suit <- _empty_/Enums.Suits.isRed().(suit)
[14:21..14:26): Suits -> _empty_/Enums.Suits#
[14:32..14:37): isRed <- _empty_/Enums.Suits.isRed().
[14:39..14:46): Boolean -> scala/Boolean#
[15:6..15:10): suit -> _empty_/Enums.Suits.isRed().(suit)
[15:11..15:13): == -> scala/Any#`==`().
[15:14..15:20): Hearts -> _empty_/Enums.Suits.Hearts.
[15:21..15:23): || -> scala/Boolean#`||`().
[15:24..15:28): suit -> _empty_/Enums.Suits.isRed().(suit)
[15:29..15:31): == -> scala/Any#`==`().
[15:32..15:40): Diamonds -> _empty_/Enums.Suits.Diamonds.
[17:15..17:19): suit <- _empty_/Enums.Suits.isBlack().(suit)
[17:21..17:26): Suits -> _empty_/Enums.Suits#
[17:32..17:39): isBlack <- _empty_/Enums.Suits.isBlack().
[17:41..17:48): Boolean -> scala/Boolean#
[17:51..17:55): suit -> _empty_/Enums.Suits.isBlack().(suit)
[18:11..18:17): Spades -> _empty_/Enums.Suits.Spades.
[18:20..18:25): Clubs -> _empty_/Enums.Suits.Clubs.
[21:7..21:15): WeekDays <- _empty_/Enums.WeekDays#
[22:4..22:4): <- _empty_/Enums.WeekDays#`<init>`().
[22:9..22:15): Monday <- _empty_/Enums.WeekDays.Monday.
[23:9..23:16): Tuesday <- _empty_/Enums.WeekDays.Tuesday.
[24:9..24:18): Wednesday <- _empty_/Enums.WeekDays.Wednesday.
[25:9..25:17): Thursday <- _empty_/Enums.WeekDays.Thursday.
[26:9..26:15): Friday <- _empty_/Enums.WeekDays.Friday.
[27:9..27:17): Saturday <- _empty_/Enums.WeekDays.Saturday.
[28:9..28:15): Sunday <- _empty_/Enums.WeekDays.Sunday.
[30:7..30:11): Coin <- _empty_/Enums.Coin#
[30:11..30:11): <- _empty_/Enums.Coin#`<init>`().
[30:12..30:17): value <- _empty_/Enums.Coin#value.
[30:19..30:22): Int -> scala/Int#
[31:9..31:14): Penny <- _empty_/Enums.Coin.Penny.
[31:26..31:30): Coin -> _empty_/Enums.Coin#
[32:9..32:15): Nickel <- _empty_/Enums.Coin.Nickel.
[32:26..32:30): Coin -> _empty_/Enums.Coin#
[33:9..33:13): Dime <- _empty_/Enums.Coin.Dime.
[33:26..33:30): Coin -> _empty_/Enums.Coin#
[34:9..34:16): Quarter <- _empty_/Enums.Coin.Quarter.
[34:26..34:30): Coin -> _empty_/Enums.Coin#
[35:9..35:15): Dollar <- _empty_/Enums.Coin.Dollar.
[35:26..35:30): Coin -> _empty_/Enums.Coin#
[37:7..37:12): Maybe <- _empty_/Enums.Maybe#
[37:12..37:12): <- _empty_/Enums.Maybe#`<init>`().
[37:14..37:15): A <- _empty_/Enums.Maybe#[A]
[38:9..38:13): Just <- _empty_/Enums.Maybe.Just#
[38:13..38:13): <- _empty_/Enums.Maybe.Just#`<init>`().
[38:14..38:19): value <- _empty_/Enums.Maybe.Just#value.
[38:21..38:22): A -> _empty_/Enums.Maybe.Just#[A]
[39:9..39:13): None <- _empty_/Enums.Maybe.None.
[41:7..41:10): Tag <- _empty_/Enums.Tag#
[41:10..41:10): <- _empty_/Enums.Tag#`<init>`().
[41:11..41:12): A <- _empty_/Enums.Tag#[A]
[42:9..42:15): IntTag <- _empty_/Enums.Tag.IntTag.
[42:24..42:27): Tag -> _empty_/Enums.Tag#
[42:28..42:31): Int -> scala/Int#
[43:9..43:19): BooleanTag <- _empty_/Enums.Tag.BooleanTag.
[43:28..43:31): Tag -> _empty_/Enums.Tag#
[43:32..43:39): Boolean -> scala/Boolean#
[45:7..45:10): <:< <- _empty_/Enums.`<:<`#
[45:10..45:10): <- _empty_/Enums.`<:<`#`<init>`().
[45:12..45:13): A <- _empty_/Enums.`<:<`#[A]
[45:15..45:16): B <- _empty_/Enums.`<:<`#[B]
[46:9..46:13): Refl <- _empty_/Enums.`<:<`.Refl#
[46:13..46:13): <- _empty_/Enums.`<:<`.Refl#`<init>`().
[46:14..46:15): C <- _empty_/Enums.`<:<`.Refl#[C]
[46:28..46:29): C -> _empty_/Enums.`<:<`.Refl#[C]
[46:30..46:33): <:< -> _empty_/Enums.`<:<`#
[46:34..46:35): C -> _empty_/Enums.`<:<`.Refl#[C]
[48:10..48:13): <:< <- _empty_/Enums.`<:<`.
[49:11..49:12): T <- _empty_/Enums.`<:<`.`given_<:<_T_T`().[T]
[49:16..49:17): T -> _empty_/Enums.`<:<`.`given_<:<_T_T`().[T]
[49:18..49:21): <:< -> _empty_/Enums.`<:<`#
[49:22..49:23): T -> _empty_/Enums.`<:<`.`given_<:<_T_T`().[T]
[49:27..49:31): Refl -> _empty_/Enums.`<:<`.Refl.
[51:13..51:14): A <- _empty_/Enums.unwrap().[A]
[51:16..51:17): B <- _empty_/Enums.unwrap().[B]
[51:19..51:22): opt <- _empty_/Enums.unwrap().(opt)
[51:24..51:30): Option -> scala/Option#
[51:31..51:32): A -> _empty_/Enums.unwrap().[A]
[51:39..51:45): unwrap <- _empty_/Enums.unwrap().
[51:52..51:54): ev <- _empty_/Enums.unwrap().(ev)
[51:56..51:57): A -> _empty_/Enums.unwrap().[A]
[51:58..51:61): <:< -> _empty_/Enums.`<:<`#
[51:62..51:68): Option -> scala/Option#
[51:69..51:70): B -> _empty_/Enums.unwrap().[B]
[51:74..51:80): Option -> scala/Option#
[51:81..51:82): B -> _empty_/Enums.unwrap().[B]
[51:86..51:88): ev -> _empty_/Enums.unwrap().(ev)
[52:9..52:13): Refl -> _empty_/Enums.`<:<`.Refl.
[52:19..52:22): opt -> _empty_/Enums.unwrap().(opt)
[52:23..52:30): flatMap -> scala/Option#flatMap().
[52:31..52:39): identity -> scala/Predef.identity().
[52:40..52:46): Option -> scala/Option#
[52:47..52:48): B -> _empty_/Enums.unwrap().[B]
[54:6..54:11): some1 <- _empty_/Enums.some1.
[54:14..54:18): Some -> scala/Some.
[54:19..54:23): Some -> scala/Some.
[54:28..54:34): unwrap -> _empty_/Enums.unwrap().
[56:7..56:13): Planet <- _empty_/Enums.Planet#
[56:13..56:13): <- _empty_/Enums.Planet#`<init>`().
[56:14..56:18): mass <- _empty_/Enums.Planet#mass.
[56:20..56:26): Double -> scala/Double#
[56:28..56:34): radius <- _empty_/Enums.Planet#radius.
[56:36..56:42): Double -> scala/Double#
[56:52..56:56): Enum -> java/lang/Enum#
[56:57..56:63): Planet -> _empty_/Enums.Planet#
[57:22..57:23): G <- _empty_/Enums.Planet#G.
[58:8..58:22): surfaceGravity <- _empty_/Enums.Planet#surfaceGravity().
[58:25..58:26): G -> _empty_/Enums.Planet#G.
[58:27..58:28): * -> scala/Double#`*`(+6).
[58:29..58:33): mass -> _empty_/Enums.Planet#mass.
[58:34..58:35): / -> scala/Double#`/`(+6).
[58:37..58:43): radius -> _empty_/Enums.Planet#radius.
[58:44..58:45): * -> scala/Double#`*`(+6).
[58:46..58:52): radius -> _empty_/Enums.Planet#radius.
[59:8..59:21): surfaceWeight <- _empty_/Enums.Planet#surfaceWeight().
[59:22..59:31): otherMass <- _empty_/Enums.Planet#surfaceWeight().(otherMass)
[59:33..59:39): Double -> scala/Double#
[59:43..59:52): otherMass -> _empty_/Enums.Planet#surfaceWeight().(otherMass)
[59:53..59:54): * -> scala/Double#`*`(+6).
[59:55..59:69): surfaceGravity -> _empty_/Enums.Planet#surfaceGravity().
[61:9..61:16): Mercury <- _empty_/Enums.Planet.Mercury.
[61:25..61:31): Planet -> _empty_/Enums.Planet#
[62:9..62:14): Venus <- _empty_/Enums.Planet.Venus.
[62:25..62:31): Planet -> _empty_/Enums.Planet#
[63:9..63:14): Earth <- _empty_/Enums.Planet.Earth.
[63:25..63:31): Planet -> _empty_/Enums.Planet#
[64:9..64:13): Mars <- _empty_/Enums.Planet.Mars.
[64:25..64:31): Planet -> _empty_/Enums.Planet#
[65:9..65:16): Jupiter <- _empty_/Enums.Planet.Jupiter.
[65:25..65:31): Planet -> _empty_/Enums.Planet#
[66:9..66:15): Saturn <- _empty_/Enums.Planet.Saturn.
[66:25..66:31): Planet -> _empty_/Enums.Planet#
[67:9..67:15): Uranus <- _empty_/Enums.Planet.Uranus.
[67:25..67:31): Planet -> _empty_/Enums.Planet#
[68:9..68:16): Neptune <- _empty_/Enums.Planet.Neptune.
[68:25..68:31): Planet -> _empty_/Enums.Planet#

Synthetics:
[52:9..52:13):Refl => *.unapply[Option[B]]
[52:31..52:50):identity[Option[B]] => *[Function1[A, Option[B]]]
[54:14..54:18):Some => *.apply[Some[Int]]
[54:14..54:34):Some(Some(1)).unwrap => *(given_<:<_T_T[Option[Int]])
[54:19..54:23):Some => *.apply[Int]
[54:28..54:34):unwrap => *[Some[Int], Int]

expect/EtaExpansion.scala
-------------------------

Summary:
Schema => SemanticDB v4
Uri => EtaExpansion.scala
Text => empty
Language => Scala
Symbols => 3 entries
Occurrences => 9 entries
Synthetics => 5 entries

Symbols:
example/EtaExpansion# => class EtaExpansion extends Object { self: EtaExpansion => +1 decls }
example/EtaExpansion#`<init>`(). => primary ctor <init> (): EtaExpansion
local0 => param x: Int

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:18): EtaExpansion <- example/EtaExpansion#
[3:2..3:6): Some -> scala/Some.
[3:2..3:2): <- example/EtaExpansion#`<init>`().
[3:10..3:13): map -> scala/Option#map().
[3:14..3:22): identity -> scala/Predef.identity().
[4:2..4:6): List -> scala/package.List.
[4:10..4:18): foldLeft -> scala/collection/LinearSeqOps#foldLeft().
[4:25..4:26): + -> java/lang/String#`+`().

Synthetics:
[3:2..3:13):Some(1).map => *[Int]
[3:2..3:6):Some => *.apply[Int]
[3:14..3:22):identity => *[Int]
[4:2..4:18):List(1).foldLeft => *[String]
[4:2..4:6):List => *.apply[Int]

expect/Example.scala
--------------------

Summary:
Schema => SemanticDB v4
Uri => Example.scala
Text => empty
Language => Scala
Symbols => 5 entries
Occurrences => 23 entries

Symbols:
example/Example. => final object Example extends Object { self: Example.type => +3 decls }
example/Example.main(). => method main (param args: Array[String]): Unit
example/Example.main().(args) => param args: Array[String]
example/Example.x. => val method x ClassTag[Int]
local0 => selfparam self: Example.type

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:12): scala -> scala/
[2:13..2:23): concurrent -> scala/concurrent/
[2:24..2:30): Future -> scala/concurrent/Future.
[2:24..2:30): Future -> scala/concurrent/Future#
[4:7..4:14): Example <- example/Example.
[4:17..4:21): self <- local0
[5:6..5:11): scala -> scala/
[5:12..5:22): collection -> scala/collection/
[5:23..5:30): mutable -> scala/collection/mutable/
[5:31..5:36): Stack -> scala/collection/mutable/Stack#
[5:37..5:40): Int -> scala/Int#
[6:6..6:10): main <- example/Example.main().
[6:11..6:15): args <- example/Example.main().(args)
[6:17..6:22): Array -> scala/Array#
[6:23..6:29): String -> scala/Predef.String#
[6:33..6:37): Unit -> scala/Unit#
[7:4..7:11): println -> scala/Predef.println(+1).
[9:6..9:7): x <- example/Example.x.
[9:10..9:15): scala -> scala/
[9:16..9:23): reflect -> scala/reflect/
[9:24..9:32): classTag -> scala/reflect/package.classTag().
[9:33..9:36): Int -> scala/Int#

expect/Extension.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => Extension.scala
Text => empty
Language => Scala
Symbols => 32 entries
Occurrences => 66 entries
Synthetics => 1 entries

Symbols:
ext/DeckUsage. => final object DeckUsage extends Object { self: DeckUsage.type => +2 decls }
ext/DeckUsage.deck. => val method deck Deck
ext/Extension$package. => final package object ext extends Object { self: ext.type { opaque type Deck  } => +9 decls }
ext/Extension$package.Deck# => opaque type Deck 
ext/Extension$package.Deck. => final object Deck extends Object { self: Deck.type => +2 decls }
ext/Extension$package.Deck.fooSize(). => method fooSize (param data: Deck): Int
ext/Extension$package.Deck.fooSize().(data) => param data: Deck
ext/Extension$package.`#*#`(). => method #*# (param s: String)(param i: Int): Tuple2[String, Int]
ext/Extension$package.`#*#`().(i) => param i: Int
ext/Extension$package.`#*#`().(s) => param s: String
ext/Extension$package.a. => val method a Int
ext/Extension$package.c. => val method c Tuple2[String, Int]
ext/Extension$package.foo(). => method foo (param s: String): Int
ext/Extension$package.foo().(s) => param s: String
ext/Extension$package.readInto(). => method readInto [typeparam T ](param s: String)(implicit given param x$2: Read[T]): Option[T]
ext/Extension$package.readInto().(s) => param s: String
ext/Extension$package.readInto().(x$2) => implicit given param x$2: Read[T]
ext/Extension$package.readInto().[T] => typeparam T 
ext/Functor# => trait Functor [typeparam F [type _ ]] extends Object { self: Functor[F] => +3 decls }
ext/Functor#[F] => typeparam F [type _ ]
ext/Functor#[F][_] => type _ 
ext/Functor#`<init>`(). => primary ctor <init> [typeparam F [type _ ]](): Functor[F]
ext/Functor#map(). => abstract method map [typeparam T , typeparam U ](param t: F[T])(param f: Function1[T, U]): F[U]
ext/Functor#map().(f) => param f: Function1[T, U]
ext/Functor#map().(t) => param t: F[T]
ext/Functor#map().[T] => typeparam T 
ext/Functor#map().[U] => typeparam U 
ext/Read# => trait Read [covariant typeparam T ] extends Object { self: Read[T] => +3 decls }
ext/Read#[T] => covariant typeparam T 
ext/Read#`<init>`(). => primary ctor <init> [covariant typeparam T ](): Read[T]
ext/Read#fromString(). => abstract method fromString (param s: String): Option[T]
ext/Read#fromString().(s) => param s: String

Occurrences:
[0:8..0:11): ext <- ext/
[2:11..2:12): s <- ext/Extension$package.foo().(s)
[2:11..2:12): s <- ext/Extension$package.`#*#`().(s)
[2:14..2:20): String -> scala/Predef.String#
[3:6..3:9): foo <- ext/Extension$package.foo().
[3:11..3:14): Int -> scala/Int#
[4:6..4:9): #*# <- ext/Extension$package.`#*#`().
[4:11..4:12): i <- ext/Extension$package.`#*#`().(i)
[4:14..4:17): Int -> scala/Int#
[4:21..4:27): String -> scala/Predef.String#
[4:29..4:32): Int -> scala/Int#
[4:37..4:38): s -> ext/Extension$package.`#*#`().(s)
[4:40..4:41): i -> ext/Extension$package.`#*#`().(i)
[6:4..6:5): a <- ext/Extension$package.a.
[6:14..6:17): foo -> ext/Extension$package.foo().
[8:4..8:5): c <- ext/Extension$package.c.
[8:14..8:17): #*# -> ext/Extension$package.`#*#`().
[10:6..10:10): Read <- ext/Read#
[10:10..10:10): <- ext/Read#`<init>`().
[10:12..10:13): T <- ext/Read#[T]
[11:6..11:16): fromString <- ext/Read#fromString().
[11:17..11:18): s <- ext/Read#fromString().(s)
[11:20..11:26): String -> scala/Predef.String#
[11:29..11:35): Option -> scala/Option#
[11:36..11:37): T -> ext/Read#[T]
[13:11..13:12): s <- ext/Extension$package.readInto().(s)
[13:14..13:20): String -> scala/Predef.String#
[14:6..14:14): readInto <- ext/Extension$package.readInto().
[14:15..14:16): T <- ext/Extension$package.readInto().[T]
[14:24..14:28): Read -> ext/Read#
[14:29..14:30): T -> ext/Extension$package.readInto().[T]
[14:34..14:40): Option -> scala/Option#
[14:41..14:42): T -> ext/Extension$package.readInto().[T]
[14:46..14:52): summon -> scala/Predef.summon().
[14:53..14:57): Read -> ext/Read#
[14:58..14:59): T -> ext/Extension$package.readInto().[T]
[14:62..14:72): fromString -> ext/Read#fromString().
[14:73..14:74): s -> ext/Extension$package.readInto().(s)
[16:6..16:13): Functor <- ext/Functor#
[16:13..16:13): <- ext/Functor#`<init>`().
[16:14..16:15): F <- ext/Functor#[F]
[17:13..17:14): T <- ext/Functor#map().[T]
[17:16..17:17): t <- ext/Functor#map().(t)
[17:19..17:20): F -> ext/Functor#[F]
[17:21..17:22): T -> ext/Functor#map().[T]
[17:29..17:32): map <- ext/Functor#map().
[17:33..17:34): U <- ext/Functor#map().[U]
[17:36..17:37): f <- ext/Functor#map().(f)
[17:39..17:40): T -> ext/Functor#map().[T]
[17:44..17:45): U -> ext/Functor#map().[U]
[17:48..17:49): F -> ext/Functor#[F]
[17:50..17:51): U -> ext/Functor#map().[U]
[19:12..19:16): Deck <- ext/Extension$package.Deck#
[19:19..19:23): Long -> scala/Long#
[20:7..20:11): Deck <- ext/Extension$package.Deck.
[21:13..21:17): data <- ext/Extension$package.Deck.fooSize().(data)
[21:19..21:23): Deck -> ext/Extension$package.Deck#
[22:8..22:15): fooSize <- ext/Extension$package.Deck.fooSize().
[22:17..22:20): Int -> scala/Int#
[22:23..22:26): ??? -> scala/Predef.`???`().
[24:7..24:16): DeckUsage <- ext/DeckUsage.
[25:6..25:10): deck <- ext/DeckUsage.deck.
[25:12..25:16): Deck -> ext/Extension$package.Deck#
[25:19..25:22): ??? -> scala/Predef.`???`().
[26:2..26:6): deck -> ext/DeckUsage.deck.
[26:7..26:14): fooSize -> ext/Extension$package.Deck.fooSize().

Synthetics:
[14:46..14:61):summon[Read[T]] => *(x$2)

expect/ForComprehension.scala
-----------------------------

Summary:
Schema => SemanticDB v4
Uri => ForComprehension.scala
Text => empty
Language => Scala
Symbols => 13 entries
Occurrences => 53 entries
Synthetics => 6 entries

Symbols:
example/ForComprehension# => class ForComprehension extends Object { self: ForComprehension => +1 decls }
example/ForComprehension#`<init>`(). => primary ctor <init> (): ForComprehension
local0 => param a: Int
local1 => param b: Int
local2 => val local c: Int
local3 => param x$1: Tuple2[Int, Int]
local4 => param a: Int
local5 => param b: Int
local6 => param x$1: Tuple2[Int, Int]
local7 => val local c: Int
local8 => val local d: Int
local9 => val local e: Tuple4[Int, Int, Int, Int]
local10 => param f: Tuple4[Int, Int, Int, Int]

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:22): ForComprehension <- example/ForComprehension#
[3:2..3:2): <- example/ForComprehension#`<init>`().
[4:4..4:5): a <- local0
[4:9..4:13): List -> scala/package.List.
[5:4..5:5): b <- local1
[5:4..5:5): b -> local1
[5:9..5:13): List -> scala/package.List.
[6:7..6:8): b -> local1
[6:9..6:10): > -> scala/Int#`>`(+3).
[7:4..7:5): c <- local2
[7:4..7:5): c -> local2
[7:8..7:9): a -> local0
[7:10..7:11): + -> scala/Int#`+`(+4).
[7:12..7:13): b -> local1
[8:11..8:12): a -> local0
[8:14..8:15): b -> local1
[8:17..8:18): c -> local2
[10:4..10:5): a <- local4
[10:9..10:13): List -> scala/package.List.
[11:4..11:5): b <- local5
[11:9..11:13): List -> scala/package.List.
[11:14..11:15): a -> local4
[13:6..13:7): a -> local4
[14:6..14:7): b -> local5
[15:6..15:8): == -> scala/Any#`==`().
[17:6..17:7): c <- local7
[18:6..18:7): d <- local8
[19:9..19:13): List -> scala/package.List.
[19:15..19:16): a -> local4
[19:18..19:19): b -> local5
[21:6..21:7): a -> local4
[22:6..22:7): b -> local5
[23:6..23:7): c -> local7
[24:6..24:7): d -> local8
[25:6..25:8): == -> scala/Any#`==`().
[26:4..26:5): e <- local9
[26:4..26:5): e -> local9
[27:6..27:7): a -> local4
[28:6..28:7): b -> local5
[29:6..29:7): c -> local7
[30:6..30:7): d -> local8
[32:7..32:8): e -> local9
[32:9..32:11): == -> scala/Any#`==`().
[33:4..33:5): f <- local10
[33:9..33:13): List -> scala/package.List.
[33:14..33:15): e -> local9
[36:6..36:7): a -> local4
[37:6..37:7): b -> local5
[38:6..38:7): c -> local7
[39:6..39:7): d -> local8
[40:6..40:7): e -> local9
[41:6..41:7): f -> local10

Synthetics:
[4:9..4:13):List => *.apply[Int]
[5:9..5:13):List => *.apply[Int]
[10:9..10:13):List => *.apply[Int]
[11:9..11:13):List => *.apply[Int]
[19:9..19:13):List => *.apply[Tuple2[Int, Int]]
[33:9..33:13):List => *.apply[Tuple4[Int, Int, Int, Int]]

expect/Givens.scala
-------------------

Summary:
Schema => SemanticDB v4
Uri => Givens.scala
Text => empty
Language => Scala
Symbols => 33 entries
Occurrences => 72 entries
Synthetics => 3 entries

Symbols:
a/b/Givens. => final object Givens extends Object { self: Givens.type => +13 decls }
a/b/Givens.Monoid# => trait Monoid [typeparam A ] extends Object { self: Monoid[A] => +4 decls }
a/b/Givens.Monoid#[A] => typeparam A 
a/b/Givens.Monoid#`<init>`(). => primary ctor <init> [typeparam A ](): Monoid[A]
a/b/Givens.Monoid#combine(). => abstract method combine (param x: A)(param y: A): A
a/b/Givens.Monoid#combine().(x) => param x: A
a/b/Givens.Monoid#combine().(y) => param y: A
a/b/Givens.Monoid#empty(). => abstract method empty => A
a/b/Givens.foo(). => method foo [typeparam A ](implicit given param A: Monoid[A]): A
a/b/Givens.foo().(A) => implicit given param A: Monoid[A]
a/b/Givens.foo().[A] => typeparam A 
a/b/Givens.given_Monoid_String. => final implicit given object given_Monoid_String extends Object with Monoid[String] { self: given_Monoid_String.type => +3 decls }
a/b/Givens.given_Monoid_String.combine(). => method combine (param x: String)(param y: String): String <: a/b/Givens.Monoid#combine().
a/b/Givens.given_Monoid_String.combine().(x) => param x: String
a/b/Givens.given_Monoid_String.combine().(y) => param y: String
a/b/Givens.given_Monoid_String.empty(). => method empty => String <: a/b/Givens.Monoid#empty().
a/b/Givens.goodbye1. => val method goodbye1 String
a/b/Givens.hello1. => val method hello1 String
a/b/Givens.int2String# => implicit given class int2String extends Conversion[Int, String] { self: int2String => +2 decls }
a/b/Givens.int2String#`<init>`(). => primary ctor <init> (): int2String
a/b/Givens.int2String#apply(). => method apply (param x: Int): String <: scala/Conversion#apply()., scala/Function1#apply().
a/b/Givens.int2String#apply().(x) => param x: Int
a/b/Givens.int2String(). => final implicit given inline macro int2String => int2String
a/b/Givens.sayGoodbye(). => method sayGoodbye [typeparam B ](param any: B): String
a/b/Givens.sayGoodbye().(any) => param any: B
a/b/Givens.sayGoodbye().[B] => typeparam B 
a/b/Givens.sayHello(). => method sayHello [typeparam A ](param any: A): String
a/b/Givens.sayHello().(any) => param any: A
a/b/Givens.sayHello().[A] => typeparam A 
a/b/Givens.saySoLong(). => method saySoLong [typeparam B ](param any: B): String
a/b/Givens.saySoLong().(any) => param any: B
a/b/Givens.saySoLong().[B] => typeparam B 
a/b/Givens.soLong1. => val method soLong1 String

Occurrences:
[0:8..0:9): a <- a/
[1:8..1:9): b <- a/b/
[3:7..3:13): Givens <- a/b/Givens.
[5:13..5:14): A <- a/b/Givens.sayHello().[A]
[5:16..5:19): any <- a/b/Givens.sayHello().(any)
[5:21..5:22): A -> a/b/Givens.sayHello().[A]
[6:8..6:16): sayHello <- a/b/Givens.sayHello().
[6:34..6:37): any -> a/b/Givens.sayHello().(any)
[6:37..6:38): " -> scala/StringContext#s().
[8:13..8:14): B <- a/b/Givens.sayGoodbye().[B]
[8:13..8:14): B <- a/b/Givens.saySoLong().[B]
[8:16..8:19): any <- a/b/Givens.sayGoodbye().(any)
[8:16..8:19): any <- a/b/Givens.saySoLong().(any)
[8:21..8:22): B -> a/b/Givens.sayGoodbye().[B]
[8:21..8:22): B -> a/b/Givens.saySoLong().[B]
[9:8..9:18): sayGoodbye <- a/b/Givens.sayGoodbye().
[9:38..9:41): any -> a/b/Givens.sayGoodbye().(any)
[9:41..9:42): " -> scala/StringContext#s().
[10:8..10:17): saySoLong <- a/b/Givens.saySoLong().
[10:37..10:40): any -> a/b/Givens.saySoLong().(any)
[10:40..10:41): " -> scala/StringContext#s().
[12:6..12:12): hello1 <- a/b/Givens.hello1.
[12:17..12:25): sayHello -> a/b/Givens.sayHello().
[13:6..13:14): goodbye1 <- a/b/Givens.goodbye1.
[13:19..13:29): sayGoodbye -> a/b/Givens.sayGoodbye().
[14:6..14:13): soLong1 <- a/b/Givens.soLong1.
[14:18..14:27): saySoLong -> a/b/Givens.saySoLong().
[16:8..16:14): Monoid <- a/b/Givens.Monoid#
[16:14..16:14): <- a/b/Givens.Monoid#`<init>`().
[16:15..16:16): A <- a/b/Givens.Monoid#[A]
[17:8..17:13): empty <- a/b/Givens.Monoid#empty().
[17:15..17:16): A -> a/b/Givens.Monoid#[A]
[18:15..18:16): x <- a/b/Givens.Monoid#combine().(x)
[18:18..18:19): A -> a/b/Givens.Monoid#[A]
[18:25..18:32): combine <- a/b/Givens.Monoid#combine().
[18:33..18:34): y <- a/b/Givens.Monoid#combine().(y)
[18:36..18:37): A -> a/b/Givens.Monoid#[A]
[18:40..18:41): A -> a/b/Givens.Monoid#[A]
[20:8..20:14): Monoid -> a/b/Givens.Monoid#
[20:15..20:21): String -> scala/Predef.String#
[21:8..21:13): empty <- a/b/Givens.given_Monoid_String.empty().
[22:15..22:16): x <- a/b/Givens.given_Monoid_String.combine().(x)
[22:18..22:24): String -> scala/Predef.String#
[22:30..22:37): combine <- a/b/Givens.given_Monoid_String.combine().
[22:38..22:39): y <- a/b/Givens.given_Monoid_String.combine().(y)
[22:41..22:47): String -> scala/Predef.String#
[22:51..22:52): x -> a/b/Givens.given_Monoid_String.combine().(x)
[22:53..22:54): + -> java/lang/String#`+`().
[22:55..22:56): y -> a/b/Givens.given_Monoid_String.combine().(y)
[24:15..24:25): int2String <- a/b/Givens.int2String().
[24:27..24:37): Conversion -> scala/Conversion#
[24:27..24:27): <- a/b/Givens.int2String#`<init>`().
[24:38..24:41): Int -> scala/Int#
[24:43..24:49): String -> scala/Predef.String#
[25:8..25:13): apply <- a/b/Givens.int2String#apply().
[25:14..25:15): x <- a/b/Givens.int2String#apply().(x)
[25:17..25:20): Int -> scala/Int#
[25:23..25:29): String -> scala/Predef.String#
[25:32..25:33): x -> a/b/Givens.int2String#apply().(x)
[25:34..25:42): toString -> scala/Any#toString().
[27:6..27:9): foo <- a/b/Givens.foo().
[27:10..27:11): A <- a/b/Givens.foo().[A]
[27:19..27:20): A <- a/b/Givens.foo().(A)
[27:22..27:28): Monoid -> a/b/Givens.Monoid#
[27:29..27:30): A -> a/b/Givens.foo().[A]
[27:34..27:35): A -> a/b/Givens.foo().[A]
[27:38..27:39): A -> a/b/Givens.foo().(A)
[27:40..27:47): combine -> a/b/Givens.Monoid#combine().
[27:48..27:49): A -> a/b/Givens.foo().(A)
[27:50..27:55): empty -> a/b/Givens.Monoid#empty().
[27:57..27:58): A -> a/b/Givens.foo().(A)
[27:59..27:64): empty -> a/b/Givens.Monoid#empty().

Synthetics:
[12:17..12:25):sayHello => *[Int]
[13:19..13:29):sayGoodbye => *[Int]
[14:18..14:27):saySoLong => *[Int]

expect/ImplicitConversion.scala
-------------------------------

Summary:
Schema => SemanticDB v4
Uri => ImplicitConversion.scala
Text => empty
Language => Scala
Symbols => 23 entries
Occurrences => 52 entries
Synthetics => 6 entries

Symbols:
example/ImplicitConversion# => class ImplicitConversion extends Object { self: ImplicitConversion => +9 decls }
example/ImplicitConversion#`<init>`(). => primary ctor <init> (): ImplicitConversion
example/ImplicitConversion#a. => val method a Int
example/ImplicitConversion#b. => val method b Long
example/ImplicitConversion#char. => val method char Char
example/ImplicitConversion#message. => val method message String
example/ImplicitConversion#number. => val method number Int
example/ImplicitConversion#string2Number(). => implicit method string2Number (param string: String): Int
example/ImplicitConversion#string2Number().(string) => param string: String
example/ImplicitConversion#tuple. => val method tuple Tuple2[Int, Int]
example/ImplicitConversion#x. => val method x Int
example/ImplicitConversion. => final object ImplicitConversion extends Object { self: ImplicitConversion.type => +6 decls }
example/ImplicitConversion.newAny2stringadd# => final implicit class newAny2stringadd [typeparam A ] extends AnyVal { self: newAny2stringadd[A] => +4 decls }
example/ImplicitConversion.newAny2stringadd#[A] => typeparam A 
example/ImplicitConversion.newAny2stringadd#`+`(). => method + (param other: String): String
example/ImplicitConversion.newAny2stringadd#`+`().(other) => param other: String
example/ImplicitConversion.newAny2stringadd#`<init>`(). => primary ctor <init> [typeparam A ](param self: A): newAny2stringadd[A]
example/ImplicitConversion.newAny2stringadd#`<init>`().(self) => param self: A
example/ImplicitConversion.newAny2stringadd#self. => private val method self A
example/ImplicitConversion.newAny2stringadd(). => final implicit method newAny2stringadd [typeparam A ](param self: A): newAny2stringadd[A]
example/ImplicitConversion.newAny2stringadd().(self) => param self: A
example/ImplicitConversion.newAny2stringadd().[A] => typeparam A 
example/ImplicitConversion.newAny2stringadd. => final object newAny2stringadd extends Object { self: newAny2stringadd.type => +2 decls }

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:12): scala -> scala/
[2:13..2:21): language -> scala/language.
[2:22..2:41): implicitConversions -> scala/language.implicitConversions.
[4:6..4:24): ImplicitConversion <- example/ImplicitConversion#
[5:2..5:2): <- example/ImplicitConversion#`<init>`().
[5:9..5:27): ImplicitConversion -> example/ImplicitConversion.
[6:15..6:28): string2Number <- example/ImplicitConversion#string2Number().
[7:6..7:12): string <- example/ImplicitConversion#string2Number().(string)
[7:14..7:20): String -> scala/Predef.String#
[8:5..8:8): Int -> scala/Int#
[9:6..9:13): message <- example/ImplicitConversion#message.
[10:6..10:12): number <- example/ImplicitConversion#number.
[11:6..11:11): tuple <- example/ImplicitConversion#tuple.
[12:6..12:10): char <- example/ImplicitConversion#char.
[12:12..12:16): Char -> scala/Char#
[15:2..15:9): message -> example/ImplicitConversion#message.
[16:5..16:16): stripSuffix -> scala/collection/StringOps#stripSuffix().
[17:2..17:7): tuple -> example/ImplicitConversion#tuple.
[17:8..17:9): + -> example/ImplicitConversion.newAny2stringadd#`+`().
[20:6..20:7): x <- example/ImplicitConversion#x.
[20:9..20:12): Int -> scala/Int#
[20:15..20:22): message -> example/ImplicitConversion#message.
[23:11..23:18): message -> example/ImplicitConversion#message.
[23:20..23:26): number -> example/ImplicitConversion#number.
[23:26..23:27): " -> scala/StringContext#s().
[25:7..25:14): message -> example/ImplicitConversion#message.
[26:7..26:13): number -> example/ImplicitConversion#number.
[26:15..26:16): " -> scala/StringContext#s().
[26:17..26:28): stripMargin -> scala/collection/StringOps#stripMargin(+1).
[28:6..28:7): a <- example/ImplicitConversion#a.
[28:9..28:12): Int -> scala/Int#
[28:15..28:19): char -> example/ImplicitConversion#char.
[29:6..29:7): b <- example/ImplicitConversion#b.
[29:9..29:13): Long -> scala/Long#
[29:16..29:20): char -> example/ImplicitConversion#char.
[32:7..32:25): ImplicitConversion <- example/ImplicitConversion.
[33:23..33:39): newAny2stringadd <- example/ImplicitConversion.newAny2stringadd#
[33:39..33:39): <- example/ImplicitConversion.newAny2stringadd#`<init>`().
[33:40..33:41): A <- example/ImplicitConversion.newAny2stringadd#[A]
[33:55..33:59): self <- example/ImplicitConversion.newAny2stringadd#self.
[33:61..33:62): A -> example/ImplicitConversion.newAny2stringadd#[A]
[33:72..33:78): AnyVal -> scala/AnyVal#
[34:8..34:9): + <- example/ImplicitConversion.newAny2stringadd#`+`().
[34:10..34:15): other <- example/ImplicitConversion.newAny2stringadd#`+`().(other)
[34:17..34:23): String -> scala/Predef.String#
[34:26..34:32): String -> scala/Predef.String#
[34:35..34:41): String -> java/lang/String#
[34:42..34:49): valueOf -> java/lang/String#valueOf().
[34:50..34:54): self -> example/ImplicitConversion.newAny2stringadd#self.
[34:56..34:57): + -> java/lang/String#`+`().
[34:58..34:63): other -> example/ImplicitConversion.newAny2stringadd#`+`().(other)

Synthetics:
[15:2..15:9):message => augmentString(*)
[17:2..17:7):tuple => newAny2stringadd[Tuple2[Int, Int]](*)
[20:15..20:22):message => string2Number(*)
[24:2..26:16):s"""Hello
     |$message
     |$number""" => augmentString(*)
[28:15..28:19):char => char2int(*)
[29:16..29:20):char => char2long(*)

expect/Imports.scala
--------------------

Summary:
Schema => SemanticDB v4
Uri => Imports.scala
Text => empty
Language => Scala
Symbols => 2 entries
Occurrences => 16 entries

Symbols:
_empty_/Imports$package. => final package object _empty_ extends Object { self: _empty_.type => +2 decls }
_empty_/Imports$package.m. => val method m HashMap[Int, Int]

Occurrences:
[0:7..0:12): scala -> scala/
[0:13..0:17): util -> scala/util/
[0:18..0:25): control -> scala/util/control/
[0:26..0:34): NonFatal -> scala/util/control/NonFatal.
[1:7..1:12): scala -> scala/
[1:13..1:23): collection -> scala/collection/
[1:24..1:33): immutable -> scala/collection/immutable/
[1:35..1:42): HashMap -> scala/collection/immutable/HashMap.
[1:35..1:42): HashMap -> scala/collection/immutable/HashMap#
[3:4..3:5): m <- _empty_/Imports$package.m.
[3:7..3:9): HM -> scala/collection/immutable/HashMap#
[3:10..3:13): Int -> scala/Int#
[3:15..3:18): Int -> scala/Int#
[3:22..3:24): HM -> scala/collection/immutable/HashMap.
[3:25..3:28): Int -> scala/Int#
[3:30..3:33): Int -> scala/Int#

expect/InstrumentTyper.scala
----------------------------

Summary:
Schema => SemanticDB v4
Uri => InstrumentTyper.scala
Text => empty
Language => Scala
Symbols => 8 entries
Occurrences => 53 entries
Synthetics => 2 entries

Symbols:
example/InstrumentTyper# => class InstrumentTyper extends Object { self: AnyRef & InstrumentTyper => +5 decls }
example/InstrumentTyper#AnnotatedType# => type AnnotatedType  = Int @param
example/InstrumentTyper#`<init>`(). => primary ctor <init> (): InstrumentTyper
example/InstrumentTyper#all(). => method all => List[Float | Double | List[Nothing] | Boolean | Unit | Char | String | LinkOption | Int | Long | Class[Option[Int]]]
example/InstrumentTyper#clazzOf. => final val method clazzOf Option[Int]
example/InstrumentTyper#singletonType(). => method singletonType (param x: Predef.type): Nothing
example/InstrumentTyper#singletonType().(x) => param x: Predef.type
local0 => selfparam self: AnyRef

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:12): scala -> scala/
[2:13..2:23): annotation -> scala/annotation/
[2:24..2:28): meta -> scala/annotation/meta/
[2:29..2:34): param -> scala/annotation/meta/param#
[3:7..3:12): scala -> scala/
[3:13..3:21): language -> scala/language.
[3:22..3:34): existentials -> scala/language.existentials.
[4:7..4:12): scala -> scala/
[4:13..4:21): language -> scala/language.
[4:22..4:33): higherKinds -> scala/language.higherKinds.
[5:7..5:12): types -> types/
[5:13..5:17): Test -> types/Test.
[7:6..7:21): InstrumentTyper <- example/InstrumentTyper#
[7:24..7:28): self <- local0
[7:24..7:24): <- example/InstrumentTyper#`<init>`().
[7:30..7:36): AnyRef -> scala/AnyRef#
[8:6..8:9): all <- example/InstrumentTyper#all().
[8:12..8:16): List -> scala/package.List.
[9:4..9:11): Literal -> types/Test.Literal.
[9:12..9:15): int -> types/Test.Literal.int.
[10:4..10:11): Literal -> types/Test.Literal.
[10:12..10:16): long -> types/Test.Literal.long.
[11:4..11:11): Literal -> types/Test.Literal.
[11:12..11:17): float -> types/Test.Literal.float.
[12:4..12:11): Literal -> types/Test.Literal.
[12:12..12:18): double -> types/Test.Literal.double.
[13:4..13:11): Literal -> types/Test.Literal.
[13:12..13:15): nil -> types/Test.Literal.nil.
[14:4..14:11): Literal -> types/Test.Literal.
[14:12..14:16): char -> types/Test.Literal.char.
[15:4..15:11): Literal -> types/Test.Literal.
[15:12..15:18): string -> types/Test.Literal.string.
[16:4..16:11): Literal -> types/Test.Literal.
[16:12..16:16): bool -> types/Test.Literal.bool.
[17:4..17:11): Literal -> types/Test.Literal.
[17:12..17:16): unit -> types/Test.Literal.unit.
[18:4..18:11): Literal -> types/Test.Literal.
[18:12..18:20): javaEnum -> types/Test.Literal.javaEnum.
[19:4..19:11): Literal -> types/Test.Literal.
[19:12..19:19): clazzOf -> types/Test.Literal.clazzOf.
[20:4..20:8): List -> scala/package.List.
[22:7..22:20): AnnotatedType <- example/InstrumentTyper#AnnotatedType#
[22:23..22:26): Int -> scala/Int#
[22:28..22:33): param -> scala/annotation/meta/param#
[23:6..23:19): singletonType <- example/InstrumentTyper#singletonType().
[23:20..23:21): x <- example/InstrumentTyper#singletonType().(x)
[23:23..23:29): Predef -> scala/Predef.
[23:38..23:41): ??? -> scala/Predef.`???`().
[24:12..24:19): clazzOf <- example/InstrumentTyper#clazzOf.
[24:22..24:29): classOf -> scala/Predef.classOf().
[24:30..24:36): Option -> scala/Option#
[24:37..24:40): Int -> scala/Int#

Synthetics:
[8:12..8:16):List => *.apply[Float | Double | List[Nothing] | Boolean | Unit | Char | String | LinkOption | Int | Long | Class[Option[Int]]]
[20:4..20:8):List => *.apply[Nothing]

expect/InventedNames.scala
--------------------------

Summary:
Schema => SemanticDB v4
Uri => InventedNames.scala
Text => empty
Language => Scala
Symbols => 45 entries
Occurrences => 66 entries
Synthetics => 3 entries

Symbols:
givens/InventedNames$package. => final package object givens extends Object { self: givens.type => +24 decls }
givens/InventedNames$package.`* *`. => final implicit lazy val given method * * Long
givens/InventedNames$package.a. => val method a Int
givens/InventedNames$package.b. => val method b String
givens/InventedNames$package.c. => val method c Double
givens/InventedNames$package.d. => val method d List[Int]
givens/InventedNames$package.e. => val method e Char
givens/InventedNames$package.f. => val method f Float
givens/InventedNames$package.g. => val method g Long
givens/InventedNames$package.given_Char. => final implicit lazy val given method given_Char Char
givens/InventedNames$package.given_Double(). => final implicit given method given_Double (implicit given param x$1: Int): Double
givens/InventedNames$package.given_Double().(x$1) => implicit given param x$1: Int
givens/InventedNames$package.given_Float. => final implicit lazy val given method given_Float Float
givens/InventedNames$package.given_List_T(). => final implicit given method given_List_T [typeparam T ]: List[T]
givens/InventedNames$package.given_List_T().[T] => typeparam T 
givens/InventedNames$package.given_String. => final implicit lazy val given method given_String String
givens/InventedNames$package.given_X. => final implicit given object given_X extends Object with X { self: given_X.type => +2 decls }
givens/InventedNames$package.given_X.doX(). => method doX => Int <: givens/X#doX().
givens/InventedNames$package.given_Y# => implicit given class given_Y extends Object with Y { self: given_Y => +3 decls }
givens/InventedNames$package.given_Y#`<init>`(). => primary ctor <init> (implicit val given param x$1: X)(): given_Y
givens/InventedNames$package.given_Y#`<init>`().(x$1) => implicit val given param x$1: X
givens/InventedNames$package.given_Y#doY(). => method doY => String <: givens/Y#doY().
givens/InventedNames$package.given_Y#x$1. => protected implicit val given method x$1 X
givens/InventedNames$package.given_Y(). => final implicit given method given_Y (implicit given param x$1: X): given_Y
givens/InventedNames$package.given_Y().(x$1) => implicit given param x$1: X
givens/InventedNames$package.given_Z_T# => implicit given class given_Z_T [typeparam T ] extends Object with Z[T] { self: given_Z_T[T] => +3 decls }
givens/InventedNames$package.given_Z_T#[T] => typeparam T 
givens/InventedNames$package.given_Z_T#`<init>`(). => primary ctor <init> [typeparam T ](): given_Z_T[T]
givens/InventedNames$package.given_Z_T#doZ(). => method doZ => List[T] <: givens/Z#doZ().
givens/InventedNames$package.given_Z_T(). => final implicit given method given_Z_T [typeparam T ]: given_Z_T[T]
givens/InventedNames$package.given_Z_T().[T] => typeparam T 
givens/InventedNames$package.intValue. => final implicit lazy val given method intValue Int
givens/InventedNames$package.x. => val method x given_X.type
givens/InventedNames$package.y. => val method y given_Y
givens/InventedNames$package.z. => val method z given_Z_T[String]
givens/X# => trait X extends Object { self: X => +2 decls }
givens/X#`<init>`(). => primary ctor <init> (): X
givens/X#doX(). => abstract method doX => Int
givens/Y# => trait Y extends Object { self: Y => +2 decls }
givens/Y#`<init>`(). => primary ctor <init> (): Y
givens/Y#doY(). => abstract method doY => String
givens/Z# => trait Z [typeparam T ] extends Object { self: Z[T] => +3 decls }
givens/Z#[T] => typeparam T 
givens/Z#`<init>`(). => primary ctor <init> [typeparam T ](): Z[T]
givens/Z#doZ(). => abstract method doZ => List[T]

Occurrences:
[0:8..0:14): givens <- givens/
[2:6..2:7): X <- givens/X#
[3:2..3:2): <- givens/X#`<init>`().
[3:6..3:9): doX <- givens/X#doX().
[3:11..3:14): Int -> scala/Int#
[5:6..5:7): Y <- givens/Y#
[6:2..6:2): <- givens/Y#`<init>`().
[6:6..6:9): doY <- givens/Y#doY().
[6:11..6:17): String -> scala/Predef.String#
[8:6..8:7): Z <- givens/Z#
[8:7..8:7): <- givens/Z#`<init>`().
[8:8..8:9): T <- givens/Z#[T]
[9:6..9:9): doZ <- givens/Z#doZ().
[9:11..9:15): List -> scala/package.List#
[9:16..9:17): T -> givens/Z#[T]
[13:6..13:14): intValue <- givens/InventedNames$package.intValue.
[13:16..13:19): Int -> scala/Int#
[14:6..14:12): String -> scala/Predef.String#
[15:13..15:16): Int -> scala/Int#
[15:19..15:25): Double -> scala/Double#
[16:7..16:8): T <- givens/InventedNames$package.given_List_T().[T]
[16:11..16:15): List -> scala/package.List#
[16:16..16:17): T -> givens/InventedNames$package.given_List_T().[T]
[16:21..16:24): Nil -> scala/package.Nil.
[17:6..17:16): given_Char <- givens/InventedNames$package.given_Char.
[17:18..17:22): Char -> scala/Char#
[18:7..18:18): given_Float <- givens/InventedNames$package.given_Float.
[18:21..18:26): Float -> scala/Float#
[19:7..19:10): * * <- givens/InventedNames$package.`* *`.
[19:13..19:17): Long -> scala/Long#
[21:6..21:7): X -> givens/X#
[22:6..22:9): doX <- givens/InventedNames$package.given_X.doX().
[24:13..24:14): X -> givens/X#
[24:13..24:13): <- givens/InventedNames$package.given_Y#`<init>`().
[24:17..24:18): Y -> givens/Y#
[25:6..25:9): doY <- givens/InventedNames$package.given_Y#doY().
[27:7..27:8): T <- givens/InventedNames$package.given_Z_T#[T]
[27:7..27:7): <- givens/InventedNames$package.given_Z_T#`<init>`().
[27:11..27:12): Z -> givens/Z#
[27:13..27:14): T -> givens/InventedNames$package.given_Z_T#[T]
[28:6..28:9): doZ <- givens/InventedNames$package.given_Z_T#doZ().
[28:11..28:15): List -> scala/package.List#
[28:16..28:17): T -> givens/InventedNames$package.given_Z_T#[T]
[28:21..28:24): Nil -> scala/package.Nil.
[32:4..32:5): a <- givens/InventedNames$package.a.
[32:8..32:16): intValue -> givens/InventedNames$package.intValue.
[33:4..33:5): b <- givens/InventedNames$package.b.
[33:8..33:20): given_String -> givens/InventedNames$package.given_String.
[34:4..34:5): c <- givens/InventedNames$package.c.
[34:8..34:20): given_Double -> givens/InventedNames$package.given_Double().
[35:4..35:5): d <- givens/InventedNames$package.d.
[35:8..35:20): given_List_T -> givens/InventedNames$package.given_List_T().
[35:21..35:24): Int -> scala/Int#
[36:4..36:5): e <- givens/InventedNames$package.e.
[36:8..36:18): given_Char -> givens/InventedNames$package.given_Char.
[37:4..37:5): f <- givens/InventedNames$package.f.
[37:8..37:19): given_Float -> givens/InventedNames$package.given_Float.
[38:4..38:5): g <- givens/InventedNames$package.g.
[38:8..38:13): `* *` -> givens/InventedNames$package.`* *`.
[39:4..39:5): x <- givens/InventedNames$package.x.
[39:8..39:15): given_X -> givens/InventedNames$package.given_X.
[40:4..40:5): y <- givens/InventedNames$package.y.
[40:8..40:15): given_Y -> givens/InventedNames$package.given_Y().
[41:4..41:5): z <- givens/InventedNames$package.z.
[41:8..41:17): given_Z_T -> givens/InventedNames$package.given_Z_T().
[41:18..41:24): String -> scala/Predef.String#

Synthetics:
[24:0..24:0): => *(x$1)
[34:8..34:20):given_Double => *(intValue)
[40:8..40:15):given_Y => *(given_X)

expect/Issue1749.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => Issue1749.scala
Text => empty
Language => Scala
Symbols => 7 entries
Occurrences => 24 entries
Synthetics => 3 entries

Symbols:
example/Issue1749# => class Issue1749 extends Object { self: Issue1749 => +3 decls }
example/Issue1749#`<init>`(). => primary ctor <init> (): Issue1749
example/Issue1749#x1. => val method x1 Int
example/Issue1749#x2. => val method x2 Int
example/Issue1854# => class Issue1854 extends Object { self: Issue1854 => +2 decls }
example/Issue1854#`<init>`(). => primary ctor <init> (): Issue1854
example/Issue1854#map. => val method map Map[String, String]

Occurrences:
[1:8..1:15): example <- example/
[3:7..3:12): scala -> scala/
[3:13..3:17): math -> scala/math/
[3:18..3:25): Ordered -> scala/math/Ordered.
[3:26..3:43): orderingToOrdered -> scala/math/Ordered.orderingToOrdered().
[5:6..5:15): Issue1749 <- example/Issue1749#
[6:2..6:2): <- example/Issue1749#`<init>`().
[6:6..6:8): x1 <- example/Issue1749#x1.
[7:6..7:8): x2 <- example/Issue1749#x2.
[8:3..8:5): x1 -> example/Issue1749#x1.
[8:7..8:9): x1 -> example/Issue1749#x1.
[9:5..9:12): compare -> scala/math/Ordered#compare().
[9:14..9:16): x2 -> example/Issue1749#x2.
[9:18..9:20): x2 -> example/Issue1749#x2.
[12:6..12:15): Issue1854 <- example/Issue1854#
[13:2..13:2): <- example/Issue1854#`<init>`().
[13:6..13:9): map <- example/Issue1854#map.
[13:12..13:22): collection -> scala/collection/
[13:23..13:30): mutable -> scala/collection/mutable/
[13:31..13:34): Map -> scala/collection/mutable/Map.
[13:35..13:40): empty -> scala/collection/MapFactory.Delegate#empty().
[13:41..13:47): String -> scala/Predef.String#
[13:49..13:55): String -> scala/Predef.String#
[14:2..14:5): map -> example/Issue1854#map.

Synthetics:
[8:2..8:10):(x1, x1) => orderingToOrdered[Tuple2[Int, Int]](*)
[8:2..8:10):(x1, x1) => *(Tuple2(Int, Int))
[8:10..8:10): => *(Int, Int)

expect/Local.scala
------------------

Summary:
Schema => SemanticDB v4
Uri => Local.scala
Text => empty
Language => Scala
Symbols => 6 entries
Occurrences => 11 entries
Synthetics => 1 entries

Symbols:
example/Local# => class Local extends Object { self: Local => +2 decls }
example/Local#`<init>`(). => primary ctor <init> (): Local
example/Local#a(). => method a (): Int
local0 => typeparam A 
local1 => param a: A
local2 => local id: [typeparam A ](param a: A): A

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:11): Local <- example/Local#
[3:2..3:2): <- example/Local#`<init>`().
[3:6..3:7): a <- example/Local#a().
[4:8..4:10): id <- local2
[4:11..4:12): A <- local0
[4:14..4:15): a <- local1
[4:17..4:18): A -> local0
[4:21..4:22): A -> local0
[4:25..4:26): a -> local1
[5:4..5:6): id -> local2

Synthetics:
[5:4..5:6):id => *[Int]

expect/Locals.scala
-------------------

Summary:
Schema => SemanticDB v4
Uri => Locals.scala
Text => empty
Language => Scala
Symbols => 3 entries
Occurrences => 6 entries
Synthetics => 1 entries

Symbols:
local0 => val local x: Int
locals/Test. => final object Test extends Object { self: Test.type => +2 decls }
locals/Test.xs. => val method xs List[Int]

Occurrences:
[0:8..0:14): locals <- locals/
[2:7..2:11): Test <- locals/Test.
[3:6..3:8): xs <- locals/Test.xs.
[4:8..4:9): x <- local0
[5:4..5:8): List -> scala/package.List.
[5:9..5:10): x -> local0

Synthetics:
[5:4..5:8):List => *.apply[Int]

expect/MatchType.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => MatchType.scala
Text => empty
Language => Scala
Symbols => 10 entries
Occurrences => 29 entries

Symbols:
example/MatchType$package. => final package object example extends Object { self: example.type => +3 decls }
example/MatchType$package.Concat# => type Concat [typeparam Xs  <: Tuple, covariant typeparam Ys  <: Tuple] = Xs match { EmptyTuple => Ys, *:[x, xs] => *:[x, Concat[xs, Ys]] }
example/MatchType$package.Concat#[Xs] => typeparam Xs  <: Tuple
example/MatchType$package.Concat#[Ys] => covariant typeparam Ys  <: Tuple
example/MatchType$package.Elem# => type Elem [typeparam X ] = X match { String => Char, Array[t] => t, Iterable[t] => t }
example/MatchType$package.Elem#[X] => typeparam X 
local0 => type t 
local1 => type t 
local2 => type x 
local3 => type xs  <: Tuple

Occurrences:
[0:8..0:15): example <- example/
[2:5..2:9): Elem <- example/MatchType$package.Elem#
[2:10..2:11): X <- example/MatchType$package.Elem#[X]
[2:15..2:16): X -> example/MatchType$package.Elem#[X]
[3:7..3:13): String -> scala/Predef.String#
[3:17..3:21): Char -> scala/Char#
[4:7..4:12): Array -> scala/Array#
[4:13..4:14): t <- local0
[4:19..4:20): t -> local0
[5:7..5:15): Iterable -> scala/package.Iterable#
[5:16..5:17): t <- local1
[5:22..5:23): t -> local1
[7:5..7:11): Concat <- example/MatchType$package.Concat#
[7:12..7:14): Xs <- example/MatchType$package.Concat#[Xs]
[7:18..7:23): Tuple -> scala/Tuple#
[7:26..7:28): Ys <- example/MatchType$package.Concat#[Ys]
[7:32..7:37): Tuple -> scala/Tuple#
[7:42..7:47): Tuple -> scala/Tuple#
[7:50..7:52): Xs -> example/MatchType$package.Concat#[Xs]
[8:7..8:17): EmptyTuple -> scala/Tuple$package.EmptyTuple#
[8:21..8:23): Ys -> example/MatchType$package.Concat#[Ys]
[9:7..9:8): x <- local2
[9:9..9:11): *: -> scala/`*:`#
[9:12..9:14): xs <- local3
[9:18..9:19): x -> local2
[9:20..9:22): *: -> scala/`*:`#
[9:23..9:29): Concat -> example/MatchType$package.Concat#
[9:30..9:32): xs -> local3
[9:34..9:36): Ys -> example/MatchType$package.Concat#[Ys]

expect/MetacJava.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => MetacJava.scala
Text => empty
Language => Scala
Symbols => 10 entries
Occurrences => 63 entries

Symbols:
example/MetacJava# => class MetacJava extends Object { self: MetacJava => +9 decls }
example/MetacJava#`<init>`(). => primary ctor <init> (): MetacJava
example/MetacJava#coin. => val method coin Coin
example/MetacJava#entry. => val method entry Entry[Int, Int]
example/MetacJava#inner. => val method inner MetacJava
example/MetacJava#interface. => val method interface Interface
example/MetacJava#nonStatic. => val method nonStatic staticInner.NonStatic
example/MetacJava#overload1. => val method overload1 inner.Overload1
example/MetacJava#overload2. => val method overload2 inner.Overload2
example/MetacJava#staticInner. => val method staticInner StaticInner

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:10): com -> com/
[2:11..2:17): javacp -> com/javacp/
[4:6..4:15): MetacJava <- example/MetacJava#
[5:2..5:8): javacp -> com/javacp/
[5:2..5:2): <- example/MetacJava#`<init>`().
[5:9..5:18): MetacJava -> com/javacp/MetacJava#
[5:19..5:30): StaticInner -> com/javacp/MetacJava#StaticInner#
[5:31..5:39): isStatic -> com/javacp/MetacJava#StaticInner#isStatic().
[6:6..6:12): javacp -> com/javacp/
[6:13..6:22): MetacJava -> com/javacp/MetacJava#
[6:23..6:34): StaticInner -> com/javacp/MetacJava#StaticInner#
[6:37..6:48): isNotStatic -> com/javacp/MetacJava#StaticInner#isNotStatic().
[7:6..7:11): inner <- example/MetacJava#inner.
[7:18..7:24): javacp -> com/javacp/
[7:25..7:34): MetacJava -> com/javacp/MetacJava#
[8:6..8:15): overload1 <- example/MetacJava#overload1.
[8:22..8:27): inner -> example/MetacJava#inner.
[8:28..8:37): Overload1 -> com/javacp/MetacJava#Overload1#
[9:6..9:15): overload2 <- example/MetacJava#overload2.
[9:22..9:27): inner -> example/MetacJava#inner.
[9:28..9:37): Overload2 -> com/javacp/MetacJava#Overload2#
[10:2..10:7): inner -> example/MetacJava#inner.
[10:8..10:16): overload -> com/javacp/MetacJava#overload().
[10:21..10:30): overload1 -> example/MetacJava#overload1.
[10:31..10:32): A -> com/javacp/MetacJava#Overload1#A#
[11:2..11:7): inner -> example/MetacJava#inner.
[11:8..11:16): overload -> com/javacp/MetacJava#overload(+1).
[11:21..11:30): overload2 -> example/MetacJava#overload2.
[11:31..11:32): A -> com/javacp/MetacJava#Overload2#A#
[12:6..12:17): staticInner <- example/MetacJava#staticInner.
[12:24..12:30): javacp -> com/javacp/
[12:31..12:40): MetacJava -> com/javacp/MetacJava#
[12:41..12:52): StaticInner -> com/javacp/MetacJava#StaticInner#
[13:6..13:15): nonStatic <- example/MetacJava#nonStatic.
[13:22..13:33): staticInner -> example/MetacJava#staticInner.
[13:34..13:43): NonStatic -> com/javacp/MetacJava#StaticInner#NonStatic#
[14:2..14:11): nonStatic -> example/MetacJava#nonStatic.
[14:12..14:18): method -> com/javacp/MetacJava#StaticInner#NonStatic#method().
[14:19..14:28): nonStatic -> example/MetacJava#nonStatic.
[15:2..15:8): javacp -> com/javacp/
[15:9..15:18): MetacJava -> com/javacp/MetacJava#
[15:19..15:27): overload -> com/javacp/MetacJava#overload(+2).
[15:32..15:38): javacp -> com/javacp/
[15:39..15:48): MetacJava -> com/javacp/MetacJava#
[15:49..15:58): Overload3 -> com/javacp/MetacJava#Overload3#
[15:59..15:60): A -> com/javacp/MetacJava#Overload3#A#
[16:6..16:15): interface <- example/MetacJava#interface.
[16:17..16:23): javacp -> com/javacp/
[16:24..16:33): Interface -> com/javacp/Interface#
[17:6..17:10): coin <- example/MetacJava#coin.
[17:12..17:18): javacp -> com/javacp/
[17:19..17:23): Coin -> com/javacp/Coin#
[17:26..17:32): javacp -> com/javacp/
[17:33..17:37): Coin -> com/javacp/Coin#
[17:38..17:43): PENNY -> com/javacp/Coin#PENNY.
[18:6..18:11): entry <- example/MetacJava#entry.
[18:13..18:17): java -> java/
[18:18..18:22): util -> java/util/
[18:23..18:26): Map -> java/util/Map#
[18:27..18:32): Entry -> java/util/Map#Entry#
[18:33..18:36): Int -> scala/Int#
[18:38..18:41): Int -> scala/Int#

expect/MethodUsages.scala
-------------------------

Summary:
Schema => SemanticDB v4
Uri => MethodUsages.scala
Text => empty
Language => Scala
Symbols => 3 entries
Occurrences => 81 entries
Synthetics => 2 entries

Symbols:
example/MethodUsages# => class MethodUsages extends Object { self: MethodUsages => +2 decls }
example/MethodUsages#`<init>`(). => primary ctor <init> (): MethodUsages
example/MethodUsages#m. => val method m Methods[Int]

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:18): MethodUsages <- example/MethodUsages#
[3:2..3:2): <- example/MethodUsages#`<init>`().
[3:6..3:7): m <- example/MethodUsages#m.
[3:14..3:21): Methods -> example/Methods#
[3:22..3:25): Int -> scala/Int#
[4:2..4:3): m -> example/MethodUsages#m.
[4:4..4:6): m1 -> example/Methods#m1().
[5:2..5:3): m -> example/MethodUsages#m.
[5:4..5:6): m2 -> example/Methods#m2().
[6:2..6:3): m -> example/MethodUsages#m.
[6:4..6:6): m3 -> example/Methods#m3().
[7:2..7:3): m -> example/MethodUsages#m.
[7:4..7:6): m4 -> example/Methods#m4().
[8:2..8:3): m -> example/MethodUsages#m.
[8:4..8:6): m5 -> example/Methods#m5().
[9:2..9:3): m -> example/MethodUsages#m.
[9:4..9:6): m5 -> example/Methods#m5(+1).
[10:2..10:3): m -> example/MethodUsages#m.
[10:4..10:6): m6 -> example/Methods#m6().
[11:2..11:3): m -> example/MethodUsages#m.
[11:4..11:6): m6 -> example/Methods#m6(+1).
[11:11..11:12): m -> example/MethodUsages#m.
[11:13..11:17): List -> example/Methods#List#
[11:18..11:21): Int -> scala/Int#
[12:2..12:3): m -> example/MethodUsages#m.
[12:4..12:6): m6 -> example/Methods#m6(+2).
[12:7..12:10): Nil -> scala/package.Nil.
[13:2..13:3): m -> example/MethodUsages#m.
[13:4..13:6): m7 -> example/Methods#m7().
[13:7..13:8): m -> example/MethodUsages#m.
[13:14..13:15): m -> example/MethodUsages#m.
[13:16..13:20): List -> example/Methods#List#
[13:21..13:24): Int -> scala/Int#
[14:2..14:3): m -> example/MethodUsages#m.
[14:4..14:11): `m8().` -> example/Methods#`m8().`().
[15:2..15:3): m -> example/MethodUsages#m.
[15:4..15:6): m9 -> example/Methods#m9().
[16:2..16:3): m -> example/MethodUsages#m.
[16:4..16:7): m10 -> example/Methods#m10().
[17:2..17:3): m -> example/MethodUsages#m.
[17:4..17:7): m11 -> example/Methods#m11().
[17:8..17:14): Predef -> scala/Predef.
[18:2..18:3): m -> example/MethodUsages#m.
[18:4..18:7): m11 -> example/Methods#m11(+1).
[18:8..18:15): Example -> example/Example.
[19:2..19:3): m -> example/MethodUsages#m.
[19:4..19:8): m12a -> example/Methods#m12a().
[20:2..20:3): m -> example/MethodUsages#m.
[20:4..20:8): m12b -> example/Methods#m12b().
[21:2..21:3): m -> example/MethodUsages#m.
[21:4..21:7): m13 -> example/Methods#m13().
[22:2..22:3): m -> example/MethodUsages#m.
[22:4..22:7): m15 -> example/Methods#m15().
[23:2..23:3): m -> example/MethodUsages#m.
[23:4..23:7): m16 -> example/Methods#m16().
[24:2..24:3): m -> example/MethodUsages#m.
[24:4..24:7): m16 -> example/Methods#m16().
[25:2..25:3): m -> example/MethodUsages#m.
[25:4..25:7): m17 -> example/Methods#m17.
[25:8..25:9): m -> example/Methods#m17.m().
[26:2..26:3): m -> example/MethodUsages#m.
[26:4..26:7): m17 -> example/Methods#m17().
[27:2..27:3): m -> example/MethodUsages#m.
[27:4..27:7): m17 -> example/Methods#m17(+1).
[28:2..28:3): m -> example/MethodUsages#m.
[28:4..28:7): m18 -> example/Methods#m18.
[28:8..28:9): m -> example/Methods#m17.m().
[29:2..29:3): m -> example/MethodUsages#m.
[29:4..29:7): m18 -> example/Methods#m18().
[30:2..30:3): m -> example/MethodUsages#m.
[30:4..30:7): m18 -> example/Methods#m18(+1).
[31:2..31:3): m -> example/MethodUsages#m.
[31:4..31:7): m19 -> example/Methods#m19().
[32:2..32:3): m -> example/MethodUsages#m.
[32:4..32:7): m20 -> example/Methods#m20().
[33:2..33:3): m -> example/MethodUsages#m.
[33:4..33:7): m20 -> example/Methods#m20(+1).
[34:2..34:3): m -> example/MethodUsages#m.
[34:4..34:7): m20 -> example/Methods#m20(+2).
[34:8..34:9): m -> example/Methods#m17.m().

Synthetics:
[13:2..13:6):m.m7 => *[Int]
[13:2..13:26):m.m7(m, new m.List[Int]) => *(Int)

expect/Methods.scala
--------------------

Summary:
Schema => SemanticDB v4
Uri => Methods.scala
Text => empty
Language => Scala
Symbols => 82 entries
Occurrences => 156 entries

Symbols:
example/Methods# => class Methods [typeparam T ] extends Object { self: Methods[T] => +44 decls }
example/Methods#AList# => type AList [typeparam T ] = List[T]
example/Methods#AList#[T] => typeparam T 
example/Methods#List# => class List [typeparam T ] extends Object { self: List[T] => +2 decls }
example/Methods#List#[T] => typeparam T 
example/Methods#List#`<init>`(). => primary ctor <init> [typeparam T ](): List[T]
example/Methods#[T] => typeparam T 
example/Methods#`<init>`(). => primary ctor <init> [typeparam T ](): Methods[T]
example/Methods#`m8().`(). => method m8(). (): Nothing
example/Methods#`m9().`# => class m9(). extends Object { self: m9(). => +1 decls }
example/Methods#`m9().`#`<init>`(). => primary ctor <init> (): m9().
example/Methods#`m20_=`(). => var method m20_= (param x$1: m17.type): Unit
example/Methods#`m20_=`().(x$1) => param x$1: m17.type
example/Methods#m1(). => method m1 => Nothing
example/Methods#m2(). => method m2 (): Nothing
example/Methods#m3(). => method m3 (param x: Int): Nothing
example/Methods#m3().(x) => param x: Int
example/Methods#m4(). => method m4 (param x: Int)(param y: Int): Nothing
example/Methods#m4().(x) => param x: Int
example/Methods#m4().(y) => param y: Int
example/Methods#m5(). => method m5 (param x: String): Nothing
example/Methods#m5().(x) => param x: String
example/Methods#m5(+1). => method m5 (param x: Int): Nothing
example/Methods#m5(+1).(x) => param x: Int
example/Methods#m6(). => method m6 (param x: Int): Nothing
example/Methods#m6().(x) => param x: Int
example/Methods#m6(+1). => method m6 (param x: List[T]): Nothing
example/Methods#m6(+1).(x) => param x: List[T]
example/Methods#m6(+2). => method m6 (param x: List[T]): Nothing
example/Methods#m6(+2).(x) => param x: List[T]
example/Methods#m7(). => method m7 [typeparam U ](param c: Methods[T], param l: List[U])(implicit param evidence$1: Ordering[U]): Nothing
example/Methods#m7().(c) => param c: Methods[T]
example/Methods#m7().(evidence$1) => implicit param evidence$1: Ordering[U]
example/Methods#m7().(l) => param l: List[U]
example/Methods#m7().[U] => typeparam U 
example/Methods#m9(). => method m9 (param x: m9().): Nothing
example/Methods#m9().(x) => param x: m9().
example/Methods#m10(). => method m10 (param x: List[T]): Nothing
example/Methods#m10().(x) => param x: List[T]
example/Methods#m11(). => method m11 (param x: Predef.type): Nothing
example/Methods#m11().(x) => param x: Predef.type
example/Methods#m11(+1). => method m11 (param x: Example.type): Nothing
example/Methods#m11(+1).(x) => param x: Example.type
example/Methods#m12a(). => method m12a (param x: Object): Nothing
example/Methods#m12a().(x) => param x: Object
example/Methods#m12b(). => method m12b (param x: Object { abstract val method x Int }): Nothing
example/Methods#m12b().(x) => param x: Object { abstract val method x Int }
example/Methods#m12c(). => method m12c (param x: Object { abstract method y => Int; abstract val method x Int }): Nothing
example/Methods#m12c().(x) => param x: Object { abstract method y => Int; abstract val method x Int }
example/Methods#m13(). => method m13 (param x: Int @unchecked): Nothing
example/Methods#m13().(x) => param x: Int @unchecked
example/Methods#m15(). => method m15 (param x: => Int): Nothing
example/Methods#m15().(x) => param x: => Int
example/Methods#m16(). => method m16 (param x: Int*): Nothing
example/Methods#m16().(x) => param x: Int*
example/Methods#m17(). => method m17 (param a: Int): Nothing
example/Methods#m17().(a) => param a: Int
example/Methods#m17(+1). => method m17 (param b: String): Nothing
example/Methods#m17(+1).(b) => param b: String
example/Methods#m17. => final object m17 extends Object { self: m17.type => +2 decls }
example/Methods#m17.m(). => method m (): Nothing
example/Methods#m18(). => method m18 (param a: Int): Nothing
example/Methods#m18().(a) => param a: Int
example/Methods#m18(+1). => method m18 (param b: String): Nothing
example/Methods#m18(+1).(b) => param b: String
example/Methods#m18. => val method m18 m17.type
example/Methods#m19$default$2(). => method m19$default$2 => Int @uncheckedVariance
example/Methods#m19$default$3(). => method m19$default$3 (param x: Int, param y: Int): Int @uncheckedVariance
example/Methods#m19$default$3().(x) => param x: Int
example/Methods#m19$default$3().(y) => param y: Int
example/Methods#m19(). => method m19 (param x: Int, param y: Int)(param z: Int): Nothing
example/Methods#m19().(x) => param x: Int
example/Methods#m19().(y) => param y: Int
example/Methods#m19().(z) => param z: Int
example/Methods#m20(). => method m20 (param a: Int): Nothing
example/Methods#m20().(a) => param a: Int
example/Methods#m20(+1). => method m20 (param b: String): Nothing
example/Methods#m20(+1).(b) => param b: String
example/Methods#m20(+2). => var method m20 m17.type
local0 => abstract val method x Int
local1 => abstract val method x Int
local2 => abstract method y => Int

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:12): scala -> scala/
[2:13..2:17): math -> scala/math/
[2:18..2:26): Ordering -> scala/math/Ordering.
[2:18..2:26): Ordering -> scala/math/Ordering#
[3:7..3:12): scala -> scala/
[3:13..3:21): language -> scala/language.
[3:22..3:34): existentials -> scala/language.existentials.
[5:6..5:13): Methods <- example/Methods#
[5:13..5:13): <- example/Methods#`<init>`().
[5:14..5:15): T <- example/Methods#[T]
[6:8..6:12): List <- example/Methods#List#
[6:12..6:12): <- example/Methods#List#`<init>`().
[6:13..6:14): T <- example/Methods#List#[T]
[7:7..7:12): AList <- example/Methods#AList#
[7:13..7:14): T <- example/Methods#AList#[T]
[7:18..7:22): List -> example/Methods#List#
[7:23..7:24): T -> example/Methods#AList#[T]
[8:6..8:8): m1 <- example/Methods#m1().
[8:11..8:14): ??? -> scala/Predef.`???`().
[9:6..9:8): m2 <- example/Methods#m2().
[9:13..9:16): ??? -> scala/Predef.`???`().
[10:6..10:8): m3 <- example/Methods#m3().
[10:9..10:10): x <- example/Methods#m3().(x)
[10:12..10:15): Int -> scala/Int#
[10:19..10:22): ??? -> scala/Predef.`???`().
[11:6..11:8): m4 <- example/Methods#m4().
[11:9..11:10): x <- example/Methods#m4().(x)
[11:12..11:15): Int -> scala/Int#
[11:17..11:18): y <- example/Methods#m4().(y)
[11:20..11:23): Int -> scala/Int#
[11:27..11:30): ??? -> scala/Predef.`???`().
[12:6..12:8): m5 <- example/Methods#m5().
[12:9..12:10): x <- example/Methods#m5().(x)
[12:12..12:18): String -> scala/Predef.String#
[12:22..12:25): ??? -> scala/Predef.`???`().
[13:6..13:8): m5 <- example/Methods#m5(+1).
[13:9..13:10): x <- example/Methods#m5(+1).(x)
[13:12..13:15): Int -> scala/Int#
[13:19..13:22): ??? -> scala/Predef.`???`().
[14:6..14:8): m6 <- example/Methods#m6().
[14:9..14:10): x <- example/Methods#m6().(x)
[14:12..14:15): Int -> scala/Int#
[14:19..14:22): ??? -> scala/Predef.`???`().
[15:6..15:8): m6 <- example/Methods#m6(+1).
[15:9..15:10): x <- example/Methods#m6(+1).(x)
[15:12..15:16): List -> example/Methods#List#
[15:17..15:18): T -> example/Methods#[T]
[15:23..15:26): ??? -> scala/Predef.`???`().
[16:6..16:8): m6 <- example/Methods#m6(+2).
[16:9..16:10): x <- example/Methods#m6(+2).(x)
[16:12..16:17): scala -> scala/
[16:18..16:22): List -> scala/package.List#
[16:23..16:24): T -> example/Methods#[T]
[16:29..16:32): ??? -> scala/Predef.`???`().
[17:6..17:8): m7 <- example/Methods#m7().
[17:9..17:10): U <- example/Methods#m7().[U]
[17:10..17:10): <- example/Methods#m7().(evidence$1)
[17:12..17:20): Ordering -> scala/math/Ordering#
[17:22..17:23): c <- example/Methods#m7().(c)
[17:25..17:32): Methods -> example/Methods#
[17:33..17:34): T -> example/Methods#[T]
[17:37..17:38): l <- example/Methods#m7().(l)
[17:40..17:44): List -> example/Methods#List#
[17:45..17:46): U -> example/Methods#m7().[U]
[17:51..17:54): ??? -> scala/Predef.`???`().
[18:7..18:12): m8(). <- example/Methods#`m8().`().
[18:18..18:21): ??? -> scala/Predef.`???`().
[19:2..19:2): <- example/Methods#`m9().`#`<init>`().
[19:9..19:14): m9(). <- example/Methods#`m9().`#
[20:6..20:8): m9 <- example/Methods#m9().
[20:9..20:10): x <- example/Methods#m9().(x)
[20:12..20:19): `m9().` -> example/Methods#`m9().`#
[20:23..20:26): ??? -> scala/Predef.`???`().
[21:6..21:9): m10 <- example/Methods#m10().
[21:10..21:11): x <- example/Methods#m10().(x)
[21:13..21:18): AList -> example/Methods#AList#
[21:19..21:20): T -> example/Methods#[T]
[21:25..21:28): ??? -> scala/Predef.`???`().
[22:6..22:9): m11 <- example/Methods#m11().
[22:10..22:11): x <- example/Methods#m11().(x)
[22:13..22:19): Predef -> scala/Predef.
[22:28..22:31): ??? -> scala/Predef.`???`().
[23:6..23:9): m11 <- example/Methods#m11(+1).
[23:10..23:11): x <- example/Methods#m11(+1).(x)
[23:13..23:20): Example -> example/Example.
[23:29..23:32): ??? -> scala/Predef.`???`().
[24:6..24:10): m12a <- example/Methods#m12a().
[24:11..24:12): x <- example/Methods#m12a().(x)
[24:20..24:23): ??? -> scala/Predef.`???`().
[25:6..25:10): m12b <- example/Methods#m12b().
[25:11..25:12): x <- example/Methods#m12b().(x)
[25:20..25:21): x <- local0
[25:23..25:26): Int -> scala/Int#
[25:32..25:35): ??? -> scala/Predef.`???`().
[26:6..26:10): m12c <- example/Methods#m12c().
[26:11..26:12): x <- example/Methods#m12c().(x)
[26:20..26:21): x <- local1
[26:23..26:26): Int -> scala/Int#
[26:32..26:33): y <- local2
[26:35..26:38): Int -> scala/Int#
[26:44..26:47): ??? -> scala/Predef.`???`().
[27:6..27:9): m13 <- example/Methods#m13().
[27:10..27:11): x <- example/Methods#m13().(x)
[27:13..27:16): Int -> scala/Int#
[27:18..27:27): unchecked -> scala/unchecked#
[27:31..27:34): ??? -> scala/Predef.`???`().
[28:6..28:9): m15 <- example/Methods#m15().
[28:10..28:11): x <- example/Methods#m15().(x)
[28:16..28:19): Int -> scala/Int#
[28:23..28:26): ??? -> scala/Predef.`???`().
[29:6..29:9): m16 <- example/Methods#m16().
[29:10..29:11): x <- example/Methods#m16().(x)
[29:13..29:16): Int -> scala/Int#
[29:21..29:24): ??? -> scala/Predef.`???`().
[30:9..30:12): m17 <- example/Methods#m17.
[30:19..30:20): m <- example/Methods#m17.m().
[30:25..30:28): ??? -> scala/Predef.`???`().
[31:6..31:9): m17 <- example/Methods#m17().
[31:10..31:11): a <- example/Methods#m17().(a)
[31:13..31:16): Int -> scala/Int#
[31:20..31:23): ??? -> scala/Predef.`???`().
[32:6..32:9): m17 <- example/Methods#m17(+1).
[32:10..32:11): b <- example/Methods#m17(+1).(b)
[32:13..32:19): String -> scala/Predef.String#
[32:23..32:26): ??? -> scala/Predef.`???`().
[33:6..33:9): m18 <- example/Methods#m18.
[33:12..33:15): m17 -> example/Methods#m17.
[34:6..34:9): m18 <- example/Methods#m18().
[34:10..34:11): a <- example/Methods#m18().(a)
[34:13..34:16): Int -> scala/Int#
[34:20..34:23): ??? -> scala/Predef.`???`().
[35:6..35:9): m18 <- example/Methods#m18(+1).
[35:10..35:11): b <- example/Methods#m18(+1).(b)
[35:13..35:19): String -> scala/Predef.String#
[35:23..35:26): ??? -> scala/Predef.`???`().
[36:6..36:9): m19 <- example/Methods#m19().
[36:10..36:11): x <- example/Methods#m19().(x)
[36:10..36:11): x <- example/Methods#m19$default$3().(x)
[36:13..36:16): Int -> scala/Int#
[36:18..36:19): y <- example/Methods#m19().(y)
[36:18..36:19): y <- example/Methods#m19$default$3().(y)
[36:21..36:24): Int -> scala/Int#
[36:30..36:31): z <- example/Methods#m19().(z)
[36:33..36:36): Int -> scala/Int#
[36:44..36:47): ??? -> scala/Predef.`???`().
[37:6..37:9): m20 <- example/Methods#m20().
[37:10..37:11): a <- example/Methods#m20().(a)
[37:13..37:16): Int -> scala/Int#
[37:20..37:23): ??? -> scala/Predef.`???`().
[38:6..38:9): m20 <- example/Methods#m20(+1).
[38:10..38:11): b <- example/Methods#m20(+1).(b)
[38:13..38:19): String -> scala/Predef.String#
[38:23..38:26): ??? -> scala/Predef.`???`().
[39:6..39:9): m20 <- example/Methods#m20(+2).
[39:12..39:15): m17 -> example/Methods#m17.

expect/NamedApplyBlock.scala
----------------------------

Summary:
Schema => SemanticDB v4
Uri => NamedApplyBlock.scala
Text => empty
Language => Scala
Symbols => 43 entries
Occurrences => 41 entries

Symbols:
example/NamedApplyBlockCaseClassConstruction. => final object NamedApplyBlockCaseClassConstruction extends Object { self: NamedApplyBlockCaseClassConstruction.type => +6 decls }
example/NamedApplyBlockCaseClassConstruction.Msg# => case class Msg extends Object with Product with Serializable { self: Msg => +11 decls }
example/NamedApplyBlockCaseClassConstruction.Msg#_1(). => method _1 => String
example/NamedApplyBlockCaseClassConstruction.Msg#_2(). => method _2 => String
example/NamedApplyBlockCaseClassConstruction.Msg#_3(). => method _3 => String
example/NamedApplyBlockCaseClassConstruction.Msg#`<init>`(). => primary ctor <init> (val param body: String, val param head: String, val param tail: String): Msg
example/NamedApplyBlockCaseClassConstruction.Msg#`<init>`().(body) => val param body: String
example/NamedApplyBlockCaseClassConstruction.Msg#`<init>`().(head) => val param head: String
example/NamedApplyBlockCaseClassConstruction.Msg#`<init>`().(tail) => val param tail: String
example/NamedApplyBlockCaseClassConstruction.Msg#body. => val method body String
example/NamedApplyBlockCaseClassConstruction.Msg#copy$default$1(). => method copy$default$1 => String @uncheckedVariance
example/NamedApplyBlockCaseClassConstruction.Msg#copy$default$2(). => method copy$default$2 => String @uncheckedVariance
example/NamedApplyBlockCaseClassConstruction.Msg#copy$default$3(). => method copy$default$3 => String @uncheckedVariance
example/NamedApplyBlockCaseClassConstruction.Msg#copy(). => method copy (param body: String, param head: String, param tail: String): Msg
example/NamedApplyBlockCaseClassConstruction.Msg#copy().(body) => param body: String
example/NamedApplyBlockCaseClassConstruction.Msg#copy().(head) => param head: String
example/NamedApplyBlockCaseClassConstruction.Msg#copy().(tail) => param tail: String
example/NamedApplyBlockCaseClassConstruction.Msg#head. => val method head String
example/NamedApplyBlockCaseClassConstruction.Msg#tail. => val method tail String
example/NamedApplyBlockCaseClassConstruction.Msg. => final object Msg extends Object { self: Msg.type => +5 decls }
example/NamedApplyBlockCaseClassConstruction.Msg.$lessinit$greater$default$2(). => method $lessinit$greater$default$2 => String @uncheckedVariance
example/NamedApplyBlockCaseClassConstruction.Msg.apply(). => method apply (param body: String, param head: String, param tail: String): Msg
example/NamedApplyBlockCaseClassConstruction.Msg.apply().(body) => param body: String
example/NamedApplyBlockCaseClassConstruction.Msg.apply().(head) => param head: String
example/NamedApplyBlockCaseClassConstruction.Msg.apply().(tail) => param tail: String
example/NamedApplyBlockCaseClassConstruction.Msg.toString(). => method toString => String <: scala/Any#toString().
example/NamedApplyBlockCaseClassConstruction.Msg.unapply(). => method unapply (param x$1: Msg): Msg
example/NamedApplyBlockCaseClassConstruction.Msg.unapply().(x$1) => param x$1: Msg
example/NamedApplyBlockCaseClassConstruction.bodyText. => val method bodyText String
example/NamedApplyBlockCaseClassConstruction.msg. => val method msg Msg
example/NamedApplyBlockMethods. => final object NamedApplyBlockMethods extends Object { self: NamedApplyBlockMethods.type => +8 decls }
example/NamedApplyBlockMethods.baseCase(). => method baseCase => Int
example/NamedApplyBlockMethods.foo$default$1(). => method foo$default$1 => Int @uncheckedVariance
example/NamedApplyBlockMethods.foo$default$2(). => method foo$default$2 => Int @uncheckedVariance
example/NamedApplyBlockMethods.foo$default$3(). => method foo$default$3 => Int @uncheckedVariance
example/NamedApplyBlockMethods.foo(). => method foo (param a: Int, param b: Int, param c: Int): Int
example/NamedApplyBlockMethods.foo().(a) => param a: Int
example/NamedApplyBlockMethods.foo().(b) => param b: Int
example/NamedApplyBlockMethods.foo().(c) => param c: Int
example/NamedApplyBlockMethods.local. => val method local Int
example/NamedApplyBlockMethods.recursive(). => method recursive => Int
local0 => val local c$1: Int
local1 => val local b$1: Int @uncheckedVariance

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:29): NamedApplyBlockMethods <- example/NamedApplyBlockMethods.
[3:6..3:11): local <- example/NamedApplyBlockMethods.local.
[4:6..4:9): foo <- example/NamedApplyBlockMethods.foo().
[4:10..4:11): a <- example/NamedApplyBlockMethods.foo().(a)
[4:13..4:16): Int -> scala/Int#
[4:22..4:23): b <- example/NamedApplyBlockMethods.foo().(b)
[4:25..4:28): Int -> scala/Int#
[4:34..4:35): c <- example/NamedApplyBlockMethods.foo().(c)
[4:37..4:40): Int -> scala/Int#
[4:47..4:50): Int -> scala/Int#
[4:53..4:54): a -> example/NamedApplyBlockMethods.foo().(a)
[4:55..4:56): + -> scala/Int#`+`(+4).
[4:57..4:58): b -> example/NamedApplyBlockMethods.foo().(b)
[4:59..4:60): + -> scala/Int#`+`(+4).
[4:61..4:62): c -> example/NamedApplyBlockMethods.foo().(c)
[5:6..5:14): baseCase <- example/NamedApplyBlockMethods.baseCase().
[5:17..5:20): foo -> example/NamedApplyBlockMethods.foo().
[5:21..5:26): local -> example/NamedApplyBlockMethods.local.
[5:28..5:29): c -> example/NamedApplyBlockMethods.foo().(c)
[6:6..6:15): recursive <- example/NamedApplyBlockMethods.recursive().
[6:18..6:21): foo -> example/NamedApplyBlockMethods.foo().
[6:22..6:27): local -> example/NamedApplyBlockMethods.local.
[6:29..6:30): c -> example/NamedApplyBlockMethods.foo().(c)
[6:33..6:36): foo -> example/NamedApplyBlockMethods.foo().
[6:37..6:42): local -> example/NamedApplyBlockMethods.local.
[6:44..6:45): c -> example/NamedApplyBlockMethods.foo().(c)
[9:7..9:43): NamedApplyBlockCaseClassConstruction <- example/NamedApplyBlockCaseClassConstruction.
[10:13..10:16): Msg <- example/NamedApplyBlockCaseClassConstruction.Msg#
[10:16..10:16): <- example/NamedApplyBlockCaseClassConstruction.Msg#`<init>`().
[10:17..10:21): body <- example/NamedApplyBlockCaseClassConstruction.Msg#body.
[10:23..10:29): String -> scala/Predef.String#
[10:31..10:35): head <- example/NamedApplyBlockCaseClassConstruction.Msg#head.
[10:37..10:43): String -> scala/Predef.String#
[10:57..10:61): tail <- example/NamedApplyBlockCaseClassConstruction.Msg#tail.
[10:63..10:69): String -> scala/Predef.String#
[11:6..11:14): bodyText <- example/NamedApplyBlockCaseClassConstruction.bodyText.
[12:6..12:9): msg <- example/NamedApplyBlockCaseClassConstruction.msg.
[12:12..12:15): Msg -> example/NamedApplyBlockCaseClassConstruction.Msg.
[12:16..12:24): bodyText -> example/NamedApplyBlockCaseClassConstruction.bodyText.
[12:26..12:30): tail -> example/NamedApplyBlockCaseClassConstruction.Msg.apply().(tail)

expect/NamedArguments.scala
---------------------------

Summary:
Schema => SemanticDB v4
Uri => NamedArguments.scala
Text => empty
Language => Scala
Symbols => 16 entries
Occurrences => 12 entries

Symbols:
example/NamedArguments# => class NamedArguments extends Object { self: NamedArguments => +4 decls }
example/NamedArguments#User# => case class User extends Object with Product with Serializable { self: User => +5 decls }
example/NamedArguments#User#_1(). => method _1 => String
example/NamedArguments#User#`<init>`(). => primary ctor <init> (val param name: String): User
example/NamedArguments#User#`<init>`().(name) => val param name: String
example/NamedArguments#User#copy$default$1(). => method copy$default$1 => String @uncheckedVariance
example/NamedArguments#User#copy(). => method copy (param name: String): User
example/NamedArguments#User#copy().(name) => param name: String
example/NamedArguments#User#name. => val method name String
example/NamedArguments#User. => final object User extends Object { self: User.type => +4 decls }
example/NamedArguments#User.apply(). => method apply (param name: String): User
example/NamedArguments#User.apply().(name) => param name: String
example/NamedArguments#User.toString(). => method toString => String <: scala/Any#toString().
example/NamedArguments#User.unapply(). => method unapply (param x$1: User): User
example/NamedArguments#User.unapply().(x$1) => param x$1: User
example/NamedArguments#`<init>`(). => primary ctor <init> (): NamedArguments

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:20): NamedArguments <- example/NamedArguments#
[3:2..3:2): <- example/NamedArguments#`<init>`().
[3:13..3:17): User <- example/NamedArguments#User#
[3:17..3:17): <- example/NamedArguments#User#`<init>`().
[3:18..3:22): name <- example/NamedArguments#User#name.
[3:24..3:30): String -> scala/Predef.String#
[4:2..4:6): User -> example/NamedArguments#User.
[4:7..4:11): name -> example/NamedArguments#User.apply().(name)
[5:2..5:6): User -> example/NamedArguments#User.
[5:7..5:12): apply -> example/NamedArguments#User.apply().
[5:13..5:17): name -> example/NamedArguments#User.apply().(name)

expect/NewModifiers.scala
-------------------------

Summary:
Schema => SemanticDB v4
Uri => NewModifiers.scala
Text => empty
Language => Scala
Symbols => 14 entries
Occurrences => 18 entries

Symbols:
_empty_/NewModifiers$package. => final package object _empty_ extends Object { self: _empty_.type { opaque type OpaqueB  } => +2 decls }
_empty_/NewModifiers$package.OpaqueB# => opaque type OpaqueB 
_empty_/NewModifiers. => final object NewModifiers extends Object { self: NewModifiers.type { opaque type A  } => +3 decls }
_empty_/NewModifiers.A# => opaque type A 
_empty_/NewModifiers.foo. => val inline method foo "foo"
_empty_/NewModifiersClass# => opaque class NewModifiersClass extends Object { self: Any { opaque type C  } & NewModifiersClass => +5 decls }
_empty_/NewModifiersClass#C# => opaque type C 
_empty_/NewModifiersClass#Nested# => opaque class Nested extends Object { self: Any { opaque type NestedOpaque  } & Nested => +2 decls }
_empty_/NewModifiersClass#Nested#NestedOpaque# => opaque type NestedOpaque 
_empty_/NewModifiersClass#Nested#`<init>`(). => primary ctor <init> (): Nested
_empty_/NewModifiersClass#`<init>`(). => primary ctor <init> (): NewModifiersClass
_empty_/NewModifiersTrait# => opaque trait NewModifiersTrait extends Object { self: Any { opaque type D  } & NewModifiersTrait => +2 decls }
_empty_/NewModifiersTrait#D# => opaque type D 
_empty_/NewModifiersTrait#`<init>`(). => primary ctor <init> (): NewModifiersTrait

Occurrences:
[0:7..0:19): NewModifiers <- _empty_/NewModifiers.
[1:13..1:16): foo <- _empty_/NewModifiers.foo.
[2:14..2:15): A <- _empty_/NewModifiers.A#
[2:18..2:21): Int -> scala/Int#
[5:12..5:19): OpaqueB <- _empty_/NewModifiers$package.OpaqueB#
[5:22..5:25): Int -> scala/Int#
[7:6..7:23): NewModifiersClass <- _empty_/NewModifiersClass#
[8:2..8:2): <- _empty_/NewModifiersClass#`<init>`().
[8:14..8:15): C <- _empty_/NewModifiersClass#C#
[8:18..8:21): Int -> scala/Int#
[9:8..9:14): Nested <- _empty_/NewModifiersClass#Nested#
[10:4..10:4): <- _empty_/NewModifiersClass#Nested#`<init>`().
[10:16..10:28): NestedOpaque <- _empty_/NewModifiersClass#Nested#NestedOpaque#
[10:31..10:34): Int -> scala/Int#
[14:6..14:23): NewModifiersTrait <- _empty_/NewModifiersTrait#
[15:2..15:2): <- _empty_/NewModifiersTrait#`<init>`().
[15:14..15:15): D <- _empty_/NewModifiersTrait#D#
[15:18..15:21): Int -> scala/Int#

expect/Objects.scala
--------------------

Summary:
Schema => SemanticDB v4
Uri => Objects.scala
Text => empty
Language => Scala
Symbols => 2 entries
Occurrences => 3 entries

Symbols:
objects/X. => final object X extends Object { self: X.type => +3 decls }
objects/X.Y. => final object Y extends Object { self: Y.type => +1 decls }

Occurrences:
[0:8..0:15): objects <- objects/
[2:7..2:8): X <- objects/X.
[3:9..3:10): Y <- objects/X.Y.

expect/Overrides.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => Overrides.scala
Text => empty
Language => Scala
Symbols => 6 entries
Occurrences => 10 entries

Symbols:
example/A# => trait A extends Object { self: A => +2 decls }
example/A#`<init>`(). => primary ctor <init> (): A
example/A#foo(). => abstract method foo => Int
example/B# => class B extends Object with A { self: B => +2 decls }
example/B#`<init>`(). => primary ctor <init> (): B
example/B#foo(). => method foo => Int <: example/A#foo().

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:7): A <- example/A#
[2:10..2:10): <- example/A#`<init>`().
[2:14..2:17): foo <- example/A#foo().
[2:19..2:22): Int -> scala/Int#
[3:6..3:7): B <- example/B#
[3:7..3:7): <- example/B#`<init>`().
[3:18..3:19): A -> example/A#
[3:26..3:29): foo <- example/B#foo().
[3:31..3:34): Int -> scala/Int#

expect/Prefixes.scala
---------------------

Summary:
Schema => SemanticDB v4
Uri => Prefixes.scala
Text => empty
Language => Scala
Symbols => 19 entries
Occurrences => 49 entries

Symbols:
prefixes/C# => class C extends Object { self: C => +6 decls }
prefixes/C#N. => final object N extends Object { self: N.type => +2 decls }
prefixes/C#N.U# => type U 
prefixes/C#T# => type T 
prefixes/C#`<init>`(). => primary ctor <init> (): C
prefixes/C#k1(). => method k1 => U
prefixes/C#m1(). => method m1 => T
prefixes/M. => final object M extends Object { self: M.type => +3 decls }
prefixes/M.T# => type T 
prefixes/M.n1(). => method n1 => T
prefixes/O. => final object O extends C { self: O.type => +2 decls }
prefixes/O.o1(). => method o1 => O.this.T
prefixes/Test. => final object Test extends Object { self: Test.type => +7 decls }
prefixes/Test.c. => val method c C
prefixes/Test.k2(). => method k2 => c.N.U
prefixes/Test.k3(). => method k3 => c.N.U
prefixes/Test.m2(). => method m2 => c.T
prefixes/Test.n2(). => method n2 => T
prefixes/Test.n3(). => method n3 => T

Occurrences:
[0:8..0:16): prefixes <- prefixes/
[2:6..2:7): C <- prefixes/C#
[3:2..3:2): <- prefixes/C#`<init>`().
[3:7..3:8): T <- prefixes/C#T#
[4:6..4:8): m1 <- prefixes/C#m1().
[4:10..4:11): T -> prefixes/C#T#
[4:14..4:17): ??? -> scala/Predef.`???`().
[6:9..6:10): N <- prefixes/C#N.
[7:9..7:10): U <- prefixes/C#N.U#
[9:6..9:8): k1 <- prefixes/C#k1().
[9:10..9:11): N -> prefixes/C#N.
[9:12..9:13): U -> prefixes/C#N.U#
[9:16..9:19): ??? -> scala/Predef.`???`().
[12:7..12:8): M <- prefixes/M.
[13:7..13:8): T <- prefixes/M.T#
[14:6..14:8): n1 <- prefixes/M.n1().
[14:10..14:11): T -> prefixes/M.T#
[14:14..14:17): ??? -> scala/Predef.`???`().
[17:7..17:8): O <- prefixes/O.
[17:17..17:18): C -> prefixes/C#
[18:6..18:8): o1 <- prefixes/O.o1().
[18:10..18:11): T -> prefixes/C#T#
[18:14..18:17): ??? -> scala/Predef.`???`().
[21:7..21:11): Test <- prefixes/Test.
[22:6..22:7): c <- prefixes/Test.c.
[22:9..22:10): C -> prefixes/C#
[22:13..22:16): ??? -> scala/Predef.`???`().
[23:6..23:8): m2 <- prefixes/Test.m2().
[23:10..23:11): c -> prefixes/Test.c.
[23:12..23:13): T -> prefixes/C#T#
[23:16..23:19): ??? -> scala/Predef.`???`().
[24:6..24:8): k2 <- prefixes/Test.k2().
[24:10..24:11): c -> prefixes/Test.c.
[24:12..24:13): N -> prefixes/C#N.
[24:14..24:15): U -> prefixes/C#N.U#
[24:18..24:21): ??? -> scala/Predef.`???`().
[25:9..25:10): c -> prefixes/Test.c.
[25:11..25:12): N -> prefixes/C#N.
[26:6..26:8): k3 <- prefixes/Test.k3().
[26:10..26:11): U -> prefixes/C#N.U#
[26:14..26:17): ??? -> scala/Predef.`???`().
[28:6..28:8): n2 <- prefixes/Test.n2().
[28:10..28:11): M -> prefixes/M.
[28:12..28:13): T -> prefixes/M.T#
[28:16..28:19): ??? -> scala/Predef.`???`().
[30:9..30:10): M -> prefixes/M.
[31:6..31:8): n3 <- prefixes/Test.n3().
[31:10..31:11): T -> prefixes/M.T#
[31:14..31:17): ??? -> scala/Predef.`???`().

expect/RecOrRefined.scala
-------------------------

Summary:
Schema => SemanticDB v4
Uri => RecOrRefined.scala
Text => empty
Language => Scala
Symbols => 68 entries
Occurrences => 115 entries
Synthetics => 3 entries

Symbols:
example/C# => class C extends Object { self: C => +3 decls }
example/C#T1# => type T1 
example/C#T2# => type T2 
example/C#`<init>`(). => primary ctor <init> (): C
example/PickOneRefinement_1# => class PickOneRefinement_1 [typeparam S  <: SpecialRefinement { abstract method pickOne [typeparam T ](param as: T*): Option[String] }] extends Object { self: PickOneRefinement_1[S] => +3 decls }
example/PickOneRefinement_1#[S] => typeparam S  <: SpecialRefinement { abstract method pickOne [typeparam T ](param as: T*): Option[String] }
example/PickOneRefinement_1#[S](as) => param as: T*
example/PickOneRefinement_1#[S][T] => typeparam T 
example/PickOneRefinement_1#`<init>`(). => primary ctor <init> [typeparam S  <: SpecialRefinement { abstract method pickOne [typeparam T ](param as: T*): Option[String] }](): PickOneRefinement_1[S]
example/PickOneRefinement_1#run(). => method run (param s: S, param as: String*): Option[String]
example/PickOneRefinement_1#run().(as) => param as: String*
example/PickOneRefinement_1#run().(s) => param s: S
example/PolyHolder# => trait PolyHolder extends Object { self: PolyHolder => +2 decls }
example/PolyHolder#`<init>`(). => primary ctor <init> (): PolyHolder
example/PolyHolder#foo(). => abstract method foo [typeparam T ](param t: T): Any
example/PolyHolder#foo().(t) => param t: T
example/PolyHolder#foo().[T] => typeparam T 
example/RecOrRefined$package. => final package object example extends Object { self: example.type => +9 decls }
example/RecOrRefined$package.C2# => type C2  = C { type T2  = T1 <: example/C#T2#; type T1  <: example/C#T1# }
example/RecOrRefined$package.Person# => type Person  = Record { abstract val method age Int; abstract val method name String }
example/RecOrRefined$package.m1(). => method m1 (param a: Int { abstract val method x Int }): Nothing
example/RecOrRefined$package.m1().(a) => param a: Int { abstract val method x Int }
example/RecOrRefined$package.m2(). => method m2 (param x: Object { abstract method y => Int; abstract val method x Int }): Nothing
example/RecOrRefined$package.m2().(x) => param x: Object { abstract method y => Int; abstract val method x Int }
example/RecOrRefined$package.m3(). => method m3 (param x: Object { type z ; abstract method y => Int; abstract val method x Int }): Nothing
example/RecOrRefined$package.m3().(x) => param x: Object { type z ; abstract method y => Int; abstract val method x Int }
example/RecOrRefined$package.m4(). => method m4 (param x: PolyHolder { abstract method foo [typeparam T ](param t: T): T <: example/PolyHolder#foo(). }): Nothing
example/RecOrRefined$package.m4().(x) => param x: PolyHolder { abstract method foo [typeparam T ](param t: T): T <: example/PolyHolder#foo(). }
example/RecOrRefined$package.m5(). => method m5 [typeparam Z ](param x: Int): PolyHolder { abstract method foo [typeparam T ](param t: T): T <: example/PolyHolder#foo(). }
example/RecOrRefined$package.m5().(x) => param x: Int
example/RecOrRefined$package.m5().[Z] => typeparam Z 
example/RecOrRefined$package.m6# => type m6 [typeparam X ] = PolyHolder { abstract method foo [typeparam T ](param t: T): T <: example/PolyHolder#foo(). }
example/RecOrRefined$package.m6#[X] => typeparam X 
example/Record# => class Record extends Object with Selectable { self: Record => +4 decls }
example/Record#`<init>`(). => primary ctor <init> (param elems: Tuple2[String, Any]*): Record
example/Record#`<init>`().(elems) => param elems: Tuple2[String, Any]*
example/Record#elems. => private[this] val method elems Tuple2[String, Any]*
example/Record#fields. => private[this] val method fields Map[String, Any]
example/Record#selectDynamic(). => method selectDynamic (param name: String): Any
example/Record#selectDynamic().(name) => param name: String
example/SpecialRefinement# => trait SpecialRefinement extends Object { self: SpecialRefinement => +2 decls }
example/SpecialRefinement#`<init>`(). => primary ctor <init> (): SpecialRefinement
example/SpecialRefinement#pickOne(). => abstract method pickOne [typeparam T ](param as: T*): Option[Any]
example/SpecialRefinement#pickOne().(as) => param as: T*
example/SpecialRefinement#pickOne().[T] => typeparam T 
local0 => abstract method pickOne [typeparam T ](param as: T*): Option[String]
local1 => typeparam T 
local2 => param as: T*
local3 => abstract method pickOne [typeparam T ](param as: T*): Option[String] <: example/SpecialRefinement#pickOne().
local4 => abstract val method x Int
local5 => abstract val method x Int
local6 => abstract method y => Int
local7 => abstract val method x Int
local8 => abstract method y => Int
local9 => type z 
local10 => typeparam T 
local11 => param t: T
local12 => abstract method foo [typeparam T ](param t: T): T <: example/PolyHolder#foo().
local13 => typeparam T 
local14 => param t: T
local15 => abstract method foo [typeparam T ](param t: T): T <: example/PolyHolder#foo().
local16 => typeparam T 
local17 => param t: T
local18 => abstract method foo [typeparam T ](param t: T): T <: example/PolyHolder#foo().
local19 => abstract val method name String
local20 => abstract val method age Int
local21 => type T1  <: example/C#T1#
local22 => type T2  = T1 <: example/C#T2#

Occurrences:
[0:8..0:15): example <- example/
[2:4..2:6): m1 <- example/RecOrRefined$package.m1().
[2:7..2:8): a <- example/RecOrRefined$package.m1().(a)
[2:10..2:13): Int -> scala/Int#
[2:20..2:21): x <- local4
[2:23..2:26): Int -> scala/Int#
[2:32..2:35): ??? -> scala/Predef.`???`().
[3:4..3:6): m2 <- example/RecOrRefined$package.m2().
[3:7..3:8): x <- example/RecOrRefined$package.m2().(x)
[3:16..3:17): x <- local5
[3:19..3:22): Int -> scala/Int#
[3:28..3:29): y <- local6
[3:31..3:34): Int -> scala/Int#
[3:40..3:43): ??? -> scala/Predef.`???`().
[4:4..4:6): m3 <- example/RecOrRefined$package.m3().
[4:7..4:8): x <- example/RecOrRefined$package.m3().(x)
[4:16..4:17): x <- local7
[4:19..4:22): Int -> scala/Int#
[4:28..4:29): y <- local8
[4:31..4:34): Int -> scala/Int#
[4:41..4:42): z <- local9
[4:48..4:51): ??? -> scala/Predef.`???`().
[5:6..5:16): PolyHolder <- example/PolyHolder#
[6:2..6:2): <- example/PolyHolder#`<init>`().
[6:6..6:9): foo <- example/PolyHolder#foo().
[6:10..6:11): T <- example/PolyHolder#foo().[T]
[6:13..6:14): t <- example/PolyHolder#foo().(t)
[6:16..6:17): T -> example/PolyHolder#foo().[T]
[6:20..6:23): Any -> scala/Any#
[9:4..9:6): m4 <- example/RecOrRefined$package.m4().
[9:7..9:8): x <- example/RecOrRefined$package.m4().(x)
[9:10..9:20): PolyHolder -> example/PolyHolder#
[9:27..9:30): foo <- local12
[9:31..9:32): T <- local10
[9:34..9:35): t <- local11
[9:37..9:38): T -> local10
[9:41..9:42): T -> local10
[9:48..9:51): ??? -> scala/Predef.`???`().
[10:4..10:6): m5 <- example/RecOrRefined$package.m5().
[10:7..10:8): Z <- example/RecOrRefined$package.m5().[Z]
[10:10..10:11): x <- example/RecOrRefined$package.m5().(x)
[10:13..10:16): Int -> scala/Int#
[10:19..10:29): PolyHolder -> example/PolyHolder#
[10:36..10:39): foo <- local15
[10:40..10:41): T <- local13
[10:43..10:44): t <- local14
[10:46..10:47): T -> local13
[10:50..10:51): T -> local13
[10:56..10:59): ??? -> scala/Predef.`???`().
[12:5..12:7): m6 <- example/RecOrRefined$package.m6#
[12:11..12:12): X <- example/RecOrRefined$package.m6#[X]
[12:18..12:28): PolyHolder -> example/PolyHolder#
[12:35..12:38): foo <- local18
[12:39..12:40): T <- local16
[12:42..12:43): t <- local17
[12:45..12:46): T -> local16
[12:49..12:50): T -> local16
[14:6..14:12): Record <- example/Record#
[14:12..14:12): <- example/Record#`<init>`().
[14:13..14:18): elems <- example/Record#elems.
[14:21..14:27): String -> scala/Predef.String#
[14:29..14:32): Any -> scala/Any#
[14:44..14:54): Selectable -> scala/Selectable#
[15:14..15:20): fields <- example/Record#fields.
[15:23..15:28): elems -> example/Record#elems.
[15:29..15:34): toMap -> scala/collection/IterableOnceOps#toMap().
[16:6..16:19): selectDynamic <- example/Record#selectDynamic().
[16:20..16:24): name <- example/Record#selectDynamic().(name)
[16:26..16:32): String -> scala/Predef.String#
[16:35..16:38): Any -> scala/Any#
[16:41..16:47): fields -> example/Record#fields.
[16:48..16:52): name -> example/Record#selectDynamic().(name)
[18:5..18:11): Person <- example/RecOrRefined$package.Person#
[18:14..18:20): Record -> example/Record#
[19:6..19:10): name <- local19
[19:12..19:18): String -> scala/Predef.String#
[20:6..20:9): age <- local20
[20:11..20:14): Int -> scala/Int#
[24:6..24:7): C <- example/C#
[24:10..24:10): <- example/C#`<init>`().
[24:15..24:17): T1 <- example/C#T1#
[24:24..24:26): T2 <- example/C#T2#
[25:5..25:7): C2 <- example/RecOrRefined$package.C2#
[25:10..25:11): C -> example/C#
[25:19..25:21): T1 <- local21
[25:28..25:30): T2 <- local22
[25:33..25:35): T1 -> local21
[27:6..27:23): SpecialRefinement <- example/SpecialRefinement#
[28:2..28:2): <- example/SpecialRefinement#`<init>`().
[28:6..28:13): pickOne <- example/SpecialRefinement#pickOne().
[28:14..28:15): T <- example/SpecialRefinement#pickOne().[T]
[28:17..28:19): as <- example/SpecialRefinement#pickOne().(as)
[28:21..28:22): T -> example/SpecialRefinement#pickOne().[T]
[28:26..28:32): Option -> scala/Option#
[28:33..28:36): Any -> scala/Any#
[31:6..31:25): PickOneRefinement_1 <- example/PickOneRefinement_1#
[31:25..31:25): <- example/PickOneRefinement_1#`<init>`().
[31:26..31:27): S <- example/PickOneRefinement_1#[S]
[31:31..31:48): SpecialRefinement -> example/SpecialRefinement#
[31:55..31:62): pickOne <- local3
[31:63..31:64): T <- local1
[31:66..31:68): as <- local2
[31:70..31:71): T -> local1
[31:75..31:81): Option -> scala/Option#
[31:82..31:88): String -> scala/Predef.String#
[32:6..32:9): run <- example/PickOneRefinement_1#run().
[32:10..32:11): s <- example/PickOneRefinement_1#run().(s)
[32:13..32:14): S -> example/PickOneRefinement_1#[S]
[32:16..32:18): as <- example/PickOneRefinement_1#run().(as)
[32:20..32:26): String -> scala/Predef.String#
[32:30..32:36): Option -> scala/Option#
[32:37..32:43): String -> scala/Predef.String#
[32:47..32:48): s -> example/PickOneRefinement_1#run().(s)
[32:49..32:56): pickOne -> example/SpecialRefinement#pickOne().
[32:57..32:59): as -> example/PickOneRefinement_1#run().(as)

Synthetics:
[15:23..15:34):elems.toMap => *[String, Any]
[15:23..15:34):elems.toMap => *(refl[Tuple2[String, Any]])
[32:47..32:56):s.pickOne => *[String]

expect/RightAssociativeExtension.scala
--------------------------------------

Summary:
Schema => SemanticDB v4
Uri => RightAssociativeExtension.scala
Text => empty
Language => Scala
Symbols => 5 entries
Occurrences => 12 entries

Symbols:
ext/RightAssociativeExtension$package. => final package object ext extends Object { self: ext.type => +3 decls }
ext/RightAssociativeExtension$package.`:*:`(). => method :*: (param i: Int)(param s: String): Tuple2[String, Int]
ext/RightAssociativeExtension$package.`:*:`().(i) => param i: Int
ext/RightAssociativeExtension$package.`:*:`().(s) => param s: String
ext/RightAssociativeExtension$package.b. => val method b Tuple2[String, Int]

Occurrences:
[0:8..0:11): ext <- ext/
[2:11..2:12): s <- ext/RightAssociativeExtension$package.`:*:`().(s)
[2:14..2:20): String -> scala/Predef.String#
[3:6..3:9): :*: <- ext/RightAssociativeExtension$package.`:*:`().
[3:11..3:12): i <- ext/RightAssociativeExtension$package.`:*:`().(i)
[3:14..3:17): Int -> scala/Int#
[3:21..3:27): String -> scala/Predef.String#
[3:29..3:32): Int -> scala/Int#
[3:37..3:38): s -> ext/RightAssociativeExtension$package.`:*:`().(s)
[3:40..3:41): i -> ext/RightAssociativeExtension$package.`:*:`().(i)
[5:4..5:5): b <- ext/RightAssociativeExtension$package.b.
[5:14..5:17): :*: -> ext/RightAssociativeExtension$package.`:*:`().

expect/Selfs.scala
------------------

Summary:
Schema => SemanticDB v4
Uri => Selfs.scala
Text => empty
Language => Scala
Symbols => 13 entries
Occurrences => 22 entries

Symbols:
local0 => selfparam self: C1
local1 => selfparam self: B
local2 => selfparam self: B & C1
selfs/B# => class B extends Object { self: B => +1 decls }
selfs/B#`<init>`(). => primary ctor <init> (): B
selfs/C1# => class C1 extends B { self: C1 & C1 => +1 decls }
selfs/C1#`<init>`(). => primary ctor <init> (): C1
selfs/C2# => class C2 extends B { self: B & C2 => +1 decls }
selfs/C2#`<init>`(). => primary ctor <init> (): C2
selfs/C3# => class C3 extends B { self: B & C1 & C3 => +1 decls }
selfs/C3#`<init>`(). => primary ctor <init> (): C3
selfs/C6# => class C6 extends B { self: B & C6 => +1 decls }
selfs/C6#`<init>`(). => primary ctor <init> (): C6

Occurrences:
[0:8..0:13): selfs <- selfs/
[2:0..2:0): <- selfs/B#`<init>`().
[2:6..2:7): B <- selfs/B#
[4:6..4:8): C1 <- selfs/C1#
[4:17..4:18): B -> selfs/B#
[4:17..4:17): <- selfs/C1#`<init>`().
[4:21..4:25): self <- local0
[7:6..7:8): C2 <- selfs/C2#
[7:17..7:18): B -> selfs/B#
[7:17..7:17): <- selfs/C2#`<init>`().
[7:21..7:25): self <- local1
[7:27..7:28): B -> selfs/B#
[10:6..10:8): C3 <- selfs/C3#
[10:17..10:18): B -> selfs/B#
[10:17..10:17): <- selfs/C3#`<init>`().
[10:21..10:25): self <- local2
[10:27..10:28): B -> selfs/B#
[10:34..10:36): C1 -> selfs/C1#
[13:6..13:8): C6 <- selfs/C6#
[13:17..13:18): B -> selfs/B#
[13:17..13:17): <- selfs/C6#`<init>`().
[13:27..13:28): B -> selfs/B#

expect/Synthetic.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => Synthetic.scala
Text => empty
Language => Scala
Symbols => 52 entries
Occurrences => 136 entries
Synthetics => 39 entries

Symbols:
example/Synthetic# => class Synthetic extends Object { self: Synthetic => +23 decls }
example/Synthetic#Contexts. => final object Contexts extends Object { self: Contexts.type => +6 decls }
example/Synthetic#Contexts.foo(). => method foo (param x: Int)(implicit given param x$2: Int): Nothing
example/Synthetic#Contexts.foo().(x$2) => implicit given param x$2: Int
example/Synthetic#Contexts.foo().(x) => param x: Int
example/Synthetic#Contexts.m1(). => method m1 (implicit given param x$1: Int): Nothing
example/Synthetic#Contexts.m1().(x$1) => implicit given param x$1: Int
example/Synthetic#Contexts.m2(). => method m2 (implicit given param x: Int): Nothing
example/Synthetic#Contexts.m2().(x) => implicit given param x: Int
example/Synthetic#Contexts.m3(). => method m3 => Nothing
example/Synthetic#Contexts.m4(). => method m4 => Nothing
example/Synthetic#F# => class F extends Object { self: F => +1 decls }
example/Synthetic#F#`<init>`(). => primary ctor <init> (): F
example/Synthetic#J# => class J [typeparam T ] extends Object { self: J[T] => +4 decls }
example/Synthetic#J#[T] => typeparam T 
example/Synthetic#J#`<init>`(). => primary ctor <init> [typeparam T ]()(implicit param evidence$1: Manifest[T]): J[T]
example/Synthetic#J#`<init>`().(evidence$1) => implicit param evidence$1: Manifest[T]
example/Synthetic#J#arr. => val method arr Array[T]
example/Synthetic#J#evidence$1. => private[this] implicit val method evidence$1 Manifest[T]
example/Synthetic#Name. => val method Name Regex
example/Synthetic#`<init>`(). => primary ctor <init> (): Synthetic
example/Synthetic#a1. => val method a1 Int
example/Synthetic#a2. => val method a2 Int
example/Synthetic#as. => val method as LazyList[Int]
example/Synthetic#f. => val method f Ordered[F]
example/Synthetic#lst. => val method lst LazyList[Int]
example/Synthetic#name. => val method name String
example/Synthetic#ordering. => implicit val method ordering Ordering[F]
example/Synthetic#s. => final object s extends Object { self: s.type => +5 decls }
example/Synthetic#s.Bar# => case class Bar extends Object with Product with Serializable { self: Bar => +2 decls }
example/Synthetic#s.Bar#`<init>`(). => primary ctor <init> (): Bar
example/Synthetic#s.Bar#copy(). => method copy (): Bar
example/Synthetic#s.Bar. => final object Bar extends Object { self: Bar.type => +4 decls }
example/Synthetic#s.Bar.apply(). => method apply (): Bar
example/Synthetic#s.Bar.toString(). => method toString => String <: scala/Any#toString().
example/Synthetic#s.Bar.unapply(). => method unapply (param x$1: Bar): true
example/Synthetic#s.Bar.unapply().(x$1) => param x$1: Bar
example/Synthetic#s.apply(). => method apply (): Int
example/Synthetic#x. => val method x Int
example/Synthetic#xs. => val method xs LazyList[Int]
local0 => param x: Int
local1 => param y: Int
local2 => param i: Int
local3 => param j: Int
local4 => param i: Int
local5 => param j: Int
local6 => param a: Int
local7 => param b: Int
local8 => param a: Int
local9 => param b: Int
local10 => final implicit lazy val given local x: Int
local11 => final implicit lazy val given local given_Int: Int

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:12): scala -> scala/
[2:13..2:21): language -> scala/language.
[2:22..2:41): implicitConversions -> scala/language.implicitConversions.
[4:6..4:15): Synthetic <- example/Synthetic#
[5:2..5:6): List -> scala/package.List.
[5:2..5:2): <- example/Synthetic#`<init>`().
[5:10..5:13): map -> scala/collection/immutable/List#map().
[5:16..5:17): + -> scala/Int#`+`(+4).
[6:2..6:7): Array -> scala/Array.
[6:8..6:13): empty -> scala/Array.empty().
[6:14..6:17): Int -> scala/Int#
[6:19..6:29): headOption -> scala/collection/ArrayOps#headOption().
[7:9..7:20): stripPrefix -> scala/collection/StringOps#stripPrefix().
[10:6..10:10): Name <- example/Synthetic#Name.
[10:25..10:26): r -> scala/collection/StringOps#r().
[11:6..11:7): x <- example/Synthetic#x.
[11:8..11:11): #:: -> scala/package.`#::`.
[11:12..11:14): xs <- example/Synthetic#xs.
[11:17..11:25): LazyList -> scala/package.LazyList.
[12:6..12:10): Name -> example/Synthetic#Name.
[12:11..12:15): name <- example/Synthetic#name.
[13:14..13:22): LazyList -> scala/package.LazyList.
[13:23..13:28): empty -> scala/collection/immutable/LazyList.empty().
[15:6..15:8): a1 <- example/Synthetic#a1.
[15:9..15:12): #:: -> scala/package.`#::`.
[15:13..15:15): a2 <- example/Synthetic#a2.
[15:16..15:19): #:: -> scala/package.`#::`.
[15:20..15:22): as <- example/Synthetic#as.
[15:25..15:33): LazyList -> scala/package.LazyList.
[17:6..17:9): lst <- example/Synthetic#lst.
[17:24..17:32): LazyList -> scala/package.LazyList.
[17:33..17:38): empty -> scala/collection/immutable/LazyList.empty().
[19:7..19:8): x <- local0
[19:14..19:16): to -> scala/runtime/RichInt#to().
[19:21..19:22): y <- local1
[19:28..19:33): until -> scala/runtime/RichInt#until().
[19:38..19:45): println -> scala/Predef.println(+1).
[19:46..19:47): x -> local0
[19:48..19:50): -> -> scala/Predef.ArrowAssoc#`->`().
[19:51..19:52): x -> local0
[20:7..20:8): i <- local2
[20:14..20:16): to -> scala/runtime/RichInt#to().
[20:21..20:22): j <- local3
[20:28..20:33): until -> scala/runtime/RichInt#until().
[20:45..20:46): i -> local2
[20:48..20:49): j -> local3
[21:7..21:8): i <- local4
[21:14..21:16): to -> scala/runtime/RichInt#to().
[21:21..21:22): j <- local5
[21:28..21:33): until -> scala/runtime/RichInt#until().
[21:40..21:41): i -> local4
[21:42..21:43): % -> scala/Int#`%`(+3).
[21:46..21:48): == -> scala/Int#`==`(+3).
[21:59..21:60): i -> local4
[21:62..21:63): j -> local5
[23:9..23:10): s <- example/Synthetic#s.
[24:8..24:13): apply <- example/Synthetic#s.apply().
[26:6..26:11): apply -> example/Synthetic#s.apply().
[27:15..27:18): Bar <- example/Synthetic#s.Bar#
[27:18..27:18): <- example/Synthetic#s.Bar#`<init>`().
[28:4..28:7): Bar -> example/Synthetic#s.Bar.
[29:9..29:21): asInstanceOf -> scala/Any#asInstanceOf().
[29:22..29:25): Int -> scala/Int#
[29:29..29:32): Int -> scala/Int#
[32:8..32:9): J <- example/Synthetic#J#
[32:9..32:9): <- example/Synthetic#J#`<init>`().
[32:10..32:11): T <- example/Synthetic#J#[T]
[32:11..32:11): <- example/Synthetic#J#evidence$1.
[32:13..32:21): Manifest -> scala/Predef.Manifest#
[32:29..32:32): arr <- example/Synthetic#J#arr.
[32:35..32:40): Array -> scala/Array.
[32:41..32:46): empty -> scala/Array.empty().
[32:47..32:48): T -> example/Synthetic#J#[T]
[34:2..34:2): <- example/Synthetic#F#`<init>`().
[34:8..34:9): F <- example/Synthetic#F#
[35:15..35:23): ordering <- example/Synthetic#ordering.
[35:25..35:33): Ordering -> scala/package.Ordering#
[35:34..35:35): F -> example/Synthetic#F#
[35:39..35:42): ??? -> scala/Predef.`???`().
[36:6..36:7): f <- example/Synthetic#f.
[36:9..36:16): Ordered -> scala/package.Ordered#
[36:17..36:18): F -> example/Synthetic#F#
[36:26..36:27): F -> example/Synthetic#F#
[38:9..38:14): scala -> scala/
[38:15..38:25): concurrent -> scala/concurrent/
[38:26..38:42): ExecutionContext -> scala/concurrent/ExecutionContext.
[38:43..38:52): Implicits -> scala/concurrent/ExecutionContext.Implicits.
[38:53..38:59): global -> scala/concurrent/ExecutionContext.Implicits.global().
[40:4..40:5): a <- local6
[40:9..40:14): scala -> scala/
[40:15..40:25): concurrent -> scala/concurrent/
[40:26..40:32): Future -> scala/concurrent/Future.
[40:33..40:43): successful -> scala/concurrent/Future.successful().
[41:4..41:5): b <- local7
[41:9..41:14): scala -> scala/
[41:15..41:25): concurrent -> scala/concurrent/
[41:26..41:32): Future -> scala/concurrent/Future.
[41:33..41:43): successful -> scala/concurrent/Future.successful().
[42:4..42:11): println -> scala/Predef.println(+1).
[42:12..42:13): a -> local6
[44:4..44:5): a <- local8
[44:9..44:14): scala -> scala/
[44:15..44:25): concurrent -> scala/concurrent/
[44:26..44:32): Future -> scala/concurrent/Future.
[44:33..44:43): successful -> scala/concurrent/Future.successful().
[45:4..45:5): b <- local9
[45:9..45:14): scala -> scala/
[45:15..45:25): concurrent -> scala/concurrent/
[45:26..45:32): Future -> scala/concurrent/Future.
[45:33..45:43): successful -> scala/concurrent/Future.successful().
[46:7..46:8): a -> local8
[46:9..46:10): < -> scala/Int#`<`(+3).
[46:11..46:12): b -> local9
[47:10..47:11): a -> local8
[49:9..49:17): Contexts <- example/Synthetic#Contexts.
[50:8..50:11): foo <- example/Synthetic#Contexts.foo().
[50:12..50:13): x <- example/Synthetic#Contexts.foo().(x)
[50:15..50:18): Int -> scala/Int#
[50:26..50:29): Int -> scala/Int#
[50:33..50:36): ??? -> scala/Predef.`???`().
[51:8..51:10): m1 <- example/Synthetic#Contexts.m1().
[51:17..51:20): Int -> scala/Int#
[51:24..51:27): foo -> example/Synthetic#Contexts.foo().
[52:8..52:10): m2 <- example/Synthetic#Contexts.m2().
[52:17..52:18): x <- example/Synthetic#Contexts.m2().(x)
[52:20..52:23): Int -> scala/Int#
[52:27..52:30): foo -> example/Synthetic#Contexts.foo().
[53:8..53:10): m3 <- example/Synthetic#Contexts.m3().
[54:12..54:13): x <- local10
[54:15..54:18): Int -> scala/Int#
[55:6..55:9): foo -> example/Synthetic#Contexts.foo().
[55:10..55:11): x -> local10
[56:8..56:10): m4 <- example/Synthetic#Contexts.m4().
[57:12..57:15): Int -> scala/Int#
[58:6..58:9): foo -> example/Synthetic#Contexts.foo().

Synthetics:
[5:2..5:13):List(1).map => *[Int]
[5:2..5:6):List => *.apply[Int]
[6:2..6:18):Array.empty[Int] => intArrayOps(*)
[7:2..7:8):"fooo" => augmentString(*)
[10:13..10:24):"name:(.*)" => augmentString(*)
[11:8..11:11):#:: => *.unapply[Int]
[11:17..11:25):LazyList => *.apply[Int]
[13:4..13:28):#:: 2 #:: LazyList.empty => *[Int]
[13:8..13:28):2 #:: LazyList.empty => toDeferrer[Int](*)
[13:10..13:28):#:: LazyList.empty => *[Int]
[13:14..13:28):LazyList.empty => toDeferrer[Nothing](*)
[13:14..13:28):LazyList.empty => *[Nothing]
[15:9..15:12):#:: => *.unapply[Int]
[15:16..15:19):#:: => *.unapply[Int]
[15:25..15:33):LazyList => *.apply[Int]
[17:14..17:38):#:: 2 #:: LazyList.empty => *[Int]
[17:18..17:38):2 #:: LazyList.empty => toDeferrer[Int](*)
[17:20..17:38):#:: LazyList.empty => *[Int]
[17:24..17:38):LazyList.empty => toDeferrer[Nothing](*)
[17:24..17:38):LazyList.empty => *[Nothing]
[19:12..19:13):1 => intWrapper(*)
[19:26..19:27):0 => intWrapper(*)
[19:46..19:50):x -> => *[Int]
[19:46..19:47):x => ArrowAssoc[Int](*)
[20:12..20:13):1 => intWrapper(*)
[20:26..20:27):0 => intWrapper(*)
[21:12..21:13):1 => intWrapper(*)
[21:26..21:27):0 => intWrapper(*)
[32:35..32:49):Array.empty[T] => *(evidence$1)
[36:22..36:27):new F => orderingToOrdered[F](*)
[36:22..36:27):new F => *(ordering)
[40:9..40:43):scala.concurrent.Future.successful => *[Int]
[41:9..41:43):scala.concurrent.Future.successful => *[Int]
[44:9..44:43):scala.concurrent.Future.successful => *[Int]
[45:9..45:43):scala.concurrent.Future.successful => *[Int]
[51:24..51:30):foo(0) => *(x$1)
[52:27..52:33):foo(0) => *(x)
[55:6..55:12):foo(x) => *(x)
[58:6..58:12):foo(0) => *(given_Int)

expect/Tabs.scala
-----------------

Summary:
Schema => SemanticDB v4
Uri => Tabs.scala
Text => empty
Language => Scala
Symbols => 2 entries
Occurrences => 5 entries
Synthetics => 2 entries

Symbols:
example/Tabs$package. => final package object example extends Object { self: example.type => +2 decls }
example/Tabs$package.a. => val method a List[Int]

Occurrences:
[0:8..0:15): example <- example/
[2:4..2:5): a <- example/Tabs$package.a.
[3:1..3:5): List -> scala/package.List.
[4:3..4:6): map -> scala/collection/immutable/List#map().
[4:9..4:10): + -> scala/Int#`+`(+4).

Synthetics:
[3:1..4:6):List(1,2,3)
		.map => *[Int]
[3:1..3:5):List => *.apply[Int]

expect/Traits.scala
-------------------

Summary:
Schema => SemanticDB v4
Uri => Traits.scala
Text => empty
Language => Scala
Symbols => 13 entries
Occurrences => 17 entries

Symbols:
local0 => final class $anon extends Object with U { self: $anon => +1 decls }
local2 => selfparam self: C
traits/C# => class C extends Object { self: C => +1 decls }
traits/C#`<init>`(). => primary ctor <init> (): C
traits/T# => trait T extends Object { self: T => +2 decls }
traits/T#`<init>`(). => primary ctor <init> (): T
traits/T#x(). => method x => Int
traits/U# => sealed trait U extends Object { self: U => +1 decls }
traits/U#`<init>`(). => primary ctor <init> (): U
traits/U. => final object U extends Object { self: U.type => +2 decls }
traits/U.u(). => method u => U
traits/V# => trait V extends Object { self: C & V => +1 decls }
traits/V#`<init>`(). => primary ctor <init> (): V

Occurrences:
[0:8..0:14): traits <- traits/
[2:6..2:7): T <- traits/T#
[3:2..3:2): <- traits/T#`<init>`().
[3:6..3:7): x <- traits/T#x().
[6:0..6:0): <- traits/U#`<init>`().
[6:13..6:14): U <- traits/U#
[7:7..7:8): U <- traits/U.
[8:6..8:7): u <- traits/U.u().
[8:9..8:10): U -> traits/U#
[8:13..8:13): <- local0
[8:17..8:18): U -> traits/U#
[11:0..11:0): <- traits/C#`<init>`().
[11:6..11:7): C <- traits/C#
[12:6..12:7): V <- traits/V#
[12:10..12:14): self <- local2
[12:10..12:10): <- traits/V#`<init>`().
[12:16..12:17): C -> traits/C#

expect/ValPattern.scala
-----------------------

Summary:
Schema => SemanticDB v4
Uri => ValPattern.scala
Text => empty
Language => Scala
Symbols => 22 entries
Occurrences => 45 entries
Synthetics => 11 entries

Symbols:
example/ValPattern# => class ValPattern extends Object { self: ValPattern => +14 decls }
example/ValPattern#`<init>`(). => primary ctor <init> (): ValPattern
example/ValPattern#`leftVar_=`(). => var method leftVar_= (param x$1: Int): Unit
example/ValPattern#`leftVar_=`().(x$1) => param x$1: Int
example/ValPattern#`number1Var_=`(). => var method number1Var_= (param x$1: Int): Unit
example/ValPattern#`number1Var_=`().(x$1) => param x$1: Int
example/ValPattern#`rightVar_=`(). => var method rightVar_= (param x$1: Int): Unit
example/ValPattern#`rightVar_=`().(x$1) => param x$1: Int
example/ValPattern#app(). => method app (): Unit
example/ValPattern#left. => val method left Int
example/ValPattern#leftVar(). => var method leftVar Int
example/ValPattern#number1. => val method number1 Int
example/ValPattern#number1Var(). => var method number1Var Int
example/ValPattern#q1. => val method q1 Nothing
example/ValPattern#right. => val method right Int
example/ValPattern#rightVar(). => var method rightVar Int
local0 => val local left: Int
local1 => val local right: Int
local2 => val local number1: Int
local3 => var local leftVar: Int
local4 => var local rightVar: Int
local5 => var local number1Var: Int

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:16): ValPattern <- example/ValPattern#
[4:2..4:2): <- example/ValPattern#`<init>`().
[4:7..4:11): left <- example/ValPattern#left.
[4:13..4:18): right <- example/ValPattern#right.
[5:6..5:10): Some -> scala/Some.
[5:11..5:18): number1 <- example/ValPattern#number1.
[6:4..6:8): Some -> scala/Some.
[8:6..8:10): List -> scala/package.List.
[8:11..8:15): Some -> scala/Some.
[8:16..8:18): q1 <- example/ValPattern#q1.
[8:21..8:25): None -> scala/None.
[8:29..8:32): ??? -> scala/Predef.`???`().
[10:7..10:14): leftVar <- example/ValPattern#leftVar().
[10:16..10:24): rightVar <- example/ValPattern#rightVar().
[11:6..11:10): Some -> scala/Some.
[11:11..11:21): number1Var <- example/ValPattern#number1Var().
[12:4..12:8): Some -> scala/Some.
[14:6..14:9): app <- example/ValPattern#app().
[14:13..14:17): Unit -> scala/Unit#
[15:4..15:11): println -> scala/Predef.println(+1).
[17:8..17:15): number1 -> example/ValPattern#number1.
[18:8..18:12): left -> example/ValPattern#left.
[19:8..19:13): right -> example/ValPattern#right.
[20:8..20:18): number1Var -> example/ValPattern#number1Var().
[21:8..21:15): leftVar -> example/ValPattern#leftVar().
[22:8..22:16): rightVar -> example/ValPattern#rightVar().
[25:4..25:11): locally -> scala/Predef.locally().
[26:11..26:15): left <- local0
[26:17..26:22): right <- local1
[27:10..27:14): Some -> scala/Some.
[27:15..27:22): number1 <- local2
[28:8..28:12): Some -> scala/Some.
[30:11..30:18): leftVar <- local3
[30:20..30:28): rightVar <- local4
[31:10..31:14): Some -> scala/Some.
[31:15..31:25): number1Var <- local5
[32:8..32:12): Some -> scala/Some.
[33:6..33:13): println -> scala/Predef.println(+1).
[35:10..35:17): number1 -> local2
[36:10..36:14): left -> local0
[37:10..37:15): right -> local1
[38:10..38:20): number1Var -> local5
[39:10..39:17): leftVar -> local3
[40:10..40:18): rightVar -> local4

Synthetics:
[5:6..5:10):Some => *.unapply[Int]
[6:4..6:8):Some => *.apply[Int]
[8:6..8:10):List => *.unapplySeq[Nothing]
[8:11..8:15):Some => *.unapply[Nothing]
[11:6..11:10):Some => *.unapply[Int]
[12:4..12:8):Some => *.apply[Int]
[25:4..25:11):locally => *[Unit]
[27:10..27:14):Some => *.unapply[Int]
[28:8..28:12):Some => *.apply[Int]
[31:10..31:14):Some => *.unapply[Int]
[32:8..32:12):Some => *.apply[Int]

expect/Vals.scala
-----------------

Summary:
Schema => SemanticDB v4
Uri => Vals.scala
Text => empty
Language => Scala
Symbols => 42 entries
Occurrences => 129 entries

Symbols:
example/ValUsages. => final object ValUsages extends Object { self: ValUsages.type => +2 decls }
example/ValUsages.v. => val method v Vals
example/Vals# => abstract class Vals extends Object { self: Vals => +25 decls }
example/Vals#_explicitSetter(). => private[this] var method _explicitSetter Int
example/Vals#`<init>`(). => primary ctor <init> (param p: Int, val param xp: Int, var param yp: Int): Vals
example/Vals#`<init>`().(p) => param p: Int
example/Vals#`<init>`().(xp) => val param xp: Int
example/Vals#`<init>`().(yp) => var param yp: Int
example/Vals#`explicitSetter_=`(). => method explicitSetter_= (param x: Int): Unit
example/Vals#`explicitSetter_=`().(x) => param x: Int
example/Vals#`yam_=`(). => var method yam_= (param x$1: Int): Unit
example/Vals#`yam_=`().(x$1) => param x$1: Int
example/Vals#`yfm_=`(). => final var method yfm_= (param x$1: Int): Unit
example/Vals#`yfm_=`().(x$1) => param x$1: Int
example/Vals#`yim_=`(). => var method yim_= (param x$1: Int): Unit
example/Vals#`yim_=`().(x$1) => param x$1: Int
example/Vals#`ym_=`(). => var method ym_= (param x$1: Int): Unit
example/Vals#`ym_=`().(x$1) => param x$1: Int
example/Vals#`yp_=`(). => var method yp_= (param x$1: Int): Unit
example/Vals#`yp_=`().(x$1) => param x$1: Int
example/Vals#explicitSetter(). => method explicitSetter => Int
example/Vals#m(). => method m => Unit
example/Vals#p. => private[this] val method p Int
example/Vals#xam. => abstract val method xam Int
example/Vals#xfm. => final val method xfm Int
example/Vals#xim. => implicit val method xim Int
example/Vals#xlm. => private[this] val method xlm Int
example/Vals#xm. => val method xm Int
example/Vals#xp. => val method xp Int
example/Vals#xzlm. => private[this] lazy val method xzlm Int
example/Vals#xzm. => lazy val method xzm Int
example/Vals#yam(). => abstract var method yam Int
example/Vals#yfm(). => final var method yfm Int
example/Vals#yim(). => implicit var method yim Int
example/Vals#ylm(). => private[this] var method ylm Int
example/Vals#ym(). => var method ym Int
example/Vals#yp(). => var method yp Int
local0 => val local xl: Int
local1 => lazy val local xzl: Int
local2 => implicit val local xil: Int
local3 => var local yl: Int
local4 => implicit var local yil: Int

Occurrences:
[0:8..0:15): example <- example/
[2:15..2:19): Vals <- example/Vals#
[2:19..2:19): <- example/Vals#`<init>`().
[2:20..2:21): p <- example/Vals#p.
[2:23..2:26): Int -> scala/Int#
[2:32..2:34): xp <- example/Vals#xp.
[2:36..2:39): Int -> scala/Int#
[2:45..2:47): yp <- example/Vals#yp().
[2:49..2:52): Int -> scala/Int#
[3:6..3:8): xm <- example/Vals#xm.
[3:10..3:13): Int -> scala/Int#
[3:16..3:19): ??? -> scala/Predef.`???`().
[4:6..4:9): xam <- example/Vals#xam.
[4:11..4:14): Int -> scala/Int#
[5:20..5:23): xlm <- example/Vals#xlm.
[5:25..5:28): Int -> scala/Int#
[5:31..5:34): ??? -> scala/Predef.`???`().
[6:11..6:14): xzm <- example/Vals#xzm.
[6:16..6:19): Int -> scala/Int#
[6:22..6:25): ??? -> scala/Predef.`???`().
[7:25..7:29): xzlm <- example/Vals#xzlm.
[7:31..7:34): Int -> scala/Int#
[7:37..7:40): ??? -> scala/Predef.`???`().
[8:12..8:15): xfm <- example/Vals#xfm.
[8:17..8:20): Int -> scala/Int#
[8:23..8:26): ??? -> scala/Predef.`???`().
[9:15..9:18): xim <- example/Vals#xim.
[9:20..9:23): Int -> scala/Int#
[9:26..9:29): ??? -> scala/Predef.`???`().
[10:6..10:8): ym <- example/Vals#ym().
[10:10..10:13): Int -> scala/Int#
[10:16..10:19): ??? -> scala/Predef.`???`().
[11:6..11:9): yam <- example/Vals#yam().
[11:11..11:14): Int -> scala/Int#
[12:20..12:23): ylm <- example/Vals#ylm().
[12:25..12:28): Int -> scala/Int#
[12:31..12:34): ??? -> scala/Predef.`???`().
[13:20..13:35): _explicitSetter <- example/Vals#_explicitSetter().
[13:37..13:40): Int -> scala/Int#
[14:6..14:20): explicitSetter <- example/Vals#explicitSetter().
[14:23..14:38): _explicitSetter -> example/Vals#_explicitSetter().
[15:6..15:22): explicitSetter_= <- example/Vals#`explicitSetter_=`().
[15:23..15:24): x <- example/Vals#`explicitSetter_=`().(x)
[15:26..15:29): Int -> scala/Int#
[15:32..15:36): Unit -> scala/Unit#
[15:39..15:54): _explicitSetter -> example/Vals#_explicitSetter().
[15:57..15:58): x -> example/Vals#`explicitSetter_=`().(x)
[19:12..19:15): yfm <- example/Vals#yfm().
[19:17..19:20): Int -> scala/Int#
[19:23..19:26): ??? -> scala/Predef.`???`().
[20:15..20:18): yim <- example/Vals#yim().
[20:20..20:23): Int -> scala/Int#
[20:26..20:29): ??? -> scala/Predef.`???`().
[21:6..21:7): m <- example/Vals#m().
[22:8..22:10): xl <- local0
[22:12..22:15): Int -> scala/Int#
[22:18..22:21): ??? -> scala/Predef.`???`().
[23:13..23:16): xzl <- local1
[23:18..23:21): Int -> scala/Int#
[23:24..23:27): ??? -> scala/Predef.`???`().
[26:17..26:20): xil <- local2
[26:22..26:25): Int -> scala/Int#
[26:28..26:31): ??? -> scala/Predef.`???`().
[27:8..27:10): yl <- local3
[27:12..27:15): Int -> scala/Int#
[27:18..27:21): ??? -> scala/Predef.`???`().
[32:17..32:20): yil <- local4
[32:22..32:25): Int -> scala/Int#
[32:28..32:31): ??? -> scala/Predef.`???`().
[33:4..33:6): yl -> local3
[33:9..33:11): xl -> local0
[33:12..33:13): + -> scala/Int#`+`(+4).
[33:14..33:16): yl -> local3
[34:4..34:11): println -> scala/Predef.println(+1).
[34:12..34:15): xzl -> local1
[35:4..35:7): yil -> local4
[35:10..35:13): xil -> local2
[35:14..35:15): + -> scala/Int#`+`(+4).
[35:16..35:19): yil -> local4
[37:2..37:9): println -> scala/Predef.println(+1).
[37:10..37:14): xzlm -> example/Vals#xzlm.
[38:2..38:5): ylm -> example/Vals#ylm().
[38:8..38:11): xlm -> example/Vals#xlm.
[38:12..38:13): + -> scala/Int#`+`(+4).
[38:14..38:17): ylm -> example/Vals#ylm().
[41:7..41:16): ValUsages <- example/ValUsages.
[42:6..42:7): v <- example/ValUsages.v.
[42:9..42:13): Vals -> example/Vals#
[42:16..42:19): ??? -> scala/Predef.`???`().
[43:2..43:3): v -> example/ValUsages.v.
[43:4..43:6): yp -> example/Vals#`yp_=`().
[43:9..43:10): v -> example/ValUsages.v.
[43:11..43:13): xp -> example/Vals#xp.
[43:14..43:15): + -> scala/Int#`+`(+4).
[43:16..43:17): v -> example/ValUsages.v.
[43:18..43:20): yp -> example/Vals#yp().
[44:2..44:3): v -> example/ValUsages.v.
[44:4..44:6): ym -> example/Vals#`ym_=`().
[44:9..44:10): v -> example/ValUsages.v.
[44:11..44:13): xm -> example/Vals#xm.
[44:14..44:15): + -> scala/Int#`+`(+4).
[44:16..44:17): v -> example/ValUsages.v.
[44:18..44:20): ym -> example/Vals#ym().
[45:2..45:3): v -> example/ValUsages.v.
[45:4..45:7): yam -> example/Vals#`yam_=`().
[45:10..45:11): v -> example/ValUsages.v.
[45:12..45:15): xam -> example/Vals#xam.
[45:16..45:17): + -> scala/Int#`+`(+4).
[45:18..45:19): v -> example/ValUsages.v.
[45:20..45:23): yam -> example/Vals#yam().
[46:2..46:9): println -> scala/Predef.println(+1).
[46:10..46:11): v -> example/ValUsages.v.
[46:12..46:15): xzm -> example/Vals#xzm.
[47:2..47:3): v -> example/ValUsages.v.
[47:4..47:7): yfm -> example/Vals#`yfm_=`().
[47:10..47:11): v -> example/ValUsages.v.
[47:12..47:15): xfm -> example/Vals#xfm.
[47:16..47:17): + -> scala/Int#`+`(+4).
[47:18..47:19): v -> example/ValUsages.v.
[47:20..47:23): yfm -> example/Vals#yfm().
[48:2..48:3): v -> example/ValUsages.v.
[48:4..48:7): yim -> example/Vals#`yim_=`().
[48:10..48:11): v -> example/ValUsages.v.
[48:12..48:15): xim -> example/Vals#xim.
[48:16..48:17): + -> scala/Int#`+`(+4).
[48:18..48:19): v -> example/ValUsages.v.
[48:20..48:23): yim -> example/Vals#yim().
[49:2..49:3): v -> example/ValUsages.v.
[49:3..49:18): .explicitSetter -> example/Vals#`explicitSetter_=`().

expect/Vararg.scala
-------------------

Summary:
Schema => SemanticDB v4
Uri => Vararg.scala
Text => empty
Language => Scala
Symbols => 6 entries
Occurrences => 11 entries

Symbols:
example/Vararg# => class Vararg extends Object { self: Vararg => +3 decls }
example/Vararg#`<init>`(). => primary ctor <init> (): Vararg
example/Vararg#add1(). => method add1 (param a: Int*): Unit
example/Vararg#add1().(a) => param a: Int*
example/Vararg#add2(). => method add2 (param a: Seq[Int]*): Unit
example/Vararg#add2().(a) => param a: Seq[Int]*

Occurrences:
[0:8..0:15): example <- example/
[2:6..2:12): Vararg <- example/Vararg#
[3:2..3:2): <- example/Vararg#`<init>`().
[3:6..3:10): add1 <- example/Vararg#add1().
[3:11..3:12): a <- example/Vararg#add1().(a)
[3:14..3:17): Int -> scala/Int#
[4:6..4:10): add2 <- example/Vararg#add2().
[4:11..4:12): a <- example/Vararg#add2().(a)
[4:14..4:17): Seq -> scala/package.Seq#
[4:18..4:21): Int -> scala/Int#
[4:26..4:30): Unit -> scala/Unit#

expect/dep-match.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => dep-match.scala
Text => empty
Language => Scala
Symbols => 8 entries
Occurrences => 18 entries

Symbols:
_empty_/Test_depmatch. => final object Test_depmatch extends Object { self: Test_depmatch.type => +4 decls }
_empty_/Test_depmatch.Bar# => type Bar [typeparam T ] = T match { Unit => Unit }
_empty_/Test_depmatch.Bar#[T] => typeparam T 
_empty_/Test_depmatch.Foo# => type Foo  = Int { type U  }
_empty_/Test_depmatch.baz(). => inline macro baz (param foo: Foo): Unit
_empty_/Test_depmatch.baz().(foo) => param foo: Foo
local0 => type U 
local1 => val local v: Bar[foo.U]

Occurrences:
[0:7..0:20): Test_depmatch <- _empty_/Test_depmatch.
[1:7..1:10): Foo <- _empty_/Test_depmatch.Foo#
[1:13..1:16): Int -> scala/Int#
[1:24..1:25): U <- local0
[2:7..2:10): Bar <- _empty_/Test_depmatch.Bar#
[2:11..2:12): T <- _empty_/Test_depmatch.Bar#[T]
[2:16..2:17): T -> _empty_/Test_depmatch.Bar#[T]
[3:9..3:13): Unit -> scala/Unit#
[3:17..3:21): Unit -> scala/Unit#
[5:13..5:16): baz <- _empty_/Test_depmatch.baz().
[5:17..5:20): foo <- _empty_/Test_depmatch.baz().(foo)
[5:22..5:25): Foo -> _empty_/Test_depmatch.Foo#
[5:28..5:32): Unit -> scala/Unit#
[6:8..6:9): v <- local1
[6:11..6:14): Bar -> _empty_/Test_depmatch.Bar#
[6:15..6:18): foo -> _empty_/Test_depmatch.baz().(foo)
[6:19..6:20): U -> local0
[6:24..6:27): ??? -> scala/Predef.`???`().

expect/example-dir/FileInDir.scala
----------------------------------

Summary:
Schema => SemanticDB v4
Uri => example-dir/FileInDir.scala
Text => empty
Language => Scala
Symbols => 2 entries
Occurrences => 3 entries

Symbols:
example/FileInDir# => class FileInDir extends Object { self: FileInDir => +1 decls }
example/FileInDir#`<init>`(). => primary ctor <init> (): FileInDir

Occurrences:
[0:8..0:15): example <- example/
[2:0..2:0): <- example/FileInDir#`<init>`().
[2:6..2:15): FileInDir <- example/FileInDir#

expect/exports-example-Codec.scala
----------------------------------

Summary:
Schema => SemanticDB v4
Uri => exports-example-Codec.scala
Text => empty
Language => Scala
Symbols => 21 entries
Occurrences => 33 entries

Symbols:
exports/example/Codec# => trait Codec [typeparam T ] extends Object with Decoder[T] with Encoder[T] { self: Codec[T] => +6 decls }
exports/example/Codec#[T] => typeparam T 
exports/example/Codec#`<init>`(). => primary ctor <init> [typeparam T ](param decode: Decoder[T], param encode: Encoder[T]): Codec[T]
exports/example/Codec#`<init>`().(decode) => param decode: Decoder[T]
exports/example/Codec#`<init>`().(encode) => param encode: Encoder[T]
exports/example/Codec#decode(). => final method decode (param a: Array[Byte]): T <: exports/example/Decoder#decode().
exports/example/Codec#decode().(a) => param a: Array[Byte]
exports/example/Codec#decode. => private[this] val method decode Decoder[T]
exports/example/Codec#encode(). => final method encode (param t: T): Array[Byte] <: exports/example/Encoder#encode().
exports/example/Codec#encode().(t) => param t: T
exports/example/Codec#encode. => private[this] val method encode Encoder[T]
exports/example/Decoder# => trait Decoder [covariant typeparam T ] extends Object { self: Decoder[T] => +3 decls }
exports/example/Decoder#[T] => covariant typeparam T 
exports/example/Decoder#`<init>`(). => primary ctor <init> [covariant typeparam T ](): Decoder[T]
exports/example/Decoder#decode(). => abstract method decode (param a: Array[Byte]): T
exports/example/Decoder#decode().(a) => param a: Array[Byte]
exports/example/Encoder# => trait Encoder [contravariant typeparam T ] extends Object { self: Encoder[T] => +3 decls }
exports/example/Encoder#[T] => contravariant typeparam T 
exports/example/Encoder#`<init>`(). => primary ctor <init> [contravariant typeparam T ](): Encoder[T]
exports/example/Encoder#encode(). => abstract method encode (param t: T): Array[Byte]
exports/example/Encoder#encode().(t) => param t: T

Occurrences:
[0:8..0:15): exports -> exports/
[0:16..0:23): example <- exports/example/
[2:6..2:13): Decoder <- exports/example/Decoder#
[2:13..2:13): <- exports/example/Decoder#`<init>`().
[2:15..2:16): T <- exports/example/Decoder#[T]
[3:6..3:12): decode <- exports/example/Decoder#decode().
[3:13..3:14): a <- exports/example/Decoder#decode().(a)
[3:16..3:21): Array -> scala/Array#
[3:22..3:26): Byte -> scala/Byte#
[3:30..3:31): T -> exports/example/Decoder#[T]
[6:6..6:13): Encoder <- exports/example/Encoder#
[6:13..6:13): <- exports/example/Encoder#`<init>`().
[6:15..6:16): T <- exports/example/Encoder#[T]
[7:6..7:12): encode <- exports/example/Encoder#encode().
[7:13..7:14): t <- exports/example/Encoder#encode().(t)
[7:16..7:17): T -> exports/example/Encoder#[T]
[7:20..7:25): Array -> scala/Array#
[7:26..7:30): Byte -> scala/Byte#
[10:6..10:11): Codec <- exports/example/Codec#
[10:11..10:11): <- exports/example/Codec#`<init>`().
[10:12..10:13): T <- exports/example/Codec#[T]
[10:15..10:21): decode <- exports/example/Codec#decode.
[10:23..10:30): Decoder -> exports/example/Decoder#
[10:31..10:32): T -> exports/example/Codec#[T]
[10:35..10:41): encode <- exports/example/Codec#encode.
[10:43..10:50): Encoder -> exports/example/Encoder#
[10:51..10:52): T -> exports/example/Codec#[T]
[11:10..11:17): Decoder -> exports/example/Decoder#
[11:18..11:19): T -> exports/example/Codec#[T]
[11:26..11:33): Encoder -> exports/example/Encoder#
[11:34..11:35): T -> exports/example/Codec#[T]
[12:9..12:15): decode -> exports/example/Codec#decode.
[13:9..13:15): encode -> exports/example/Codec#encode.

expect/exports-package.scala
----------------------------

Summary:
Schema => SemanticDB v4
Uri => exports-package.scala
Text => empty
Language => Scala
Symbols => 7 entries
Occurrences => 5 entries

Symbols:
exports/`exports-package$package`. => final package object exports extends Object { self: exports.type => +4 decls }
exports/`exports-package$package`.Codec# => final type Codec [typeparam T ] = Codec[T]
exports/`exports-package$package`.Codec#[T] => typeparam T 
exports/`exports-package$package`.Decoder# => final type Decoder [typeparam T ] = Decoder[T]
exports/`exports-package$package`.Decoder#[T] => typeparam T 
exports/`exports-package$package`.Encoder# => final type Encoder [typeparam T ] = Encoder[T]
exports/`exports-package$package`.Encoder#[T] => typeparam T 

Occurrences:
[0:8..0:15): exports <- exports/
[2:7..2:14): example -> exports/example/
[2:16..2:23): Decoder <- exports/`exports-package$package`.Decoder#
[2:25..2:32): Encoder <- exports/`exports-package$package`.Encoder#
[2:34..2:39): Codec <- exports/`exports-package$package`.Codec#

expect/filename with spaces.scala
---------------------------------

Summary:
Schema => SemanticDB v4
Uri => filename%20with%20spaces.scala
Text => empty
Language => Scala
Symbols => 2 entries
Occurrences => 3 entries

Symbols:
example/FilenameWithSpaces# => class FilenameWithSpaces extends Object { self: FilenameWithSpaces => +1 decls }
example/FilenameWithSpaces#`<init>`(). => primary ctor <init> (): FilenameWithSpaces

Occurrences:
[0:8..0:15): example <- example/
[2:0..2:0): <- example/FilenameWithSpaces#`<init>`().
[2:6..2:24): FilenameWithSpaces <- example/FilenameWithSpaces#

expect/hk.scala
---------------

Summary:
Schema => SemanticDB v4
Uri => hk.scala
Text => empty
Language => Scala
Symbols => 30 entries
Occurrences => 54 entries

Symbols:
hk/EitherMonad# => class EitherMonad [typeparam T ] extends Object with Monad[[E] =>> Either[T, E]] { self: EitherMonad[T] => +2 decls }
hk/EitherMonad#[E] => typeparam E 
hk/EitherMonad#[T] => typeparam T 
hk/EitherMonad#`<init>`(). => primary ctor <init> [typeparam T ](): EitherMonad[T]
hk/EitherMonad#`<init>`().[E] => typeparam E 
hk/Monad# => trait Monad [typeparam M [type _ ]] extends Object { self: Monad[M] => +4 decls }
hk/Monad#[M] => typeparam M [type _ ]
hk/Monad#[M][_] => type _ 
hk/Monad#`<init>`(). => primary ctor <init> [typeparam M [type _ ]](): Monad[M]
hk/Monad#flatMap(). => method flatMap [typeparam A , typeparam B ](param m: M[A])(param f: Function1[A, M[B]]): M[B]
hk/Monad#flatMap().(f) => param f: Function1[A, M[B]]
hk/Monad#flatMap().(m) => param m: M[A]
hk/Monad#flatMap().[A] => typeparam A 
hk/Monad#flatMap().[B] => typeparam B 
hk/Monad#pure(). => method pure [typeparam A ](param a: A): M[A]
hk/Monad#pure().(a) => param a: A
hk/Monad#pure().[A] => typeparam A 
hk/hk$package. => final package object hk extends Object { self: hk.type => +5 decls }
hk/hk$package.Id# => type Id [typeparam A ] = A
hk/hk$package.Id#[A] => typeparam A 
hk/hk$package.MapEither# => type MapEither [typeparam K ] = [L] =>> [R] =>> Map[K, Either[L, R]]
hk/hk$package.MapEither#[K] => typeparam K 
hk/hk$package.MapEither#[L] => typeparam L 
hk/hk$package.MapEither#[R] => typeparam R 
hk/hk$package.MapKV# => type MapKV [typeparam K ] = [V] =>> Map[K, V]
hk/hk$package.MapKV#[K] => typeparam K 
hk/hk$package.MapKV#[V] => typeparam V 
hk/hk$package.MapV# => type MapV [type _ ] = [V] =>> Map[String, V]
hk/hk$package.MapV#[V] => typeparam V 
hk/hk$package.MapV#[_] => type _ 

Occurrences:
[0:8..0:10): hk <- hk/
[2:6..2:11): Monad <- hk/Monad#
[2:11..2:11): <- hk/Monad#`<init>`().
[2:12..2:13): M <- hk/Monad#[M]
[3:6..3:10): pure <- hk/Monad#pure().
[3:11..3:12): A <- hk/Monad#pure().[A]
[3:14..3:15): a <- hk/Monad#pure().(a)
[3:17..3:18): A -> hk/Monad#pure().[A]
[3:21..3:22): M -> hk/Monad#[M]
[3:23..3:24): A -> hk/Monad#pure().[A]
[3:28..3:31): ??? -> scala/Predef.`???`().
[4:6..4:13): flatMap <- hk/Monad#flatMap().
[4:14..4:15): A <- hk/Monad#flatMap().[A]
[4:17..4:18): B <- hk/Monad#flatMap().[B]
[4:20..4:21): m <- hk/Monad#flatMap().(m)
[4:23..4:24): M -> hk/Monad#[M]
[4:25..4:26): A -> hk/Monad#flatMap().[A]
[4:29..4:30): f <- hk/Monad#flatMap().(f)
[4:32..4:33): A -> hk/Monad#flatMap().[A]
[4:37..4:38): M -> hk/Monad#[M]
[4:39..4:40): B -> hk/Monad#flatMap().[B]
[4:44..4:45): M -> hk/Monad#[M]
[4:46..4:47): B -> hk/Monad#flatMap().[B]
[4:51..4:54): ??? -> scala/Predef.`???`().
[7:6..7:17): EitherMonad <- hk/EitherMonad#
[7:17..7:17): <- hk/EitherMonad#`<init>`().
[7:18..7:19): T <- hk/EitherMonad#[T]
[7:29..7:34): Monad -> hk/Monad#
[7:36..7:37): E <- hk/EitherMonad#`<init>`().[E]
[7:43..7:49): Either -> scala/package.Either#
[7:50..7:51): T -> hk/EitherMonad#[T]
[10:5..10:10): MapKV <- hk/hk$package.MapKV#
[10:14..10:15): K <- hk/hk$package.MapKV#[K]
[10:22..10:23): V <- hk/hk$package.MapKV#[V]
[10:29..10:32): Map -> scala/Predef.Map#
[10:33..10:34): K -> hk/hk$package.MapKV#[K]
[10:35..10:36): V -> hk/hk$package.MapKV#[V]
[12:5..12:9): MapV <- hk/hk$package.MapV#
[12:21..12:22): V <- hk/hk$package.MapV#[V]
[12:28..12:31): Map -> scala/Predef.Map#
[12:32..12:38): String -> scala/Predef.String#
[12:40..12:41): V -> hk/hk$package.MapV#[V]
[14:5..14:14): MapEither <- hk/hk$package.MapEither#
[14:18..14:19): K <- hk/hk$package.MapEither#[K]
[14:26..14:27): L <- hk/hk$package.MapEither#[L]
[14:34..14:35): R <- hk/hk$package.MapEither#[R]
[14:41..14:44): Map -> scala/Predef.Map#
[14:45..14:46): K -> hk/hk$package.MapEither#[K]
[14:48..14:54): Either -> scala/package.Either#
[14:55..14:56): L -> hk/hk$package.MapEither#[L]
[14:58..14:59): R -> hk/hk$package.MapEither#[R]
[16:5..16:7): Id <- hk/hk$package.Id#
[16:8..16:9): A <- hk/hk$package.Id#[A]
[16:13..16:14): A -> hk/hk$package.Id#[A]

expect/i5854.scala
------------------

Summary:
Schema => SemanticDB v4
Uri => i5854.scala
Text => empty
Language => Scala
Symbols => 6 entries
Occurrences => 17 entries

Symbols:
i5854/B# => class B extends Object { self: B => +4 decls }
i5854/B#`<init>`(). => primary ctor <init> (): B
i5854/B#a. => val method a String
i5854/B#b. => val method b Object { type A  >: Any <: Nothing }
i5854/B#loop(). => method loop (): Nothing
local0 => type A  >: Any <: Nothing

Occurrences:
[0:8..0:13): i5854 <- i5854/
[2:6..2:7): B <- i5854/B#
[7:2..7:2): <- i5854/B#`<init>`().
[7:6..7:7): a <- i5854/B#a.
[7:9..7:15): String -> scala/Predef.String#
[7:24..7:27): Any -> scala/Any#
[7:30..7:31): b -> i5854/B#b.
[7:36..7:43): Nothing -> scala/Nothing#
[7:46..7:52): String -> scala/Predef.String#
[8:6..8:7): b <- i5854/B#b.
[8:16..8:17): A <- local0
[8:21..8:24): Any -> scala/Any#
[8:28..8:35): Nothing -> scala/Nothing#
[8:40..8:44): loop -> i5854/B#loop().
[9:6..9:10): loop <- i5854/B#loop().
[9:14..9:21): Nothing -> scala/Nothing#
[9:24..9:28): loop -> i5854/B#loop().

expect/i9727.scala
------------------

Summary:
Schema => SemanticDB v4
Uri => i9727.scala
Text => empty
Language => Scala
Symbols => 7 entries
Occurrences => 9 entries

Symbols:
i9727/Test# => class Test extends Object { self: Test => +2 decls }
i9727/Test#`<init>`(). => primary ctor <init> (param a: Int): Test
i9727/Test#`<init>`().(a) => param a: Int
i9727/Test#a. => private[this] val method a Int
i9727/i9727$package. => final package object i9727 extends Object { self: i9727.type => +3 decls }
i9727/i9727$package.a. => val method a Test
i9727/i9727$package.b. => val method b Test

Occurrences:
[0:8..0:13): i9727 <- i9727/
[2:6..2:10): Test <- i9727/Test#
[2:10..2:10): <- i9727/Test#`<init>`().
[2:11..2:12): a <- i9727/Test#a.
[2:14..2:17): Int -> scala/Int#
[3:4..3:5): a <- i9727/i9727$package.a.
[3:12..3:16): Test -> i9727/Test#
[4:4..4:5): b <- i9727/i9727$package.b.
[4:12..4:16): Test -> i9727/Test#

expect/i9782.scala
------------------

Summary:
Schema => SemanticDB v4
Uri => i9782.scala
Text => empty
Language => Scala
Symbols => 24 entries
Occurrences => 63 entries

Symbols:
_empty_/Copy# => trait Copy [typeparam In  <: Txn[In], typeparam Out  <: Txn[Out]] extends Object { self: Copy[In, Out] => +5 decls }
_empty_/Copy#[In] => typeparam In  <: Txn[In]
_empty_/Copy#[Out] => typeparam Out  <: Txn[Out]
_empty_/Copy#`<init>`(). => primary ctor <init> [typeparam In  <: Txn[In], typeparam Out  <: Txn[Out]](): Copy[In, Out]
_empty_/Copy#apply(). => method apply [typeparam Repr [typeparam ~  <: Txn[~]] <: Elem[~]](param in: Repr[In]): Repr[Out]
_empty_/Copy#apply().(in) => param in: Repr[In]
_empty_/Copy#apply().[Repr] => typeparam Repr [typeparam ~  <: Txn[~]] <: Elem[~]
_empty_/Copy#apply().[Repr][`~`] => typeparam ~  <: Txn[~]
_empty_/Copy#copyImpl(). => abstract method copyImpl [typeparam Repr [typeparam ~  <: Txn[~]] <: Elem[~]](param in: Repr[In]): Repr[Out]
_empty_/Copy#copyImpl().(in) => param in: Repr[In]
_empty_/Copy#copyImpl().[Repr] => typeparam Repr [typeparam ~  <: Txn[~]] <: Elem[~]
_empty_/Copy#copyImpl().[Repr][`~`] => typeparam ~  <: Txn[~]
_empty_/Elem# => trait Elem [typeparam T  <: Txn[T]] extends Object { self: Elem[T] => +2 decls }
_empty_/Elem#[T] => typeparam T  <: Txn[T]
_empty_/Elem#`<init>`(). => primary ctor <init> [typeparam T  <: Txn[T]](): Elem[T]
_empty_/Obj# => trait Obj [typeparam T  <: Txn[T]] extends Object with Elem[T] { self: Obj[T] => +2 decls }
_empty_/Obj#[T] => typeparam T  <: Txn[T]
_empty_/Obj#`<init>`(). => primary ctor <init> [typeparam T  <: Txn[T]](): Obj[T]
_empty_/Txn# => trait Txn [typeparam T  <: Txn[T]] extends Object { self: Txn[T] => +2 decls }
_empty_/Txn#[T] => typeparam T  <: Txn[T]
_empty_/Txn#`<init>`(). => primary ctor <init> [typeparam T  <: Txn[T]](): Txn[T]
local0 => val local out: Repr[Out]
local1 => val local inObj: Repr[In] & Obj[In]
local2 => val local outObj: Repr[Out] & Obj[Out]

Occurrences:
[1:6..1:9): Txn <- _empty_/Txn#
[1:9..1:9): <- _empty_/Txn#`<init>`().
[1:10..1:11): T <- _empty_/Txn#[T]
[1:15..1:18): Txn -> _empty_/Txn#
[1:19..1:20): T -> _empty_/Txn#[T]
[3:6..3:10): Elem <- _empty_/Elem#
[3:10..3:10): <- _empty_/Elem#`<init>`().
[3:11..3:12): T <- _empty_/Elem#[T]
[3:16..3:19): Txn -> _empty_/Txn#
[3:20..3:21): T -> _empty_/Elem#[T]
[5:6..5:9): Obj <- _empty_/Obj#
[5:9..5:9): <- _empty_/Obj#`<init>`().
[5:10..5:11): T <- _empty_/Obj#[T]
[5:15..5:18): Txn -> _empty_/Txn#
[5:19..5:20): T -> _empty_/Obj#[T]
[5:31..5:35): Elem -> _empty_/Elem#
[5:36..5:37): T -> _empty_/Obj#[T]
[7:6..7:10): Copy <- _empty_/Copy#
[7:10..7:10): <- _empty_/Copy#`<init>`().
[7:11..7:13): In <- _empty_/Copy#[In]
[7:17..7:20): Txn -> _empty_/Txn#
[7:21..7:23): In -> _empty_/Copy#[In]
[7:26..7:29): Out <- _empty_/Copy#[Out]
[7:33..7:36): Txn -> _empty_/Txn#
[7:37..7:40): Out -> _empty_/Copy#[Out]
[8:6..8:14): copyImpl <- _empty_/Copy#copyImpl().
[8:15..8:19): Repr <- _empty_/Copy#copyImpl().[Repr]
[8:20..8:21): ~ <- _empty_/Copy#copyImpl().[Repr][`~`]
[8:25..8:28): Txn -> _empty_/Txn#
[8:29..8:30): ~ -> _empty_/Copy#copyImpl().[Repr][`~`]
[8:36..8:40): Elem -> _empty_/Elem#
[8:41..8:42): ~ -> _empty_/Copy#copyImpl().[Repr][`~`]
[8:45..8:47): in <- _empty_/Copy#copyImpl().(in)
[8:49..8:53): Repr -> _empty_/Copy#copyImpl().[Repr]
[8:54..8:56): In -> _empty_/Copy#[In]
[8:60..8:64): Repr -> _empty_/Copy#copyImpl().[Repr]
[8:65..8:68): Out -> _empty_/Copy#[Out]
[10:6..10:11): apply <- _empty_/Copy#apply().
[10:12..10:16): Repr <- _empty_/Copy#apply().[Repr]
[10:17..10:18): ~ <- _empty_/Copy#apply().[Repr][`~`]
[10:22..10:25): Txn -> _empty_/Txn#
[10:26..10:27): ~ -> _empty_/Copy#apply().[Repr][`~`]
[10:33..10:37): Elem -> _empty_/Elem#
[10:38..10:39): ~ -> _empty_/Copy#apply().[Repr][`~`]
[10:42..10:44): in <- _empty_/Copy#apply().(in)
[10:46..10:50): Repr -> _empty_/Copy#apply().[Repr]
[10:51..10:53): In -> _empty_/Copy#[In]
[10:57..10:61): Repr -> _empty_/Copy#apply().[Repr]
[10:62..10:65): Out -> _empty_/Copy#[Out]
[11:8..11:11): out <- local0
[11:14..11:22): copyImpl -> _empty_/Copy#copyImpl().
[11:23..11:27): Repr -> _empty_/Copy#apply().[Repr]
[11:29..11:31): in -> _empty_/Copy#apply().(in)
[12:5..12:7): in -> _empty_/Copy#apply().(in)
[12:9..12:12): out -> local0
[13:12..13:17): inObj <- local1
[13:19..13:22): Obj -> _empty_/Obj#
[13:23..13:25): In -> _empty_/Copy#[In]
[13:28..13:34): outObj <- local2
[13:36..13:39): Obj -> _empty_/Obj#
[13:40..13:43): Out -> _empty_/Copy#[Out]
[14:8..14:15): println -> scala/Predef.println(+1).
[17:4..17:7): out -> local0

expect/inlineconsume.scala
--------------------------

Summary:
Schema => SemanticDB v4
Uri => inlineconsume.scala
Text => empty
Language => Scala
Symbols => 3 entries
Occurrences => 9 entries

Symbols:
inlineconsume/Foo# => class Foo extends Object { self: Foo => +2 decls }
inlineconsume/Foo#`<init>`(). => primary ctor <init> (): Foo
inlineconsume/Foo#test(). => method test => Unit

Occurrences:
[0:8..0:21): inlineconsume <- inlineconsume/
[2:7..2:17): inlinedefs -> inlinedefs/
[2:18..2:28): FakePredef -> inlinedefs/FakePredef.
[2:29..2:35): assert -> inlinedefs/FakePredef.assert().
[4:6..4:9): Foo <- inlineconsume/Foo#
[5:2..5:2): <- inlineconsume/Foo#`<init>`().
[5:6..5:10): test <- inlineconsume/Foo#test().
[5:13..5:19): assert -> inlinedefs/FakePredef.assert().
[5:22..5:23): > -> scala/Int#`>`(+3).

expect/inlinedefs.scala
-----------------------

Summary:
Schema => SemanticDB v4
Uri => inlinedefs.scala
Text => empty
Language => Scala
Symbols => 3 entries
Occurrences => 10 entries

Symbols:
inlinedefs/FakePredef. => final object FakePredef extends Object { self: FakePredef.type => +2 decls }
inlinedefs/FakePredef.assert(). => final inline transparent macro assert (inline param assertion: Boolean): Unit
inlinedefs/FakePredef.assert().(assertion) => inline param assertion: Boolean

Occurrences:
[0:8..0:18): inlinedefs <- inlinedefs/
[2:7..2:17): FakePredef <- inlinedefs/FakePredef.
[13:31..13:37): assert <- inlinedefs/FakePredef.assert().
[13:45..13:54): assertion <- inlinedefs/FakePredef.assert().(assertion)
[13:56..13:63): Boolean -> scala/Boolean#
[13:66..13:70): Unit -> scala/Unit#
[14:9..14:18): assertion -> inlinedefs/FakePredef.assert().(assertion)
[15:16..15:20): java -> java/
[15:21..15:25): lang -> java/lang/
[15:26..15:40): AssertionError -> java/lang/AssertionError#

expect/local-file.scala
-----------------------

Summary:
Schema => SemanticDB v4
Uri => local-file.scala
Text => empty
Language => Scala
Symbols => 3 entries
Occurrences => 7 entries
Synthetics => 1 entries

Symbols:
example/`local-file`# => class local-file extends Object { self: local-file => +1 decls }
example/`local-file`#`<init>`(). => primary ctor <init> (): local-file
local0 => val local local: Int

Occurrences:
[0:8..0:15): example <- example/
[2:7..2:17): local-file <- example/`local-file`#
[3:2..3:9): locally -> scala/Predef.locally().
[3:2..3:2): <- example/`local-file`#`<init>`().
[4:8..4:13): local <- local0
[5:4..5:9): local -> local0
[5:10..5:11): + -> scala/Int#`+`(+4).

Synthetics:
[3:2..3:9):locally => *[Int]

expect/nullary.scala
--------------------

Summary:
Schema => SemanticDB v4
Uri => nullary.scala
Text => empty
Language => Scala
Symbols => 17 entries
Occurrences => 31 entries
Synthetics => 1 entries

Symbols:
_empty_/Concrete# => class Concrete extends NullaryTest[Int, List] { self: Concrete => +3 decls }
_empty_/Concrete#`<init>`(). => primary ctor <init> (): Concrete
_empty_/Concrete#nullary2(). => method nullary2 => Int <: _empty_/NullaryTest#nullary2().
_empty_/Concrete#nullary3(). => method nullary3 => List[Int] <: _empty_/NullaryTest#nullary3().
_empty_/NullaryTest# => abstract class NullaryTest [typeparam T , typeparam m [typeparam s ]] extends Object { self: NullaryTest[T, m] => +9 decls }
_empty_/NullaryTest#[T] => typeparam T 
_empty_/NullaryTest#[m] => typeparam m [typeparam s ]
_empty_/NullaryTest#[m][s] => typeparam s 
_empty_/NullaryTest#`<init>`(). => primary ctor <init> [typeparam T , typeparam m [typeparam s ]](): NullaryTest[T, m]
_empty_/NullaryTest#`<init>`().[m][s] => typeparam s 
_empty_/NullaryTest#nullary(). => method nullary => String
_empty_/NullaryTest#nullary2(). => abstract method nullary2 => T
_empty_/NullaryTest#nullary3(). => abstract method nullary3 => m[T]
_empty_/NullaryTest#x. => val method x String
_empty_/NullaryTest#x2. => val method x2 T
_empty_/NullaryTest#x3. => val method x3 m[T]
_empty_/test. => final object test extends Object { self: test.type => +1 decls }

Occurrences:
[0:15..0:26): NullaryTest <- _empty_/NullaryTest#
[0:26..0:26): <- _empty_/NullaryTest#`<init>`().
[0:27..0:28): T <- _empty_/NullaryTest#[T]
[0:30..0:31): m <- _empty_/NullaryTest#[m]
[0:32..0:33): s <- _empty_/NullaryTest#`<init>`().[m][s]
[1:6..1:13): nullary <- _empty_/NullaryTest#nullary().
[1:15..1:21): String -> scala/Predef.String#
[2:6..2:7): x <- _empty_/NullaryTest#x.
[2:10..2:17): nullary -> _empty_/NullaryTest#nullary().
[4:6..4:14): nullary2 <- _empty_/NullaryTest#nullary2().
[4:16..4:17): T -> _empty_/NullaryTest#[T]
[5:6..5:8): x2 <- _empty_/NullaryTest#x2.
[5:11..5:19): nullary2 -> _empty_/NullaryTest#nullary2().
[7:6..7:14): nullary3 <- _empty_/NullaryTest#nullary3().
[7:16..7:17): m -> _empty_/NullaryTest#[m]
[7:18..7:19): T -> _empty_/NullaryTest#[T]
[8:6..8:8): x3 <- _empty_/NullaryTest#x3.
[8:11..8:19): nullary3 -> _empty_/NullaryTest#nullary3().
[11:6..11:14): Concrete <- _empty_/Concrete#
[11:23..11:34): NullaryTest -> _empty_/NullaryTest#
[11:23..11:23): <- _empty_/Concrete#`<init>`().
[11:35..11:38): Int -> scala/Int#
[11:40..11:44): List -> scala/package.List#
[12:6..12:14): nullary2 <- _empty_/Concrete#nullary2().
[13:6..13:14): nullary3 <- _empty_/Concrete#nullary3().
[13:17..13:21): List -> scala/package.List.
[16:7..16:11): test <- _empty_/test.
[17:7..17:15): Concrete -> _empty_/Concrete#
[17:17..17:25): nullary2 -> _empty_/Concrete#nullary2().
[18:7..18:15): Concrete -> _empty_/Concrete#
[18:17..18:25): nullary3 -> _empty_/Concrete#nullary3().

Synthetics:
[13:17..13:21):List => *.apply[Int]

expect/recursion.scala
----------------------

Summary:
Schema => SemanticDB v4
Uri => recursion.scala
Text => empty
Language => Scala
Symbols => 36 entries
Occurrences => 48 entries

Symbols:
local0 => type N$1  <: Nat
local1 => val local p: N$1
local2 => type N$2  <: Nat
local3 => val local p: N$2
local4 => val local Nat_this: Zero.type
local5 => val local Nat_this: Succ[Zero.type]
local6 => val local Nat_this: Succ[_] forSome { type _  <: Succ[Zero.type] }
recursion/Nats. => final object Nats extends Object { self: Nats.type => +9 decls }
recursion/Nats.Nat# => sealed trait Nat extends Object { self: Nat => +3 decls }
recursion/Nats.Nat#`++`(). => inline transparent macro ++ => Succ[Nat.this.type]
recursion/Nats.Nat#`+`(). => inline transparent macro + (inline param that: Nat): Nat
recursion/Nats.Nat#`+`().(that) => inline param that: Nat
recursion/Nats.Nat#`<init>`(). => primary ctor <init> (): Nat
recursion/Nats.Succ# => case class Succ [typeparam N  <: Nat] extends Object with Nat with Product with Serializable { self: Succ[N] => +6 decls }
recursion/Nats.Succ#[N] => typeparam N  <: Nat
recursion/Nats.Succ#_1(). => method _1 => N
recursion/Nats.Succ#`<init>`(). => primary ctor <init> [typeparam N  <: Nat](val param p: N): Succ[N]
recursion/Nats.Succ#`<init>`().(p) => val param p: N
recursion/Nats.Succ#copy$default$1(). => method copy$default$1 [typeparam N  <: Nat]: N
recursion/Nats.Succ#copy$default$1().[N] => typeparam N  <: Nat
recursion/Nats.Succ#copy(). => method copy [typeparam N  <: Nat](param p: N): Succ[N]
recursion/Nats.Succ#copy().(p) => param p: N
recursion/Nats.Succ#copy().[N] => typeparam N  <: Nat
recursion/Nats.Succ#p. => val method p N
recursion/Nats.Succ. => final object Succ extends Object { self: Succ.type => +4 decls }
recursion/Nats.Succ.apply(). => method apply [typeparam N  <: Nat](param p: N): Succ[N]
recursion/Nats.Succ.apply().(p) => param p: N
recursion/Nats.Succ.apply().[N] => typeparam N  <: Nat
recursion/Nats.Succ.toString(). => method toString => String <: scala/Any#toString().
recursion/Nats.Succ.unapply(). => method unapply [typeparam N  <: Nat](param x$1: Succ[N]): Succ[N]
recursion/Nats.Succ.unapply().(x$1) => param x$1: Succ[N]
recursion/Nats.Succ.unapply().[N] => typeparam N  <: Nat
recursion/Nats.Zero. => final case object Zero extends Object with Nat with Product with Serializable { self: Zero.type => +1 decls }
recursion/Nats.j31. => val method j31 Int
recursion/Nats.toIntg(). => inline transparent macro toIntg (inline param n: Nat): Int
recursion/Nats.toIntg().(n) => inline param n: Nat

Occurrences:
[1:8..1:17): recursion <- recursion/
[3:7..3:11): Nats <- recursion/Nats.
[4:15..4:18): Nat <- recursion/Nats.Nat#
[5:4..5:4): <- recursion/Nats.Nat#`<init>`().
[5:27..5:29): ++ <- recursion/Nats.Nat#`++`().
[5:32..5:36): Succ -> recursion/Nats.Succ#
[5:50..5:54): Succ -> recursion/Nats.Succ.
[7:27..7:28): + <- recursion/Nats.Nat#`+`().
[7:36..7:40): that <- recursion/Nats.Nat#`+`().(that)
[7:42..7:45): Nat -> recursion/Nats.Nat#
[7:48..7:51): Nat -> recursion/Nats.Nat#
[9:13..9:17): Zero -> recursion/Nats.Zero.
[9:24..9:28): that -> recursion/Nats.Nat#`+`().(that)
[10:13..10:17): Succ -> recursion/Nats.Succ.
[10:18..10:19): p <- local1
[10:24..10:25): p -> local1
[10:26..10:27): + -> recursion/Nats.Nat#`+`().
[10:28..10:32): that -> recursion/Nats.Nat#`+`().(that)
[10:33..10:35): ++ -> recursion/Nats.Nat#`++`().
[14:14..14:18): Zero <- recursion/Nats.Zero.
[14:27..14:30): Nat -> recursion/Nats.Nat#
[15:13..15:17): Succ <- recursion/Nats.Succ#
[15:17..15:17): <- recursion/Nats.Succ#`<init>`().
[15:18..15:19): N <- recursion/Nats.Succ#[N]
[15:23..15:26): Nat -> recursion/Nats.Nat#
[15:28..15:29): p <- recursion/Nats.Succ#p.
[15:31..15:32): N -> recursion/Nats.Succ#[N]
[15:42..15:45): Nat -> recursion/Nats.Nat#
[17:25..17:31): toIntg <- recursion/Nats.toIntg().
[17:39..17:40): n <- recursion/Nats.toIntg().(n)
[17:42..17:45): Nat -> recursion/Nats.Nat#
[17:48..17:51): Int -> scala/Int#
[18:11..18:12): n -> recursion/Nats.toIntg().(n)
[19:11..19:15): Zero -> recursion/Nats.Zero.
[20:11..20:15): Succ -> recursion/Nats.Succ.
[20:16..20:17): p <- local3
[20:22..20:28): toIntg -> recursion/Nats.toIntg().
[20:29..20:30): p -> local3
[20:32..20:33): + -> scala/Int#`+`(+4).
[23:6..23:9): j31 <- recursion/Nats.j31.
[23:12..23:18): toIntg -> recursion/Nats.toIntg().
[23:19..23:23): Zero -> recursion/Nats.Zero.
[23:24..23:26): ++ -> recursion/Nats.Nat#`++`().
[23:27..23:29): ++ -> recursion/Nats.Nat#`++`().
[23:30..23:32): ++ -> recursion/Nats.Nat#`++`().
[23:33..23:34): + -> recursion/Nats.Nat#`+`().
[23:35..23:39): Zero -> recursion/Nats.Zero.
[23:40..23:42): ++ -> recursion/Nats.Nat#`++`().

expect/semanticdb-Definitions.scala
-----------------------------------

Summary:
Schema => SemanticDB v4
Uri => semanticdb-Definitions.scala
Text => empty
Language => Scala
Symbols => 10 entries
Occurrences => 9 entries

Symbols:
a/Definitions. => final object Definitions extends Object { self: Definitions.type => +9 decls }
a/Definitions.D# => class D extends Object { self: D => +1 decls }
a/Definitions.D#`<init>`(). => primary ctor <init> (): D
a/Definitions.E# => trait E extends Object { self: E => +1 decls }
a/Definitions.E#`<init>`(). => primary ctor <init> (): E
a/Definitions.`b_=`(). => var method b_= (param x$1: Int): Unit
a/Definitions.`b_=`().(x$1) => param x$1: Int
a/Definitions.a. => val method a Int
a/Definitions.b(). => var method b Int
a/Definitions.c(). => method c => Int

Occurrences:
[0:8..0:9): a <- a/
[1:7..1:18): Definitions <- a/Definitions.
[2:6..2:7): a <- a/Definitions.a.
[3:6..3:7): b <- a/Definitions.b().
[4:6..4:7): c <- a/Definitions.c().
[5:2..5:2): <- a/Definitions.D#`<init>`().
[5:8..5:9): D <- a/Definitions.D#
[6:2..6:2): <- a/Definitions.E#`<init>`().
[6:8..6:9): E <- a/Definitions.E#

expect/semanticdb-Flags.scala
-----------------------------

Summary:
Schema => SemanticDB v4
Uri => semanticdb-Flags.scala
Text => empty
Language => Scala
Symbols => 50 entries
Occurrences => 78 entries
Synthetics => 2 entries

Symbols:
flags/p/package. => final package object p extends Object { self: p.type => +23 decls }
flags/p/package.AA# => class AA extends Object { self: AA => +5 decls }
flags/p/package.AA#`<init>`(). => primary ctor <init> (param x: Int, val param y: Int, var param z: Int): AA
flags/p/package.AA#`<init>`().(x) => param x: Int
flags/p/package.AA#`<init>`().(y) => val param y: Int
flags/p/package.AA#`<init>`().(z) => var param z: Int
flags/p/package.AA#`z_=`(). => var method z_= (param x$1: Int): Unit
flags/p/package.AA#`z_=`().(x$1) => param x$1: Int
flags/p/package.AA#x. => private[this] val method x Int
flags/p/package.AA#y. => val method y Int
flags/p/package.AA#z(). => var method z Int
flags/p/package.C# => abstract class C [covariant typeparam T , contravariant typeparam U , typeparam V ] extends Object { self: C[T, U, V] => +10 decls }
flags/p/package.C#[T] => covariant typeparam T 
flags/p/package.C#[U] => contravariant typeparam U 
flags/p/package.C#[V] => typeparam V 
flags/p/package.C#`<init>`(). => primary ctor <init> [covariant typeparam T , contravariant typeparam U , typeparam V ](param x: T, param y: U, param z: V): C[T, U, V]
flags/p/package.C#`<init>`().(x) => param x: T
flags/p/package.C#`<init>`().(y) => param y: U
flags/p/package.C#`<init>`().(z) => param z: V
flags/p/package.C#`<init>`(+1). => ctor <init> [covariant typeparam T , contravariant typeparam U , typeparam V ](): C[T, U, V]
flags/p/package.C#`<init>`(+2). => ctor <init> [covariant typeparam T , contravariant typeparam U , typeparam V ](param t: T): C[T, U, V]
flags/p/package.C#`<init>`(+2).(t) => param t: T
flags/p/package.C#w(). => abstract method w => Int
flags/p/package.C#x. => private[this] val method x T
flags/p/package.C#y. => private[this] val method y U
flags/p/package.C#z. => private[this] val method z V
flags/p/package.S# => class S [@specialized typeparam T ] extends Object { self: S[T] => +2 decls }
flags/p/package.S#[T] => @specialized typeparam T 
flags/p/package.S#`<init>`(). => primary ctor <init> [@specialized typeparam T ](): S[T]
flags/p/package.T1# => type T1  = Int
flags/p/package.T2# => type T2 [typeparam T ] = S[T]
flags/p/package.T2#[T] => typeparam T 
flags/p/package.U# => type U  <: Int
flags/p/package.V# => type V  >: Int
flags/p/package.X. => final case object X extends Object with Product with Serializable { self: X.type => +1 decls }
flags/p/package.Y# => final class Y extends Object { self: Y => +1 decls }
flags/p/package.Y#`<init>`(). => primary ctor <init> (): Y
flags/p/package.Z# => sealed trait Z extends Object { self: Z => +1 decls }
flags/p/package.Z#`<init>`(). => primary ctor <init> (): Z
flags/p/package.`y_=`(). => protected var method y_= (param x$1: Int): Unit
flags/p/package.`y_=`().(x$1) => param x$1: Int
flags/p/package.m(). => macro m [typeparam TT ]: Int
flags/p/package.m().[TT] => typeparam TT 
flags/p/package.x. => private[flags/p/] lazy val method x Int
flags/p/package.xs1. => val method xs1 Nothing
flags/p/package.y(). => protected implicit var method y Int
flags/p/package.z(). => method z (param pp: Int): Int
flags/p/package.z().(pp) => param pp: Int
local0 => val local xs2: Nothing
local1 => type t 

Occurrences:
[0:8..0:13): flags <- flags/
[2:7..2:12): scala -> scala/
[2:13..2:21): language -> scala/language.
[2:22..2:34): experimental -> scala/language.experimental.
[2:35..2:41): macros -> scala/language.experimental.macros.
[4:15..4:16): p <- flags/p/package.
[5:2..5:3): p -> flags/p/
[5:19..5:20): x <- flags/p/package.x.
[6:25..6:26): y <- flags/p/package.y().
[6:28..6:31): Int -> scala/Int#
[7:6..7:7): z <- flags/p/package.z().
[7:8..7:10): pp <- flags/p/package.z().(pp)
[7:12..7:15): Int -> scala/Int#
[8:6..8:7): m <- flags/p/package.m().
[8:8..8:10): TT <- flags/p/package.m().[TT]
[8:13..8:16): Int -> scala/Int#
[8:25..8:28): ??? -> scala/Predef.`???`().
[9:17..9:18): C <- flags/p/package.C#
[9:18..9:18): <- flags/p/package.C#`<init>`().
[9:20..9:21): T <- flags/p/package.C#[T]
[9:24..9:25): U <- flags/p/package.C#[U]
[9:27..9:28): V <- flags/p/package.C#[V]
[9:30..9:31): x <- flags/p/package.C#x.
[9:33..9:34): T -> flags/p/package.C#[T]
[9:36..9:37): y <- flags/p/package.C#y.
[9:39..9:40): U -> flags/p/package.C#[U]
[9:42..9:43): z <- flags/p/package.C#z.
[9:45..9:46): V -> flags/p/package.C#[V]
[10:8..10:12): <- flags/p/package.C#`<init>`(+1).
[10:22..10:25): ??? -> scala/Predef.`???`().
[10:27..10:30): ??? -> scala/Predef.`???`().
[10:32..10:35): ??? -> scala/Predef.`???`().
[11:8..11:12): <- flags/p/package.C#`<init>`(+2).
[11:13..11:14): t <- flags/p/package.C#`<init>`(+2).(t)
[11:16..11:17): T -> flags/p/package.C#[T]
[11:26..11:27): t -> flags/p/package.C#`<init>`(+2).(t)
[11:29..11:32): ??? -> scala/Predef.`???`().
[11:34..11:37): ??? -> scala/Predef.`???`().
[12:8..12:9): w <- flags/p/package.C#w().
[12:11..12:14): Int -> scala/Int#
[14:7..14:9): T1 <- flags/p/package.T1#
[14:12..14:15): Int -> scala/Int#
[15:7..15:9): T2 <- flags/p/package.T2#
[15:10..15:11): T <- flags/p/package.T2#[T]
[15:15..15:16): S -> flags/p/package.S#
[15:17..15:18): T -> flags/p/package.T2#[T]
[16:7..16:8): U <- flags/p/package.U#
[16:12..16:15): Int -> scala/Int#
[17:7..17:8): V <- flags/p/package.V#
[17:12..17:15): Int -> scala/Int#
[18:14..18:15): X <- flags/p/package.X.
[19:2..19:2): <- flags/p/package.Y#`<init>`().
[19:14..19:15): Y <- flags/p/package.Y#
[20:2..20:2): <- flags/p/package.Z#`<init>`().
[20:15..20:16): Z <- flags/p/package.Z#
[21:8..21:10): AA <- flags/p/package.AA#
[21:10..21:10): <- flags/p/package.AA#`<init>`().
[21:11..21:12): x <- flags/p/package.AA#x.
[21:14..21:17): Int -> scala/Int#
[21:23..21:24): y <- flags/p/package.AA#y.
[21:26..21:29): Int -> scala/Int#
[21:35..21:36): z <- flags/p/package.AA#z().
[21:38..21:41): Int -> scala/Int#
[22:8..22:9): S <- flags/p/package.S#
[22:9..22:9): <- flags/p/package.S#`<init>`().
[22:11..22:22): specialized -> scala/specialized#
[22:23..22:24): T <- flags/p/package.S#[T]
[23:6..23:10): List -> scala/package.List.
[23:11..23:14): xs1 <- flags/p/package.xs1.
[23:18..23:21): ??? -> scala/Predef.`???`().
[24:2..24:5): ??? -> scala/Predef.`???`().
[24:19..24:23): List -> scala/package.List.
[24:24..24:27): xs2 <- local0
[24:32..24:35): ??? -> scala/Predef.`???`().
[25:2..25:5): ??? -> scala/Predef.`???`().
[25:22..25:26): List -> scala/package.List#
[25:27..25:28): t <- local1
[25:33..25:36): ??? -> scala/Predef.`???`().

Synthetics:
[23:6..23:10):List => *.unapplySeq[Nothing]
[24:19..24:23):List => *.unapplySeq[Nothing]

expect/semanticdb-Types.scala
-----------------------------

Summary:
Schema => SemanticDB v4
Uri => semanticdb-Types.scala
Text => empty
Language => Scala
Symbols => 143 entries
Occurrences => 246 entries
Synthetics => 1 entries

Symbols:
local0 => abstract method k => Int
local1 => abstract method k => Int
local2 => method k => Int
local3 => final class $anon extends Object { self: $anon => +2 decls }
local5 => final class $anon extends M with N { self: $anon => +1 decls }
local7 => method k => Int
local8 => final class $anon extends M with N { self: $anon => +2 decls }
local10 => typeparam T 
local11 => type L [typeparam T ] = List[T]
types/B# => class B extends Object { self: B => +1 decls }
types/B#`<init>`(). => primary ctor <init> (): B
types/C# => class C extends Object { self: C => +1 decls }
types/C#`<init>`(). => primary ctor <init> (): C
types/Foo# => case class Foo extends Object with Product with Serializable { self: Foo => +5 decls }
types/Foo#_1(). => method _1 => "abc"
types/Foo#`<init>`(). => primary ctor <init> (val param s: "abc"): Foo
types/Foo#`<init>`().(s) => val param s: "abc"
types/Foo#copy$default$1(). => method copy$default$1 => "abc" @uncheckedVariance
types/Foo#copy(). => method copy (param s: "abc"): Foo
types/Foo#copy().(s) => param s: "abc"
types/Foo#s. => val method s "abc"
types/Foo. => final object Foo extends Object { self: Foo.type => +5 decls }
types/Foo.apply(). => method apply (param s: "abc"): Foo
types/Foo.apply().(s) => param s: "abc"
types/Foo.unapply(). => method unapply (param x$1: Foo): Foo
types/Foo.unapply().(x$1) => param x$1: Foo
types/Foo.x. => val method x "abc" @deprecated
types/Foo.y. => val method y "abc"
types/P# => class P extends Object { self: P => +8 decls }
types/P#C# => class C extends Object { self: C => +1 decls }
types/P#C#`<init>`(). => primary ctor <init> (): C
types/P#X# => class X extends Object { self: X => +1 decls }
types/P#X#`<init>`(). => primary ctor <init> (): X
types/P#`<init>`(). => primary ctor <init> (): P
types/P#x. => val method x X
types/T# => class T extends Object { self: T => +8 decls }
types/T#C# => class C extends Object { self: C => +1 decls }
types/T#C#`<init>`(). => primary ctor <init> (): C
types/T#X# => class X extends Object { self: X => +1 decls }
types/T#X#`<init>`(). => primary ctor <init> (): X
types/T#`<init>`(). => primary ctor <init> (): T
types/T#x. => val method x X
types/Test. => final object Test extends Object { self: Test.type => +10 decls }
types/Test.C# => class C extends M { self: C => +42 decls }
types/Test.C#ByNameType. => final object ByNameType extends Object { self: ByNameType.type => +2 decls }
types/Test.C#ByNameType.m1(). => method m1 (param x: => Int): Int
types/Test.C#ByNameType.m1().(x) => param x: => Int
types/Test.C#ClassInfoType1. => final object ClassInfoType1 extends Object { self: ClassInfoType1.type => +1 decls }
types/Test.C#ClassInfoType2# => class ClassInfoType2 extends B { self: ClassInfoType2 => +2 decls }
types/Test.C#ClassInfoType2#`<init>`(). => primary ctor <init> (): ClassInfoType2
types/Test.C#ClassInfoType2#x(). => method x => Int
types/Test.C#ClassInfoType3# => trait ClassInfoType3 [typeparam T ] extends Object { self: ClassInfoType3[T] => +2 decls }
types/Test.C#ClassInfoType3#[T] => typeparam T 
types/Test.C#ClassInfoType3#`<init>`(). => primary ctor <init> [typeparam T ](): ClassInfoType3[T]
types/Test.C#Either. => val method Either Either.type
types/Test.C#MethodType. => final object MethodType extends Object { self: MethodType.type => +7 decls }
types/Test.C#MethodType.m3(). => method m3 => Int
types/Test.C#MethodType.m4(). => method m4 (): Int
types/Test.C#MethodType.m5(). => method m5 (param x: Int): Int
types/Test.C#MethodType.m5().(x) => param x: Int
types/Test.C#MethodType.m6(). => method m6 [typeparam T ](param x: T): T
types/Test.C#MethodType.m6().(x) => param x: T
types/Test.C#MethodType.m6().[T] => typeparam T 
types/Test.C#MethodType.x1(). => method x1 => Int
types/Test.C#MethodType.x2(). => method x2 => Int
types/Test.C#RepeatedType# => case class RepeatedType extends Object with Product with Serializable { self: RepeatedType => +4 decls }
types/Test.C#RepeatedType#_1(). => method _1 => String*
types/Test.C#RepeatedType#`<init>`(). => primary ctor <init> (val param s: String*): RepeatedType
types/Test.C#RepeatedType#`<init>`().(s) => val param s: String*
types/Test.C#RepeatedType#m1(). => method m1 (param x: Int*): Int
types/Test.C#RepeatedType#m1().(x) => param x: Int*
types/Test.C#RepeatedType#s. => val method s String*
types/Test.C#RepeatedType. => final object RepeatedType extends Object { self: RepeatedType.type => +4 decls }
types/Test.C#RepeatedType.apply(). => method apply (param s: String*): RepeatedType
types/Test.C#RepeatedType.apply().(s) => param s: String*
types/Test.C#RepeatedType.toString(). => method toString => String <: scala/Any#toString().
types/Test.C#RepeatedType.unapplySeq(). => method unapplySeq (param x$1: RepeatedType): RepeatedType
types/Test.C#RepeatedType.unapplySeq().(x$1) => param x$1: RepeatedType
types/Test.C#TypeType. => final object TypeType extends Object { self: TypeType.type => +6 decls }
types/Test.C#TypeType.T1# => type T1 
types/Test.C#TypeType.T4# => type T4  = C
types/Test.C#TypeType.T5# => type T5 [typeparam U ] = U
types/Test.C#TypeType.T5#[U] => typeparam U 
types/Test.C#TypeType.m2(). => method m2 [typeparam T2  = C]: Nothing
types/Test.C#TypeType.m2().[T2] => typeparam T2  = C
types/Test.C#TypeType.m3(). => method m3 [typeparam M3 [type _ ]]: Nothing
types/Test.C#TypeType.m3().[M3] => typeparam M3 [type _ ]
types/Test.C#TypeType.m3().[M3][_] => type _ 
types/Test.C#`<init>`(). => primary ctor <init> (): C
types/Test.C#annType1. => val method annType1 T @ann[T]
types/Test.C#annType2. => val method annType2 T @ann1 @ann2
types/Test.C#compoundType1. => val method compoundType1 Object { abstract method k => Int }
types/Test.C#compoundType2. => val method compoundType2 M & N
types/Test.C#compoundType3. => val method compoundType3 M & N { abstract method k => Int }
types/Test.C#compoundType4. => val method compoundType4 Object
types/Test.C#compoundType5. => val method compoundType5 M & N
types/Test.C#compoundType6. => val method compoundType6 M & N
types/Test.C#existentialType2. => val method existentialType2 List[_] forSome { type _  }
types/Test.C#existentialType3. => val method existentialType3 Class[_] forSome { type _  }
types/Test.C#existentialType4. => val method existentialType4 Class[_] forSome { type _  }
types/Test.C#p. => val method p P
types/Test.C#singleType1. => val method singleType1 x.type
types/Test.C#singleType2. => val method singleType2 p.x.type
types/Test.C#superType1. => val method superType1 Int
types/Test.C#superType2. => val method superType2 Int
types/Test.C#superType3. => val method superType3 Int
types/Test.C#thisType1. => val method thisType1 C.this.type
types/Test.C#thisType2. => val method thisType2 C.this.type
types/Test.C#typeLambda1(). => method typeLambda1 [typeparam M [type _ ]]: Nothing
types/Test.C#typeLambda1().[M] => typeparam M [type _ ]
types/Test.C#typeLambda1().[M][_] => type _ 
types/Test.C#typeRef1. => val method typeRef1 C
types/Test.C#typeRef2. => val method typeRef2 p.C
types/Test.C#typeRef3. => val method typeRef3 T#C
types/Test.C#typeRef4. => val method typeRef4 List[Int]
types/Test.C#x. => val method x p.X
types/Test.Literal. => final object Literal extends Object { self: Literal.type => +12 decls }
types/Test.Literal.bool. => final val method bool true
types/Test.Literal.char. => final val method char 'a'
types/Test.Literal.clazzOf. => final val method clazzOf Option[Int]
types/Test.Literal.double. => final val method double 2.0
types/Test.Literal.float. => final val method float 1.0f
types/Test.Literal.int. => final val method int 1
types/Test.Literal.javaEnum. => final val method javaEnum LinkOption
types/Test.Literal.long. => final val method long 1L
types/Test.Literal.nil. => final val method nil Null
types/Test.Literal.string. => final val method string "a"
types/Test.Literal.unit. => final val method unit Unit
types/Test.M# => class M extends Object { self: M => +2 decls }
types/Test.M#`<init>`(). => primary ctor <init> (): M
types/Test.M#m(). => method m => Int
types/Test.N# => trait N extends Object { self: N => +2 decls }
types/Test.N#`<init>`(). => primary ctor <init> (): N
types/Test.N#n(). => method n => Int
types/ann# => class ann [typeparam T ] extends Annotation with StaticAnnotation { self: ann[T] => +3 decls }
types/ann#[T] => typeparam T 
types/ann#`<init>`(). => primary ctor <init> [typeparam T ](param x: T): ann[T]
types/ann#`<init>`().(x) => param x: T
types/ann#x. => private[this] val method x T
types/ann1# => class ann1 extends Annotation with StaticAnnotation { self: ann1 => +1 decls }
types/ann1#`<init>`(). => primary ctor <init> (): ann1
types/ann2# => class ann2 extends Annotation with StaticAnnotation { self: ann2 => +1 decls }
types/ann2#`<init>`(). => primary ctor <init> (): ann2

Occurrences:
[0:8..0:13): types <- types/
[2:7..2:12): scala -> scala/
[2:13..2:21): language -> scala/language.
[2:22..2:34): existentials -> scala/language.existentials.
[3:7..3:12): scala -> scala/
[3:13..3:21): language -> scala/language.
[3:22..3:33): higherKinds -> scala/language.higherKinds.
[5:6..5:9): ann <- types/ann#
[5:9..5:9): <- types/ann#`<init>`().
[5:10..5:11): T <- types/ann#[T]
[5:13..5:14): x <- types/ann#x.
[5:16..5:17): T -> types/ann#[T]
[5:27..5:32): scala -> scala/
[5:33..5:43): annotation -> scala/annotation/
[5:44..5:60): StaticAnnotation -> scala/annotation/StaticAnnotation#
[6:6..6:10): ann1 <- types/ann1#
[6:19..6:24): scala -> scala/
[6:19..6:19): <- types/ann1#`<init>`().
[6:25..6:35): annotation -> scala/annotation/
[6:36..6:52): StaticAnnotation -> scala/annotation/StaticAnnotation#
[7:6..7:10): ann2 <- types/ann2#
[7:19..7:24): scala -> scala/
[7:19..7:19): <- types/ann2#`<init>`().
[7:25..7:35): annotation -> scala/annotation/
[7:36..7:52): StaticAnnotation -> scala/annotation/StaticAnnotation#
[9:0..9:0): <- types/B#`<init>`().
[9:6..9:7): B <- types/B#
[11:0..11:0): <- types/C#`<init>`().
[11:6..11:7): C <- types/C#
[13:6..13:7): P <- types/P#
[14:2..14:2): <- types/P#C#`<init>`().
[14:2..14:2): <- types/P#`<init>`().
[14:8..14:9): C <- types/P#C#
[15:2..15:2): <- types/P#X#`<init>`().
[15:8..15:9): X <- types/P#X#
[16:6..16:7): x <- types/P#x.
[16:14..16:15): X -> types/P#X#
[19:6..19:7): T <- types/T#
[20:2..20:2): <- types/T#C#`<init>`().
[20:2..20:2): <- types/T#`<init>`().
[20:8..20:9): C <- types/T#C#
[21:2..21:2): <- types/T#X#`<init>`().
[21:8..21:9): X <- types/T#X#
[22:6..22:7): x <- types/T#x.
[22:14..22:15): X -> types/T#X#
[25:11..25:14): Foo <- types/Foo#
[25:14..25:14): <- types/Foo#`<init>`().
[25:15..25:16): s <- types/Foo#s.
[27:7..27:10): Foo <- types/Foo.
[28:6..28:7): x <- types/Foo.x.
[28:16..28:26): deprecated -> scala/deprecated#
[29:6..29:7): y <- types/Foo.y.
[29:17..29:18): x -> types/Foo.x.
[32:7..32:11): Test <- types/Test.
[33:8..33:9): M <- types/Test.M#
[34:4..34:4): <- types/Test.M#`<init>`().
[34:8..34:9): m <- types/Test.M#m().
[34:11..34:14): Int -> scala/Int#
[34:17..34:20): ??? -> scala/Predef.`???`().
[37:8..37:9): N <- types/Test.N#
[38:4..38:4): <- types/Test.N#`<init>`().
[38:8..38:9): n <- types/Test.N#n().
[38:11..38:14): Int -> scala/Int#
[38:17..38:20): ??? -> scala/Predef.`???`().
[41:8..41:9): C <- types/Test.C#
[41:18..41:19): M -> types/Test.M#
[41:18..41:18): <- types/Test.C#`<init>`().
[42:8..42:9): p <- types/Test.C#p.
[42:16..42:17): P -> types/P#
[43:8..43:9): x <- types/Test.C#x.
[43:12..43:13): p -> types/Test.C#p.
[43:14..43:15): x -> types/P#x.
[45:8..45:16): typeRef1 <- types/Test.C#typeRef1.
[45:18..45:19): C -> types/Test.C#
[45:22..45:25): ??? -> scala/Predef.`???`().
[46:8..46:16): typeRef2 <- types/Test.C#typeRef2.
[46:18..46:19): p -> types/Test.C#p.
[46:20..46:21): C -> types/P#C#
[46:24..46:27): ??? -> scala/Predef.`???`().
[47:8..47:16): typeRef3 <- types/Test.C#typeRef3.
[47:18..47:19): T -> types/T#
[47:20..47:21): C -> types/T#C#
[47:24..47:27): ??? -> scala/Predef.`???`().
[48:8..48:16): typeRef4 <- types/Test.C#typeRef4.
[48:18..48:22): List -> scala/package.List#
[48:23..48:26): Int -> scala/Int#
[48:30..48:33): ??? -> scala/Predef.`???`().
[50:8..50:19): singleType1 <- types/Test.C#singleType1.
[50:21..50:22): x -> types/Test.C#x.
[50:30..50:33): ??? -> scala/Predef.`???`().
[51:8..51:19): singleType2 <- types/Test.C#singleType2.
[51:21..51:22): p -> types/Test.C#p.
[51:23..51:24): x -> types/P#x.
[51:32..51:35): ??? -> scala/Predef.`???`().
[52:8..52:14): Either <- types/Test.C#Either.
[52:17..52:22): scala -> scala/
[52:23..52:27): util -> scala/util/
[52:28..52:34): Either -> scala/util/Either.
[54:8..54:17): thisType1 <- types/Test.C#thisType1.
[54:31..54:34): ??? -> scala/Predef.`???`().
[55:8..55:17): thisType2 <- types/Test.C#thisType2.
[55:33..55:36): ??? -> scala/Predef.`???`().
[57:8..57:18): superType1 <- types/Test.C#superType1.
[57:27..57:28): m -> types/Test.M#m().
[58:8..58:18): superType2 <- types/Test.C#superType2.
[58:30..58:31): m -> types/Test.M#m().
[59:8..59:18): superType3 <- types/Test.C#superType3.
[59:32..59:33): m -> types/Test.M#m().
[61:8..61:21): compoundType1 <- types/Test.C#compoundType1.
[61:29..61:30): k <- local0
[61:32..61:35): Int -> scala/Int#
[61:40..61:43): ??? -> scala/Predef.`???`().
[62:8..62:21): compoundType2 <- types/Test.C#compoundType2.
[62:23..62:24): M -> types/Test.M#
[62:30..62:31): N -> types/Test.N#
[62:34..62:37): ??? -> scala/Predef.`???`().
[63:8..63:21): compoundType3 <- types/Test.C#compoundType3.
[63:23..63:24): M -> types/Test.M#
[63:30..63:31): N -> types/Test.N#
[63:38..63:39): k <- local1
[63:41..63:44): Int -> scala/Int#
[63:49..63:52): ??? -> scala/Predef.`???`().
[64:8..64:21): compoundType4 <- types/Test.C#compoundType4.
[64:24..64:24): <- local3
[64:34..64:35): k <- local2
[64:37..64:40): Int -> scala/Int#
[64:43..64:46): ??? -> scala/Predef.`???`().
[65:8..65:21): compoundType5 <- types/Test.C#compoundType5.
[65:24..65:24): <- local5
[65:28..65:29): M -> types/Test.M#
[65:35..65:36): N -> types/Test.N#
[66:8..66:21): compoundType6 <- types/Test.C#compoundType6.
[66:24..66:24): <- local8
[66:28..66:29): M -> types/Test.M#
[66:35..66:36): N -> types/Test.N#
[66:43..66:44): k <- local7
[66:46..66:49): Int -> scala/Int#
[66:52..66:55): ??? -> scala/Predef.`???`().
[68:8..68:16): annType1 <- types/Test.C#annType1.
[68:18..68:19): T -> types/T#
[68:31..68:34): ??? -> scala/Predef.`???`().
[69:8..69:16): annType2 <- types/Test.C#annType2.
[69:18..69:19): T -> types/T#
[69:21..69:25): ann1 -> types/ann1#
[69:27..69:31): ann2 -> types/ann2#
[69:34..69:37): ??? -> scala/Predef.`???`().
[71:8..71:24): existentialType2 <- types/Test.C#existentialType2.
[71:26..71:30): List -> scala/package.List#
[71:36..71:39): ??? -> scala/Predef.`???`().
[72:8..72:24): existentialType3 <- types/Test.C#existentialType3.
[72:27..72:32): Class -> java/lang/Class#
[72:33..72:40): forName -> java/lang/Class#forName().
[73:8..73:24): existentialType4 <- types/Test.C#existentialType4.
[73:27..73:32): Class -> java/lang/Class#
[73:33..73:40): forName -> java/lang/Class#forName().
[75:8..75:19): typeLambda1 <- types/Test.C#typeLambda1().
[75:20..75:21): M <- types/Test.C#typeLambda1().[M]
[75:28..75:31): ??? -> scala/Predef.`???`().
[76:4..76:15): typeLambda1 -> types/Test.C#typeLambda1().
[76:24..76:25): L <- local11
[76:26..76:27): T <- local10
[76:31..76:35): List -> scala/package.List#
[76:36..76:37): T -> local10
[78:11..78:25): ClassInfoType1 <- types/Test.C#ClassInfoType1.
[79:10..79:24): ClassInfoType2 <- types/Test.C#ClassInfoType2#
[79:33..79:34): B -> types/B#
[79:33..79:33): <- types/Test.C#ClassInfoType2#`<init>`().
[79:41..79:42): x <- types/Test.C#ClassInfoType2#x().
[80:10..80:24): ClassInfoType3 <- types/Test.C#ClassInfoType3#
[80:24..80:24): <- types/Test.C#ClassInfoType3#`<init>`().
[80:25..80:26): T <- types/Test.C#ClassInfoType3#[T]
[82:11..82:21): MethodType <- types/Test.C#MethodType.
[83:10..83:12): x1 <- types/Test.C#MethodType.x1().
[83:14..83:17): Int -> scala/Int#
[83:20..83:23): ??? -> scala/Predef.`???`().
[84:10..84:12): x2 <- types/Test.C#MethodType.x2().
[84:14..84:17): Int -> scala/Int#
[84:20..84:23): ??? -> scala/Predef.`???`().
[85:10..85:12): m3 <- types/Test.C#MethodType.m3().
[85:14..85:17): Int -> scala/Int#
[85:20..85:23): ??? -> scala/Predef.`???`().
[86:10..86:12): m4 <- types/Test.C#MethodType.m4().
[86:16..86:19): Int -> scala/Int#
[86:22..86:25): ??? -> scala/Predef.`???`().
[87:10..87:12): m5 <- types/Test.C#MethodType.m5().
[87:13..87:14): x <- types/Test.C#MethodType.m5().(x)
[87:16..87:19): Int -> scala/Int#
[87:22..87:25): Int -> scala/Int#
[87:28..87:31): ??? -> scala/Predef.`???`().
[88:10..88:12): m6 <- types/Test.C#MethodType.m6().
[88:13..88:14): T <- types/Test.C#MethodType.m6().[T]
[88:16..88:17): x <- types/Test.C#MethodType.m6().(x)
[88:19..88:20): T -> types/Test.C#MethodType.m6().[T]
[88:23..88:24): T -> types/Test.C#MethodType.m6().[T]
[88:27..88:30): ??? -> scala/Predef.`???`().
[91:11..91:21): ByNameType <- types/Test.C#ByNameType.
[92:10..92:12): m1 <- types/Test.C#ByNameType.m1().
[92:13..92:14): x <- types/Test.C#ByNameType.m1().(x)
[92:19..92:22): Int -> scala/Int#
[92:25..92:28): Int -> scala/Int#
[92:31..92:34): ??? -> scala/Predef.`???`().
[95:15..95:27): RepeatedType <- types/Test.C#RepeatedType#
[95:27..95:27): <- types/Test.C#RepeatedType#`<init>`().
[95:28..95:29): s <- types/Test.C#RepeatedType#s.
[95:31..95:37): String -> scala/Predef.String#
[96:10..96:12): m1 <- types/Test.C#RepeatedType#m1().
[96:13..96:14): x <- types/Test.C#RepeatedType#m1().(x)
[96:16..96:19): Int -> scala/Int#
[96:23..96:26): Int -> scala/Int#
[96:29..96:30): s -> types/Test.C#RepeatedType#s.
[96:31..96:37): length -> scala/collection/SeqOps#length().
[99:11..99:19): TypeType <- types/Test.C#TypeType.
[100:11..100:13): T1 <- types/Test.C#TypeType.T1#
[101:10..101:12): m2 <- types/Test.C#TypeType.m2().
[101:13..101:15): T2 <- types/Test.C#TypeType.m2().[T2]
[101:19..101:20): C -> types/Test.C#
[101:24..101:25): C -> types/Test.C#
[101:29..101:32): ??? -> scala/Predef.`???`().
[102:10..102:12): m3 <- types/Test.C#TypeType.m3().
[102:13..102:15): M3 <- types/Test.C#TypeType.m3().[M3]
[102:22..102:25): ??? -> scala/Predef.`???`().
[103:11..103:13): T4 <- types/Test.C#TypeType.T4#
[103:16..103:17): C -> types/Test.C#
[104:11..104:13): T5 <- types/Test.C#TypeType.T5#
[104:14..104:15): U <- types/Test.C#TypeType.T5#[U]
[104:19..104:20): U -> types/Test.C#TypeType.T5#[U]
[108:9..108:16): Literal <- types/Test.Literal.
[109:14..109:17): int <- types/Test.Literal.int.
[110:14..110:18): long <- types/Test.Literal.long.
[111:14..111:19): float <- types/Test.Literal.float.
[112:14..112:20): double <- types/Test.Literal.double.
[113:14..113:17): nil <- types/Test.Literal.nil.
[114:14..114:18): char <- types/Test.Literal.char.
[115:14..115:20): string <- types/Test.Literal.string.
[116:14..116:18): bool <- types/Test.Literal.bool.
[117:14..117:18): unit <- types/Test.Literal.unit.
[118:14..118:22): javaEnum <- types/Test.Literal.javaEnum.
[118:25..118:29): java -> java/
[118:30..118:33): nio -> java/nio/
[118:34..118:38): file -> java/nio/file/
[118:39..118:49): LinkOption -> java/nio/file/LinkOption#
[118:50..118:64): NOFOLLOW_LINKS -> java/nio/file/LinkOption#NOFOLLOW_LINKS.
[119:14..119:21): clazzOf <- types/Test.Literal.clazzOf.
[119:24..119:31): classOf -> scala/Predef.classOf().
[119:32..119:38): Option -> scala/Option#
[119:39..119:42): Int -> scala/Int#

Synthetics:
[68:20..68:24):@ann => *[Int]

expect/semanticdb-extract.scala
-------------------------------

Summary:
Schema => SemanticDB v4
Uri => semanticdb-extract.scala
Text => empty
Language => Scala
Symbols => 18 entries
Occurrences => 21 entries
Synthetics => 3 entries

Symbols:
_empty_/AnObject. => final object AnObject extends Object { self: AnObject.type => +6 decls }
_empty_/AnObject.Foo# => case class Foo extends Object with Product with Serializable { self: Foo => +5 decls }
_empty_/AnObject.Foo#_1(). => method _1 => Int
_empty_/AnObject.Foo#`<init>`(). => primary ctor <init> (val param x: Int): Foo
_empty_/AnObject.Foo#`<init>`().(x) => val param x: Int
_empty_/AnObject.Foo#copy$default$1(). => method copy$default$1 => Int @uncheckedVariance
_empty_/AnObject.Foo#copy(). => method copy (param x: Int): Foo
_empty_/AnObject.Foo#copy().(x) => param x: Int
_empty_/AnObject.Foo#x. => val method x Int
_empty_/AnObject.Foo. => final object Foo extends Object { self: Foo.type => +4 decls }
_empty_/AnObject.Foo.apply(). => method apply (param x: Int): Foo
_empty_/AnObject.Foo.apply().(x) => param x: Int
_empty_/AnObject.Foo.toString(). => method toString => String <: scala/Any#toString().
_empty_/AnObject.Foo.unapply(). => method unapply (param x$1: Foo): Foo
_empty_/AnObject.Foo.unapply().(x$1) => param x$1: Foo
_empty_/AnObject.foo(). => method foo (param x: Int): Unit
_empty_/AnObject.foo().(x) => param x: Int
_empty_/AnObject.foo(+1). => method foo (): Unit

Occurrences:
[0:7..0:15): AnObject <- _empty_/AnObject.
[2:6..2:9): foo <- _empty_/AnObject.foo().
[2:10..2:11): x <- _empty_/AnObject.foo().(x)
[2:13..2:16): Int -> scala/Int#
[3:6..3:9): foo <- _empty_/AnObject.foo(+1).
[3:13..3:17): Unit -> scala/Unit#
[5:2..5:5): foo -> _empty_/AnObject.foo().
[6:2..6:5): foo -> _empty_/AnObject.foo(+1).
[8:5..8:14): substring -> java/lang/String#substring().
[9:5..9:14): substring -> java/lang/String#substring(+1).
[11:2..11:6): List -> scala/package.List.
[12:2..12:6): List -> scala/package.List.
[12:7..12:12): apply -> scala/collection/IterableFactory#apply().
[13:2..13:6): List -> scala/package.List.
[13:7..13:14): `apply` -> scala/collection/IterableFactory#apply().
[14:2..14:9): println -> scala/Predef.println(+1).
[14:12..14:13): + -> scala/Int#`+`(+4).
[16:13..16:16): Foo <- _empty_/AnObject.Foo#
[16:16..16:16): <- _empty_/AnObject.Foo#`<init>`().
[16:17..16:18): x <- _empty_/AnObject.Foo#x.
[16:20..16:23): Int -> scala/Int#

Synthetics:
[11:2..11:6):List => *.apply[Int]
[12:2..12:12):List.apply => *[Nothing]
[13:2..13:14):List.`apply` => *[Nothing]

expect/toplevel.scala
---------------------

Summary:
Schema => SemanticDB v4
Uri => toplevel.scala
Text => empty
Language => Scala
Symbols => 18 entries
Occurrences => 43 entries
Synthetics => 2 entries

Symbols:
_empty_/MyProgram# => final class MyProgram extends Object { self: MyProgram => +2 decls }
_empty_/readInts# => final class readInts extends Object { self: readInts => +2 decls }
_empty_/toplevel$package. => final package object _empty_ extends Object { self: _empty_.type => +9 decls }
_empty_/toplevel$package.MyProgram(). => @main method MyProgram (param times: Int): Unit
_empty_/toplevel$package.MyProgram().(times) => param times: Int
_empty_/toplevel$package.a. => val inline method a ""
_empty_/toplevel$package.combine(). => method combine (param x: Int)(param y: Int): Int
_empty_/toplevel$package.combine().(x) => param x: Int
_empty_/toplevel$package.combine().(y) => param y: Int
_empty_/toplevel$package.combine(+1). => method combine (param x: Int, param y: Int, param z: Int): Int
_empty_/toplevel$package.combine(+1).(x) => param x: Int
_empty_/toplevel$package.combine(+1).(y) => param y: Int
_empty_/toplevel$package.combine(+1).(z) => param z: Int
_empty_/toplevel$package.combine(+2). => method combine => Int
_empty_/toplevel$package.foo(). => method foo => String
_empty_/toplevel$package.fooRef(). => method fooRef => String
_empty_/toplevel$package.readInts(). => @main method readInts (param ints: Int*): Unit
_empty_/toplevel$package.readInts().(ints) => param ints: Int*

Occurrences:
[0:11..0:12): a <- _empty_/toplevel$package.a.
[1:11..1:12): x <- _empty_/toplevel$package.combine().(x)
[1:14..1:17): Int -> scala/Int#
[1:23..1:30): combine <- _empty_/toplevel$package.combine().
[1:32..1:33): y <- _empty_/toplevel$package.combine().(y)
[1:35..1:38): Int -> scala/Int#
[1:42..1:43): x -> _empty_/toplevel$package.combine().(x)
[1:44..1:45): + -> scala/Int#`+`(+4).
[1:46..1:47): y -> _empty_/toplevel$package.combine().(y)
[2:4..2:11): combine <- _empty_/toplevel$package.combine(+1).
[2:12..2:13): x <- _empty_/toplevel$package.combine(+1).(x)
[2:15..2:18): Int -> scala/Int#
[2:20..2:21): y <- _empty_/toplevel$package.combine(+1).(y)
[2:23..2:26): Int -> scala/Int#
[2:28..2:29): z <- _empty_/toplevel$package.combine(+1).(z)
[2:31..2:34): Int -> scala/Int#
[2:38..2:39): x -> _empty_/toplevel$package.combine(+1).(x)
[2:40..2:41): + -> scala/Int#`+`(+4).
[2:42..2:43): y -> _empty_/toplevel$package.combine(+1).(y)
[2:44..2:45): + -> scala/Int#`+`(+4).
[2:46..2:47): z -> _empty_/toplevel$package.combine(+1).(z)
[3:4..3:11): combine <- _empty_/toplevel$package.combine(+2).
[4:4..4:7): foo <- _empty_/toplevel$package.foo().
[5:1..5:5): main -> scala/main#
[5:10..5:19): MyProgram <- _empty_/toplevel$package.MyProgram().
[5:20..5:25): times <- _empty_/toplevel$package.MyProgram().(times)
[5:27..5:30): Int -> scala/Int#
[5:33..5:37): Unit -> scala/Unit#
[5:43..5:45): to -> scala/runtime/RichInt#to().
[5:46..5:51): times -> _empty_/toplevel$package.MyProgram().(times)
[5:53..5:60): foreach -> scala/collection/immutable/Range#foreach().
[5:67..5:74): println -> scala/Predef.println(+1).
[6:1..6:5): main -> scala/main#
[6:10..6:18): readInts <- _empty_/toplevel$package.readInts().
[6:19..6:23): ints <- _empty_/toplevel$package.readInts().(ints)
[6:25..6:28): Int -> scala/Int#
[6:32..6:36): Unit -> scala/Unit#
[6:39..6:46): println -> scala/Predef.println(+1).
[6:47..6:51): ints -> _empty_/toplevel$package.readInts().(ints)
[6:52..6:60): mkString -> scala/collection/IterableOnceOps#mkString(+1).
[7:4..7:10): fooRef <- _empty_/toplevel$package.fooRef().
[7:13..7:29): toplevel$package -> _empty_/toplevel$package.
[7:30..7:33): foo -> _empty_/toplevel$package.foo().

Synthetics:
[5:40..5:60):(1 to times) foreach => *[Unit]
[5:41..5:42):1 => intWrapper(*)

