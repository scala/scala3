-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:23:11 --------------------------------------
23 |    cur = (() => f.write()) :: Nil // error
   |           ^^^^^^^^^^^^^^^^^^^^^^^
   |           Found:    List[box () ->{f} Unit]
   |           Required: List[box () ->{xs*} Unit]
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:34:7 ---------------------------------------
34 |      (() => f.write()) :: Nil // error
   |       ^^^^^^^^^^^^^^^^^^^^^^^
   |       Found:    List[box () ->{f} Unit]
   |       Required: box List[box () ->{xs*} Unit]^?
   |
   |       Note that reference (f : File^), defined in method $anonfun
   |       cannot be included in outer capture set {xs*} of value cur
   |
   | longer explanation available when compiling with `-explain`
-- Error: tests/neg-custom-args/captures/reaches.scala:37:6 ------------------------------------------------------------
37 |  var cur: List[Proc] = xs   // error
   |      ^
   |      Mutable variable cur cannot have type List[box () => Unit] since
   |      the part box () => Unit of that type captures the root capability `cap`.
-- Error: tests/neg-custom-args/captures/reaches.scala:44:16 -----------------------------------------------------------
44 |  val cur = Ref[List[Proc]](xs) // error
   |                ^^^^^^^^^^
   |                Type variable T of constructor Ref cannot be instantiated to List[box () => Unit] since
   |                the part box () => Unit of that type captures the root capability `cap`.
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:46:35 --------------------------------------
46 |    val next: () => Unit = cur.get.head // error
   |                           ^^^^^^^^^^^^
   |                           Found:    () => Unit
   |                           Required: () ->{fresh} Unit
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:48:20 --------------------------------------
48 |    cur.set(cur.get.tail: List[Proc]) // error
   |            ^^^^^^^^^^^^
   |            Found:    List[box () => Unit]
   |            Required: List[box () ->{fresh} Unit]
   |
   | longer explanation available when compiling with `-explain`
-- Error: tests/neg-custom-args/captures/reaches.scala:54:51 -----------------------------------------------------------
54 |  val id: Id[Proc, Proc] = new Id[Proc, () -> Unit] // error
   |                                                   ^
   |                                Type variable A of constructor Id cannot be instantiated to box () => Unit since
   |                                that type captures the root capability `cap`.
-- Error: tests/neg-custom-args/captures/reaches.scala:56:6 ------------------------------------------------------------
56 |    id(() => f.write()) // error
   |    ^^^^^^^^^^^^^^^^^^^
   |    Local reach capability id* leaks into capture scope of method test
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:63:27 --------------------------------------
63 |    val f1: File^{id*} = id(f) // error, since now id(f): File^ // error
   |                         ^^^^^
   |                         Found:    File^{f}
   |                         Required: File^{id*}
   |
   | longer explanation available when compiling with `-explain`
-- Error: tests/neg-custom-args/captures/reaches.scala:80:10 -----------------------------------------------------------
80 |  ps.map((x, y) => compose1(x, y)) // error // error // error sepcheck
   |          ^
   |          Local reach capability ps* leaks into capture scope of method mapCompose.
   |          To allow this, the parameter ps should be declared with a @use annotation
-- Error: tests/neg-custom-args/captures/reaches.scala:80:13 -----------------------------------------------------------
80 |  ps.map((x, y) => compose1(x, y)) // error // error // error sepcheck
   |             ^
   |             Local reach capability ps* leaks into capture scope of method mapCompose.
   |             To allow this, the parameter ps should be declared with a @use annotation
-- Error: tests/neg-custom-args/captures/reaches.scala:80:31 -----------------------------------------------------------
80 |  ps.map((x, y) => compose1(x, y)) // error // error // error sepcheck
   |                               ^
   |                               Separation failure: argument of type  (x$0: A) ->{y} box A^?
   |                               to method compose1: [A, B, C](f: A => B, g: B => C): A ->{f, g} C
   |                               corresponds to capture-polymorphic formal parameter g of type  box A^? => box A^?
   |                               and captures {ps*}, but this capability is also passed separately
   |                               in the first argument with type  (x$0: A) ->{x} box A^?.
   |
   |                                 Capture set of first argument         : {x}
   |                                 Hidden set of current argument        : {y}
   |                                 Footprint of first argument           : {x, ps*}
   |                                 Hidden footprint of current argument  : {y, ps*}
   |                                 Declared footprint of current argument: {}
   |                                 Undeclared overlap of footprints      : {ps*}
-- Error: tests/neg-custom-args/captures/reaches.scala:83:31 -----------------------------------------------------------
83 |  ps.map((x, y) => compose1(x, y)) // error sepcheck
   |                               ^
   |                               Separation failure: argument of type  (x$0: A) ->{y} box A^?
   |                               to method compose1: [A, B, C](f: A => B, g: B => C): A ->{f, g} C
   |                               corresponds to capture-polymorphic formal parameter g of type  box A^? => box A^?
   |                               and captures {ps*}, but this capability is also passed separately
   |                               in the first argument with type  (x$0: A) ->{x} box A^?.
   |
   |                                 Capture set of first argument         : {x}
   |                                 Hidden set of current argument        : {y}
   |                                 Footprint of first argument           : {x, ps*}
   |                                 Hidden footprint of current argument  : {y, ps*}
   |                                 Declared footprint of current argument: {}
   |                                 Undeclared overlap of footprints      : {ps*}
-- Error: tests/neg-custom-args/captures/reaches.scala:62:31 -----------------------------------------------------------
62 |  val leaked = usingFile[File^{id*}]: f => // error
   |                               ^^^
   |                               id* cannot be tracked since its deep capture set is empty
-- Error: tests/neg-custom-args/captures/reaches.scala:63:18 -----------------------------------------------------------
63 |    val f1: File^{id*} = id(f) // error, since now id(f): File^ // error
   |                  ^^^
   |                  id* cannot be tracked since its deep capture set is empty
