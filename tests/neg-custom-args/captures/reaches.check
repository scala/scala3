-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:22:13 --------------------------------------
22 |  usingFile: f => // error
   |             ^
   |             Found:    (f: File^?) ->? Unit
   |             Required: (f: File^) ->{fresh} Unit
23 |    cur = (() => f.write()) :: Nil
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:32:13 --------------------------------------
32 |  usingFile: f => // error
   |             ^
   |             Found:    (f: File^?) ->? Unit
   |             Required: (f: File^) ->{fresh} Unit
33 |    cur.set:
34 |      (() => f.write()) :: Nil
   |
   | longer explanation available when compiling with `-explain`
-- Error: tests/neg-custom-args/captures/reaches.scala:37:6 ------------------------------------------------------------
37 |  var cur: List[Proc] = xs   // error
   |      ^
   |      Mutable variable cur cannot have type List[box () => Unit] since
   |      the part box () => Unit of that type captures the root capability `cap`.
-- Error: tests/neg-custom-args/captures/reaches.scala:44:16 -----------------------------------------------------------
44 |  val cur = Ref[List[Proc]](xs) // error
   |                ^^^^^^^^^^
   |                Type variable T of constructor Ref cannot be instantiated to List[box () => Unit] since
   |                the part box () => Unit of that type captures the root capability `cap`.
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:46:35 --------------------------------------
46 |    val next: () => Unit = cur.get.head // error
   |                           ^^^^^^^^^^^^
   |                           Found:    () => Unit
   |                           Required: () ->{fresh} Unit
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:48:20 --------------------------------------
48 |    cur.set(cur.get.tail: List[Proc]) // error
   |            ^^^^^^^^^^^^
   |            Found:    List[box () => Unit]
   |            Required: List[box () ->{fresh} Unit]
   |
   | longer explanation available when compiling with `-explain`
-- Error: tests/neg-custom-args/captures/reaches.scala:54:51 -----------------------------------------------------------
54 |  val id: Id[Proc, Proc] = new Id[Proc, () -> Unit] // error
   |                                                   ^
   |                                Type variable A of constructor Id cannot be instantiated to box () => Unit since
   |                                that type captures the root capability `cap`.
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:59:27 --------------------------------------
59 |  val id: File^ -> File^ = x => x // error
   |                           ^^^^^^
   |                           Found:    (x: File^) ->? File^{x}
   |                           Required: (x: File^) -> File^{fresh}
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:62:38 --------------------------------------
62 |  val leaked = usingFile[File^{id*}]: f => // error // error
   |                                      ^
   |                                      Found:    (f: File^?) ->? box File^?
   |                                      Required: (f: File^) ->{fresh} box File^{id*}
63 |    val f1: File^{id*} = id(f)
64 |    f1
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:67:32 --------------------------------------
67 |  val id: (x: File^) -> File^ = x => x // error
   |                                ^^^^^^
   |                            Found:    (x: File^) ->? File^{x}
   |                            Required: (x: File^) -> File^{localcap}
   |
   |                            Note that the existential capture root in File^
   |                            cannot subsume the capability x.type since that capability is not a SharedCapability
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:70:38 --------------------------------------
70 |  val leaked = usingFile[File^{id*}]: f => // error // error
   |                                      ^
   |                                      Found:    (f: File^?) ->? box File^?
   |                                      Required: (f: File^) ->{fresh} box File^{id*}
71 |    val f1: File^{id*} = id(f)
72 |    f1
   |
   | longer explanation available when compiling with `-explain`
-- Error: tests/neg-custom-args/captures/reaches.scala:88:10 -----------------------------------------------------------
88 |  ps.map((x, y) => compose1(x, y)) // error
   |          ^
   |          Local reach capability ps* leaks into capture scope of method mapCompose.
   |          To allow this, the parameter ps should be declared with a @use annotation
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reaches.scala:91:10 --------------------------------------
91 |  ps.map((x, y) => compose1(x, y)) // error
   |          ^^^^^^^^^^^^^^^^^^^^^^^
   |          Found:    (x$1: (box (x$0: A^) ->? A^?, box (x$0: A^) ->? A^?)^?) ->? box (x$0: A^?) ->? A^?
   |          Required: (x$1: (box A ->{ps*} A, box A ->{ps*} A)) ->{fresh} box (x$0: A^?) ->? A^?
   |
   | longer explanation available when compiling with `-explain`
-- Error: tests/neg-custom-args/captures/reaches.scala:62:31 -----------------------------------------------------------
62 |  val leaked = usingFile[File^{id*}]: f => // error // error
   |                               ^^^
   |                               id* cannot be tracked since its deep capture set is empty
-- Error: tests/neg-custom-args/captures/reaches.scala:70:31 -----------------------------------------------------------
70 |  val leaked = usingFile[File^{id*}]: f => // error // error
   |                               ^^^
   |                               id* cannot be tracked since its deep capture set is empty
