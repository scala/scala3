-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reference-cc.scala:44:29 ---------------------------------
44 |  val later = usingLogFile { file => () => file.write(0) } // error
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |Capability file outlives its scope: it leaks into outer capture set 's1 which is owned by value later.
   |The leakage occurred when trying to match the following types:
   |
   |Found:    (file: java.io.FileOutputStream^'s2) ->'s3 () ->{file} Unit
   |Required: java.io.FileOutputStream^ => () ->'s1 Unit
   |
   |where:    => refers to a root capability created in value later when checking argument to parameter op of method usingLogFile
   |          ^  refers to the universal root capability
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reference-cc.scala:47:25 ---------------------------------
47 |  val xs = usingLogFile: f => // error
   |                         ^
   |Capability f outlives its scope: it leaks into outer capture set 's4 which is owned by value xs.
   |The leakage occurred when trying to match the following types:
   |
   |Found:    (f: java.io.FileOutputStream^'s5) ->'s6 LzyList[Int]^{f}
   |Required: java.io.FileOutputStream^ => LzyList[Int]^'s4
   |
   |where:    => refers to a root capability created in value xs when checking argument to parameter op of method usingLogFile
   |          ^  refers to the universal root capability
   |
48 |    LzyList(1, 2, 3).map { x => f.write(x); x * x }
   |
   | longer explanation available when compiling with `-explain`
-- [E007] Type Mismatch Error: tests/neg-custom-args/captures/reference-cc.scala:58:8 ----------------------------------
58 |    try () => xs.map(f).sum  // error TODO improve error message
   |        ^^^^^^^^^^^^^^^^^^^
   |Found:    () ->{canThrow$1} Double
   |Required: () => Double
   |
   |Note that capability canThrow$1 is not included in capture set {cap}
   |because (canThrow$1 : CanThrow[LimitExceeded]) in an enclosing try expression is not visible from cap in an enclosing function.
   |
   |where:    => and cap refer to a root capability created in anonymous function of type (using erased x$1: CanThrow[LimitExceeded]): () => Double when instantiating expected result type () ->{capÂ²} Double of function literal
   |
   | longer explanation available when compiling with `-explain`
