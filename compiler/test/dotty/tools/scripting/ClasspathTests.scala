package dotty
package tools
package scripting

import java.io.File
import java.nio.file.{Files, Paths, Path}

import org.junit.Test

import vulpix.TestConfiguration

import scala.sys.process._
import scala.jdk.CollectionConverters._
import dotty.tools.dotc.config.Properties._

/** Test java command line generated by bin/scala and bin/scalac */
class ClasspathTests:
  val packBinDir = "dist/target/pack/bin"
  val packLibDir = "dist/target/pack/lib"

  def exists(scriptPath: Path): Boolean = Files.exists(scriptPath)
  def packBinScalaExists:Boolean = exists(Paths.get(s"$packBinDir/scala"))

  /*
   * verify classpath reported by called script.
   */
  @Test def hashbangClasspathVerifyTest = {
    // only interested in classpath test scripts
    val testScriptName = "classpathReport.sc"
    val testScript = scripts("/scripting").find { _.getName.matches(testScriptName) } match
      case None => sys.error(s"test script not found: ${testScriptName}")
      case Some(file) => file

    val relpath = testScript.toPath.relpath.norm
    printf("===> hashbangClasspathVerifyTest for script [%s]\n", relpath)
    printf("bash is [%s]\n", bashExe)

    if packBinScalaExists then
      val bashCmdline = s"SCALA_OPTS= $relpath"
      val cmd = Array(bashExe, "-c", bashCmdline)

      cmd.foreach { printf("[%s]\n", _) }

      // test script reports the classpath it sees
      val scriptOutput = exec(cmd:_*)
      val scriptCwd = findTaggedLine("cwd", scriptOutput)
      printf("script ran in directory [%s]\n", scriptCwd)
      val scriptCp = findTaggedLine("classpath", scriptOutput)

      val hashbangClasspathJars = scriptCp.split(psep).map { _.getName }.sorted.distinct
      val packlibJars = listJars(s"$scriptCwd/$packLibDir").sorted.distinct

      printf("%d jar files in dist/target/pack/lib\n", packlibJars.size)
      printf("%d test script jars in classpath\n", hashbangClasspathJars.size)

      // verify that the classpath set in the hashbang line is effective
      if hashbangClasspathJars.size != packlibJars.size then
        printf("hashbangClasspathJars: %s\n", hashbangClasspathJars.mkString("\n ", "\n ", ""))

      assert(hashbangClasspathJars.size == packlibJars.size)
  }
  /*
   * verify classpath is unglobbed by MainGenericRunner.
   */
  @Test def unglobClasspathVerifyTest = {
    val testScriptName = "unglobClasspath.sc"
    val testScript = scripts("/scripting").find { _.getName.matches(testScriptName) } match
      case None => sys.error(s"test script not found: ${testScriptName}")
      case Some(file) => file

    val relpath = testScript.toPath.relpath.norm
    printf("===> unglobClasspathVerifyTest for script [%s]\n", relpath)
    printf("bash is [%s]\n", bashExe)

    if packBinScalaExists then
      val bashCmdline = s"SCALA_OPTS= $relpath"
      val cmd = Array(bashExe, "-c", bashCmdline)

      cmd.foreach { printf("[%s]\n", _) }

      // test script reports the classpath it sees
      val scriptOutput = exec(cmd:_*)
      val scriptCp = findTaggedLine("unglobbed classpath", scriptOutput)
      val classpathJars = scriptCp.split(psep).map { _.getName }.sorted.distinct
      //classpathJars.foreach { printf("%s\n", _) }
      assert(classpathJars.size > 1)
  }


//////////////// end of tests ////////////////
lazy val cwd = Paths.get(".").toAbsolutePath
lazy val wildcardEntry = "dist/target/pack/lib/*"

def listJars(dir: String) =
  val packlibDir = Paths.get(dir).toFile
  if packlibDir.isDirectory then
    packlibDir.listFiles.toList.map { _.getName }.filter { _.endsWith(".jar") }
  else
    Nil

import scala.jdk.CollectionConverters._
lazy val env:Map[String, String] = System.getenv.asScala.toMap

// script output expected as "<tag>: <value>"
def findTaggedLine(tag: String, lines: Seq[String]): String =
  lines.find { _.startsWith(tag) } match
    case None =>
      lines.foreach { System.err.printf("line[%s]\n", _) }
      sys.error(s"no $tag: found in script output")
    case Some(cwd) => cwd.dropWhile( _ != ' ').trim // discard tag

def exec(cmd: String *): Seq[String] = Process(cmd).lazyLines_!.toList

def which(str:String) =
  var out = ""
  path.find { entry =>
    val it = Paths.get(entry).toAbsolutePath
    it.toFile.isDirectory && {
      var testpath = s"$it/$str".norm
      val test = Paths.get(testpath)
      if test.toFile.exists then
        out = testpath
        true
      else
        val test = Paths.get(s"$it/$str.exe".norm)
        if test.toFile.exists then
          out = testpath
          true
        else
          false
      }
    }

  out

def bashExe = which("bash")
def unameExe = which("uname")
def path = envOrElse("PATH", "").split(psep).toList
def psep = sys.props("path.separator")

def cygwin = ostype == "cygwin"
def mingw = ostype == "mingw"
def msys = ostype == "msys"
def winshell = cygwin || mingw || msys

def ostypeFull = if unameExe.nonEmpty then exec(unameExe).mkString else ""
def ostype = ostypeFull.toLowerCase.takeWhile{ cc => cc >= 'a' && cc <='z' || cc >= 'A' && cc <= 'Z' }

extension(p:Path)
  def relpath: Path = cwd.relativize(p)
  def norm: String = p.toString.replace('\\', '/')

extension(path: String)
  def getName: String = norm.replaceAll(".*/", "")

  // Normalize path separator, convert relative path to absolute
  def norm: String =
    path.replace('\\', '/') match {
      case s if s.secondChar == ":" => s // .drop(2) // path without drive letter
      case s if s.startsWith("./") => s.drop(2)
      case s => s
    }

  def parent: String = norm.replaceAll("/[^/]*$", "")

  // convert to absolute path relative to cwd.
  def absPath: String = norm match
    case str if str.isAbsolute => norm
    case _ => Paths.get(userDir, norm).toString.norm

  def isDir: Boolean = Files.isDirectory(Paths.get(path))

  def toUrl: String = Paths.get(absPath).toUri.toURL.toString

  // Treat norm paths with a leading '/' as absolute.
  // Windows java.io.File#isAbsolute treats them as relative.
  def isAbsolute = path.norm.startsWith("/") || (isWin && path.secondChar == ":")
  def secondChar: String = path.take(2).drop(1).mkString("")

extension (str: String) def dropExtension =
  str.reverse.dropWhile(_ != '.').drop(1).reverse

//extension(f: File) def absPath =
//f.getAbsolutePath.replace('\\', '/')

