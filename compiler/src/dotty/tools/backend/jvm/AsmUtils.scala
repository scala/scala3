package dotty.tools
package backend
package jvm

import scala.jdk.CollectionConverters.*
import scala.tools.asm.tree.*
import scala.tools.asm.util.{TraceClassVisitor, TraceMethodVisitor, Textifier, ASMifier}
import scala.tools.asm.ClassReader
import dotty.tools.backend.jvm.analysis.InitialProducer

import java.io.{PrintWriter, StringWriter}

// TODO RENAME this is all about logging (and could it not depend on InitialProducer? it's a bit weird)
object AsmUtils {

  /**
   * Print the bytecode of methods generated by GenBCode to the standard output. Only methods
   * whose name contains `traceMethodPattern` are traced.
   */
  final val traceMethodEnabled = sys.env.contains("printBCODE")
  final val traceMethodPattern = sys.env.getOrElse("printBCODE", "")

  /**
   * Print the bytecode of classes generated by GenBCode to the standard output.
   */
  inline val traceClassEnabled = false
  inline val traceClassPattern = ""

  /**
   * Print the bytecode of classes as they are serialized by the ASM library. The serialization
   * performed by `asm.ClassWriter` can change the code generated by GenBCode. For example, it
   * introduces stack map frames, it computes the maximal stack sizes, and it replaces dead
   * code by NOPs (see also https://github.com/scala/scala/pull/3726#issuecomment-42861780).
   */
  inline val traceSerializedClassEnabled = false
  inline val traceSerializedClassPattern = ""

  def traceMethod(mnode: MethodNode1): Unit = {
    println(s"Bytecode for method ${mnode.name}")
    val p = new Textifier
    val tracer = new TraceMethodVisitor(p)
    mnode.accept(tracer)
    val w = new PrintWriter(System.out)
    p.print(w)
    w.flush()
  }

  def traceClass(cnode: ClassNode1): Unit = {
    println(s"Bytecode for class ${cnode.name}")
    val w = new PrintWriter(System.out)
    cnode.accept(new TraceClassVisitor(w))
    w.flush()
  }

  def traceClass(bytes: Array[Byte]): Unit = traceClass(readClass(bytes))

  def readClass(bytes: Array[Byte]): ClassNode1 = {
    val node = new ClassNode1()
    new ClassReader(bytes).accept(node, 0)
    node
  }

  def instructionString(instruction: AbstractInsnNode): String = instruction.getOpcode match {
    case -1 => instruction.toString
    case op => scala.tools.asm.util.Printer.OPCODES(op)
  }

  /**
   * Returns a human-readable representation of the cnode ClassNode.
   */
  def textify(cnode: ClassNode): String = {
    val trace = new TraceClassVisitor(new PrintWriter(new StringWriter))
    cnode.accept(trace)
    val sw = new StringWriter
    val pw = new PrintWriter(sw)
    trace.p.print(pw)
    sw.toString
  }

  /**
   * Returns a human-readable representation of the code in the mnode MethodNode.
   */
  def textify(mnode: MethodNode): String = {
    val trace = new TraceClassVisitor(new PrintWriter(new StringWriter))
    mnode.accept(trace)
    val sw = new StringWriter
    val pw = new PrintWriter(sw)
    trace.p.print(pw)
    sw.toString
  }

  /**
   * Returns a human-readable representation of the given instruction.
   */
  def textify(insn: AbstractInsnNode): String = insn match {
    case _: InitialProducer =>
      insn.toString
    case _ =>
      val trace = new TraceMethodVisitor(new Textifier)
      insn.accept(trace)
      val sw = new StringWriter
      val pw = new PrintWriter(sw)
      trace.p.print(pw)
      sw.toString.trim
  }

  /**
   * Returns a human-readable representation of the given instruction sequence.
   */
  def textify(insns: Iterator[AbstractInsnNode]): String = {
    val trace = new TraceMethodVisitor(new Textifier)
    insns.foreach(_.accept(trace))
    val sw: StringWriter = new StringWriter
    val pw: PrintWriter = new PrintWriter(sw)
    trace.p.print(pw)
    sw.toString.trim
  }

  def asmify(cnode: ClassNode): String = {
    val trace = new TraceClassVisitor(null, new ASMifier(), null)
    cnode.accept(trace)
    val sw = new StringWriter
    val pw = new PrintWriter(sw)
    trace.p.print(pw)
    sw.toString
  }

  /**
   * Returns a human-readable representation of the given instruction sequence.
   */
  def textify(insns: InsnList): String = textify(insns.iterator.asScala)

}
